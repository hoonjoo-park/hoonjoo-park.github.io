{"pages":[],"posts":[{"title":"[Node.js] 11047번 : 동전 0","text":"문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) 출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다. 풀이 과정 실수로 완전탐색 방식으로 풀어버릴 뻔 했다….처음 풀어보는 그리디 알고리즘 유형이었어서 여러 풀이법들을 참고했다. 그리디 알고리즘…? 그리디 알고리즘은 모든 경우의 수를 탐색하는 알고리즘이 아니다. 따라서 경우에 따라 내가 도출한 답이 최적의 답이 아닐 수도 있다. ( 하지만 빠를 수는 있음 ) 코드 로직 우선 N값과 K값을 선언해준다. 카운트를 세야 하기 때문에 count 변수 또한 선언해준다. 그리디 알고리즘이기 때문에, 작은 값에서 큰 값으로 탐색하는 것은 비효율적이다. 따라서, 배열의 가장 우측에서부터 차례대로 탐색하는 것이 빠른 해답을 찾기 위한 방법일 것이다. for문 또한 i가 감소하는 식으로 구성한다. 우측에서부터 진행되기 때문에 최소 조합을 구성하기 위해선 K/Arr[i]가 count에 담기면 된다. 그리고 K값은 해당 Arr[i]값으로 나눈 나머지, 즉 K%= Arr[i]가 되면 된다. 이렇게 반복문을 계속 돌리면 우측에서부터 탐색했을 경우의 최소 동전 집합의 개수를 구할 수 있다. 소스 코드123456789101112function coin(arr, NK) { // K와 N 선언 const N = NK[0]; let K = NK[1]; let count = 0; // 합이 K가 되는 동전 조합의 최소값 구하기 for (let i = N - 1; i &gt; 0; i--) { count += Math.floor(K / arr[i]); K %= arr[i]; } return count;}","link":"/algorithm/boj/11047/"},{"title":"1.네트워크의 기본","text":"네트워크란 무엇인가? 네트워크란, 한 마디로 “연결”을 의미한다.학교도 선생님과 학생들을 이어주는 네트워크, 회사도, 집도 모두 네트워크의 일환이다. 컴퓨터 네트워크 ⇒ 하지만 컴퓨터 네트워크는 “데이터를 주고 받기 위한 네트워크”를 의미한다. 카톡 메시지를 주고 받는 것, 인터넷에서 정보를 검색하거나 작성하는 것 모두 데이터의 전달 과정이 그 기반이 된다. 사설 네트워크 (인트라넷) 사설 네트워크는 사용자의 제한을 두는 제한적인 네트워크다. ⇒ 인트라넷, LAN 등이 이에 포함될 수 있다. 인터넷 누구나 접속이 가능한 네트워크다 ⇒ 해커, 옆집 강아지(?), 할아버지 할머니 등등 브라우저를 통해 누구든지 인터넷에 접속할 수 있다. LAN과 WAN LAN과 WAN은 사설 네트워크(인트라넷 등)에 사용되는 네트워크다. LAN (Local Area Network) ⇒ 가까운 범위 내의 기기들을 라우터 등을 통해 연결시키고, 기기 간의 데이터 통신 등이 가능하도록 네트워크를 구성한다. 즉, 가까운 거리에 있는 기계와 기계를 연결시킨다! WAN (Wide Area Network) ⇒ 위의 LAN을 다른 거점의 LAN과 연결시킬 수 있도록 연결해주는 역할을 한다.즉, LAN과 LAN의 연결을 돕는 징검다리라고 생각하면 편하다. 인터넷 그렇다면 근거리 기기간의 통신이 아닌, 각기 떨어져 있는 세상의 모든 사람들과 통신할 수 있는 방법은 뭘까? → 바로 인터넷이다. AS와 ISP AS : 자율 시스템(Autonomous System)⇒ 전세계의 다양한 조직들이 운영하는 네트워크조직 등을 구성하는 네트워크 생태계 ISP : Internet Service Provider⇒ 쉽게 설명하자면, 네트워크 서비스를 제공해주는 기업을 의미한다. 1티어 ISP로는 SKT, KT, LG U+ 등이 있다. 하위 티어의 영세 ISP도 많은데, 이들의 통신은 어쩔 수 없이 1티어 ISP를 경유할 수밖에 없다즉, 우리는 인터넷을 이용하고자 한다면… 1티어 ISP를 반드시 사용하게 된다. 서버와 클라이언트, 그리고 애플리케이션 인터넷을 통해 데이터를 주고받는다는 것은 알겠다.그렇다면 그 데이터가 도대체 어떻게 저장되고 어디에 저장되는 것인가? 서버와 클라이언트 클라이언트 서버 일반적인 우리들의 컴퓨터 굉장히 좋은 컴퓨터 주로 서버에 데이터를 “요청(Reuest)” 클라이언트로 부터 요청을 처리 (Response) ⇒ 클라이언트(우리)는 서버에 어떠한 특정 요청을 보내고 → 서버는 이러한 요청을 처리한 뒤 응답(Response)를 보내준다. 고객이 레스토랑에서 웨이터에게 주문을 하는 것과 같다고 보면 된다. 이러한 이유 때문에 서버의 컴퓨터 성능은 고성능이 요구된다. 애플리케이션 서버에서 데이터를 받아 처리하는 역할을 하는 것이 애플리케이션이다.클라이언트 사이드에서 반환된 데이터를 받아내는 것 또한 클라이언트의 애플리케이션이다. 네트워크 아키텍처와 프로토콜 그럼 어떤 방식으로 데이터를 주고 받을까?⇒ 네트워크를 통한 올바른 데이터 송수신을 위해선 규칙과 규약 등이 필요하다. 프로토콜 ⇒ 우리가 한국어를 사용할 때 막 사용하는 것이 아니듯이, 네트워크 또한 통신을 할 때 자기가 원하는 대로 규칙없이 대화를 하지는 않는다. 한국어에도 문법, 훈민정음, 발음, 상황에 따른 용법 등 다양한 규칙과 기준이 존재하듯, 네트워크 통신에도 이러한 다양한 규칙(프로토콜)들이 존재한다. 즉, 프로토콜은 네트워크 통신을 위한 규약이자 규칙들의 단편들이다. 네트워크 아키텍처 ⇒ 위의 프로토콜들이 종합된 것이 네트워크 아키텍처다.한국어, 영어와 같이 하나의 언어라고 생각하면 된다. TCP/IP 전세계적으로 영어가 공용어로 통하듯이, 대부분 통용되는 네트워크 아키텍처의 표준은 TCP/IP다. 이러한 네트워크 아키텍처를 효율적으로 운용하기 위해 아키텍처는 프로토콜들을 단순히 집약해놓은 것이 아니라, 계층화 하여 기능별로 구분해 둔다. TCP/IP의 계층 애플리케이션 계층 트랜스포트 계층 인터넷층 네트워크 인터페이스층 클라우드 네트워크 전통적인 방식은 회사 등이 자체적으로 서버를 구축하여 운용하고 관리하는 것이었다.하지만 시대가 변함에 따라, 인터넷만 통해서 가상의 (물리적으로 떨어져있는) 서버를 구축할 수 있게 되었고, 우리는 이를 클라우드 서비스라고 부른다. 클라우드 서비스의 종류 Iaas : 하드웨어만 사용 가능 Paas : 하드웨어와 OS, Middleware등의 시스템 플랫폼을 활용 가능하다. Saas : 하드웨어와 플랫폼 뿐만 아니라, 애플리케이션 기능까지 모두 사용 가능하다⇒ 대표적인 예로 AWS를 들 수 있다.","link":"/cs/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98%20%EA%B8%B0%EB%B3%B8/"},{"title":"Javascript는 어떻게 작동하는가?","text":"💡 사전 지식 Parse : 컴퓨터가 이해할 수 있도록 프로그래밍 언어가 데이터를 가공하고 읽기 위해 일정한 포맷으로 변환하는 것. (쉽게 말하면, 사람의 언어 구조 → 컴퓨터의 언어 구조로 변환되는 것이라 봐도 될 것 같다) Thread : 프로그램 내에서의 작업 또는 프로세스의 경로 자바스크립트 개요 JS는 컴파일이 필요 없는 Interpreter 언어이다. JS는 변수를 설정할 때 특정 문자열타입을 지정하지 않고 let과 const에 구분없이 담을 수 있다. (동적 타입) 이러한 타입 시스템의 부재로 정적타입 언어인 C, C++에 비해 자바스크립트는 효율성이 떨어지고 느리다. 그렇다면 이렇게 비효율적이고 느린 언어를 계속 사용하는가? 이를 이해하기 위해선, 자바스크립트의 역사에 대해 간략히 짚고 넘어가야 한다. JS의 역사 1990년대의 웹 브라우저들은 매우 정적이고 비상호적인 페이지들을 띄우는 역할만을 담당했었다. 하지만 이후 웹 브라우저에서의 상호작용성을 더하기 위해 1995년 Netscape의 브랜든 아이크(Brendan Eich)에 의해 10일만에 개발된 Javascript가 세상에 공개되었고, 이는 혁신을 일으켰다. 하지만 여러 경쟁사들이 이러한 동적이고 상호적인 브라우저 언어의 개발에 뛰어들었고, 브라우저마다 언어가 달랐기에 호환성 등의 문제가 발발했다. 이에 따라 ECMA Script라는 브라우저 언어에 대한 약속이자 문법을 담은 문서가 개발된 것이다. 그렇게 표준화 되어가는 것 처럼 보이던 ECMA Script에 의한 브라우저 언어의 안정성과 호환성은 마이크로소프트 사의 ECMA 참여 거부로 점점 불안정해지기 시작한다. 그러나, Jesse James라는 개발자가 AJAX를 제안했고, 2008년 생태계 교란종이라고 할 수 있는 강력한 Chrome의 등장으로 위기를 느낀 다른 브라우저들의 협력을 통해 ES5, ES6 등의 문서들이 이후 작성되었다. 드디어 JS는 성숙하고 안정된 언어로 자리잡을 수 있게 된 것이다. 이제 JS가 브라우저에서 어떻게 “실행(Implemented)”되어야 하는지는 ES에 의해 정의됐다.그렇다면 “어떻게” 작동되어야 하는지는 무엇이 결정하는가? ⇒ JS엔진에 대한 이해가 필요하다. 자바스크립트 엔진 모든 브라우저는 JS코드를 실행하기 위한 JS 엔진을 탑재하고 있다 (Netscape는 SpiderMonkey라는 엔진을, Chrome은 V8엔진을 사용한다). 가장 기초적인 엔진구조(SpiderMonkey)는 JS소스코드를 컴파일 하여 Bytecode로 만드는 baseline compiler → 그리고 이 Bytecode를 머신코드(Binary Code)로 변환하여 최종적으로 CPU에서 실행되게 하는 Interpreter가 존재한다. 하지만 이러한 기초적 엔진구조는 컴파일 시간의 단축에만 집중할 뿐, 코드의 최적화에는 목적을 두지 않는다. 따라서 위와 같은 기초적 엔진구조는 아주 동적이고 인터렉티브한 웹 어플리케이션을 구동하는데 무리가 있다. 이러한 문제점들을 해결하기 위해 구글(Google)은 V8엔진을 사용한다. V8은 Baseline Compiler로써 Full-Codegen을 사용하고, 최적화를 위한 Crankshaft를 사용한다. 기존과 같이 Full-Codegen은 최적화를 신경쓰지 않고 최대한 빨리 Binary Code를 반환한다. 하지만 이러한 과정 중에 소스코드의 최적화를 진행해 최적화된 코드를 Full-Codegen이 반환한 코드의 일부와 대체한다. 즉, 빠른 컴파일과 최적화를 행한다는 것이다. 어떻게 작동되는지에 대한 프로세스는 이제 알겠다. 그렇다면 그 “최적화”라는 것은 어떻게 이루어지는가? 자바스크립트의 최적화 위에서 설명했듯, JS는 타입 시스템이 없고, 더 나아가 프로파일링 데이터(Profiling Data)를 수집하며 느리게 실행되는 코드를 감별하느라 CPU에 부담을 준다. 이에 따라 2017년에 새로 개발된 것이 새로운 V8엔진이다. 새로운 버전의 V8 엔진에는 Ignition이라는 파이프라인이 추가됐다. 이는 **베이스라인의 기능( JS 소스코드 → 바이트 코드로 변환) + 인터프리터의 기능(바이너리 코드로의 변환)**이 이루어지는 파이프라인이다. 그리고 Turbo Fan은 Ignition으로 부터 프로파일링 데이터를 넘겨받아 Hot코드 (CPU에 부담을 주는 코드)를 최적화 할 지, 말 지를 결정한다. 런타임에서의 JS 자바스크립트는 single-threaded 언어다. 즉, 자바스크립트는 코드가 실행될 때 모든 코드가 한 덩어리로써 한번에 실행된다는 것이다. 이러한 싱글 스레드 방식의 문제점은, 실행시간이 오래걸리는 코드가 중간에 껴있으면, 그 후의 코드 실행에 악영향을 미친다는 것이다. 따라서 이러한 블락(또는 무한루프) 문제점이 발생하면 브라우저의 모든 기능들은 중단된다는 문제점을 갖는다. 하지만 다행히도, 이제는 대부분의 브라우저들이 멀티탭 기능들을 탑재하고 있기에, 브라우저별 스레드가 아닌 탭(Tab)별 스레드가 적용되기 때문에 하나의 탭에만 싱글 스레드 문제점이 적용된다. 이렇듯 자바스크립트는 싱글 스레디드 언어이기 때문에 하나의 힙 메모리와 하나의 스택을 갖는다. 스택에서의 코드 실행 방식과 pop 방식은 아래와 같이 LIFO(후입선출)를 따른다. 이와 같은 싱글 스레드 방식만을 따르면, 브라우저는 HTTP 요청을 보내거나 받는 동안 다른 모든 핵심 기능들을 (캐싱, 데이터베이스 스토리지, DOM 이벤트 리스닝 등등) 사용하지 못할 것이다. 이를 해결하기 위해 자바스크립트만의 스레드는 독립적으로 두되, 브라우저 자체 내에서 다른 스레드를 구성하여 DOM 이벤트 리스닝, 캐싱, 데이터베이스 스토리지 등을 자바스크립트와는 독립적으로 기능할 수 있도록 하는 것이다. 이러한 독립적 스레드를 사용하는 브라우저 기능 중에는 Web API 요청을 위한 fetch() 가 있다. 이 fetch()는 자바스크립트 엔진 내의 스레드를 사용하지 않기 때문에 비동기적으로 작동하고, 이러한 비동기 방식 때문에 우리는 fetch()를 사용할 때 콜백함수를 사용하고, async await과 같은 비동기 처리 방식들을 사용하는 것이다. 1234567891011121314151617function printHello() { console.log('Hello from baz');}function three() { setTimeout(printHello, 3000);}function two() { three();}function one() { two();}one(); Event Loop : 콜스택과 콜백 큐를 주시하며, 콜스택이 비어있고, 콜백 큐에 처리해야 할 스택이 존재한다면 해당 스택을 콜스택으로 옮겨 쌓아 올리는 역할을 한다. 이와 비슷하게 setTimeout() 또한, 콜스택과 메시지큐, 이벤트루프에 의한 독립적 스레드에 의해 효율적으로 작동된다. 먼저 위의 코드를 보면 one() → two() → three() 순으로 코드가 실행될 것이다. 하지만 three()의 setTimeout()내의 콜백함수인 printHello()는 자바스크립트에 의해 webAPI로 보내질 것이고 자바스크립트 엔진 자체에서 3초를 기다리는 것이 아닌, 자바스크립트 자체는 이후 바로 다음 라인의 코드로 넘어간다. 하지만 다음 라인의 코드가 없기에 자바스크립트는 콜스택에서 three two one을 순서대로 pop할 것이다. 하지만 3초 뒤 콜백함수(printHello)는 webAPI에 의해 메시지큐에 담길 것이고, 이벤트루프가 이 콜백함수를 다시 콜스택 위에 올릴 것이다. 그렇게 setTimeout과 그 안의 콜백함수가 실행되는 것이다.","link":"/javascript/base/javascript-howItWorks/"},{"title":"콜백과 프로미스 (Callback &amp; Promise)","text":"콜백 함수 (Callback Function) 비동기 처리 방식의 문제점을 해결하기 위해, 특정 로직 수행이 완료됐을 때 원하는 동작을 실행시킬 수 있도록 하는 함수! 레스토랑 예약을 예시로 들 수 있다. 우리는 레스토랑 예약을 통해 우리가 원하는 시간대에 웨이팅 없이 식사를 편하게 즐길 수 있고, 웨이팅을 하는 대신 그 시간을 자유롭게 활용할 수 있다. 즉, 예약한 시간대**(로직 수행이 완료됐을 때)에 우리는 식당에 가서 먹기로 했던 메뉴를 시켜먹으면 되는 것이다(동작)**. 😈 콜백 지옥 우리는 가끔, 비동기 처리를 위해 콜백함수를 중첩하여 사용하는 경우를 맞이하는데…이를 콜백 지옥(Callback Hell)이라고 부른다.이렇게 콜백 함수가 꼬리에 꼬리를 무는 형식은 가독성도 떨어지고 변경 및 유지보수가 어렵다. ⇒ 이러한 콜백 지옥 문제를 해결하기 위해 필요한 것이 Promise와 Async다. 🤙 프로미스란? “A promise is an object that may produce a single value some time in the future” =&gt; 자바스크립트 비동기 처리에 사용되는 객체로, 미래에 특정한 value를 생성해낸다.“미래에 하나의 value를 생성해낼 것이라는 약속!” 콜백 함수와 프로미스의 차이점? 콜백 함수와 프로미스 모두 비동기적 처리 방식의 문제점을 해결하기 위한 함수라는 점에서는 동일하다.하지만 Promise는 이러한 콜백함수들이 한 객체로써 뭉쳐서 중첩되어있지 않고분리된 객체로써 논리적으로 상호 연결될 수 있도록 하는 하나의 절차적 함수라고 보면 된다. 프로미스의 구조 new Promise() resolve() then() 프로미스의 상태(state) Pending(대기) : 비동기처리 로직이 아직 미완료된 상태 123new Promise(function (resolve, reject) { // ...}); Fullfilled(이행) : 비동기 처리가 완료 → 프로미스가 결과값을 반환 123456789101112//resolve가 됐고, 이제 then을 활용해 처리 결과값을 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { const data = 100; resolve(data); });}// resolve()의 결과 값 data를 resolvedData로 받음getData().then(function (resolvedData) { console.log(resolvedData); // 100}); Rejected(실패) : 비동기 처리의 오류/실패 12345678910111213//이렇게 리젝트에 대한 결과값(실패 이유)을 아래의 catch()를 통해 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { reject(new Error('Request is failed')); });}// reject()의 결과 값 Error를 err에 받음getData() .then() .catch(function (err) { console.log(err); // Error: Request is failed }); Iterator &amp; Iterable *이터레이터 : 반복자이터러블 : 반복 가능한* 자바스크립트에서는 “반복 가능한(Iterable)” 요소들만 순회 또는 반복될 수 있다. ex) 배열 이터레이터는 next, done, value의 구성을 갖는다!done : 이터레이터가 아직 루프중인지 확인value : 루프중일 때 해당하는 값을 반환 이터레이터와 배열의 차이? 이터레이터는 next 메서드만 기능할 수 있기 때문에, 배열의 기능적 부분집합이라고 볼 수 있다. 하지만… 일반적으로 배열이 이터레이터보다 무겁고 배열이 이터레이터보다 메모리 효율성이 떨어진다. 이터레이터는 다음 값 호출을 받았을 때, 그 때 필요한 값만 계산하는 것이 가능하기 때문이다. (next) 제너레이터 (Generator) 이터레이터를 사용할 수 있도록 해주는 함수 == 제너레이터이터레이터 + 이터러블의 조합 == 제너레이터 기본 문법 1234567function* gen() { yield 1; yield 2; yield 3;}var g = gen(); // &quot;Generator { }&quot; 사용 예시 (무한 반복자) 1234567891011function* idMaker() { var index = 0; while (true) yield index++;}var gen = idMaker(); // &quot;Generator { }&quot;console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// ...","link":"/javascript/base/%EC%BD%9C%EB%B0%B1%EA%B3%BC%20%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4%20(Callback%20&%20Promise)/"},{"title":"[Wesbos] Drum Kit","text":"키보드를 누르면 해당 키값에 맞는 드럼 사운드가 재생되는 간단한 웹페이지다.우선, 각 키를 눌렀을 때 기능해야하는 것들 + 웹페이지 작동 원리와 로직은 이하와 같다! 로직 키보드를 눌렀을 때? 해당 키값 찾기 (keyCode) 해당 오디오 태그 값 찾아서 play 연타 가능하도록 Currenttime = 0으로 설정 css 적용 (.playing 삽입) 적용된 css 제거하며 역트랜지션 구현 가능하도록 구현 코딩 과정1. 해당 키값 찾기 (keyCode) 각 키보드에는 고유한 키값이 존재한다.http://keycode.info/ 이곳에 들어가 각 키값(keyCode)들을 알아보자. html파일에서 key블록을 구성하고 있는 div에 data-key = “nn”형식으로 키값을 부여한다. 123&lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;kbd&gt;&lt;/div&gt; 참고로 본인은 기존에 설정 되어있던 [a-s-d-f-g-h-j-k-l] 배열이 불편하다 생각이 들어 오투잼 배열로 키보드 배열을 변경했음. (div와 audio 태그 내의 data-key만 변경해주면 쉽게 변경 가능!) 완료했다면, JS파일로 돌아가 keys라는 변수를 querySelectorAll을 통해 지정해준다. 1const keys = document.querySelectorAll('.key'); 이제 키보드를 눌렀다는 event를 컴퓨터가 감지할 수 있도록 addEventListener를 통해 keydown 이벤트에 반응하는 함수를 만들어준다. 1window.addEventListener('keydown', keydown); forEach 💡 배열에 사용되는 함수! 편리하게도 배열의 각 요소에 대한 callback 함수를 적용할 수 있음 123456//예시const array1 = ['가', '나', '다'];array1.forEach((element) =&gt; console.log(element));// 예상 아웃풋: &quot;가&quot;// 예상 아웃풋: &quot;나&quot;// 예상 아웃풋: &quot;다&quot; 이제 위에서 설정한 keydown 이벤트를 들을 수 있는 keydown함수를 작성해준다. 그리고 console.log를 통해 누른 키에 해당하는 keyCode값을 콘솔 창에 찍어보자. 123function keydown(e) { console.log(e.keyCode);} 2. 키 값을 활용해 audio를 play audio에 입력된 data-key와 입력된 키의 keyCode가 상호 연결되어,입력된 키에 해당하는 audio만 재생이 돼야 한다. ⇒ 따라서, audio를 따로 변수처리 해서 해당 오디오 파일을 재생시켜줘야 함 12345678const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);// 이렇게 e.keyCode를 변수화 하여 audio에 대입시키면 audio는 특정 audio,// 즉 눌러진 키에 해당하는 사운드만 플레이 될 수 있도록 지정할 수 있는 것!audio.play();//이제 play함수를 적용시키면 눌려진 키 값에 해당하는 사운드만 재생되는 것을 확인 할 수 있다. 3. currentTime을 활용한 연타 기능 추가 But… 키값에 맞는 오디오가 잘 플레이 되기는 하지만, 키를 연속적으로 눌러도 한 사운드의 재생이 끝날 때 까지 다음 키의 재생이 이루어지지 않는 것을 확인할 수 있다. ⇒ 따라서 currentTime을 활용해 키가 연속적으로 눌렸을 때 이에 즉각적으로 play() 함수가 반응되도록 해보자. 123456function keydown(e) { console.log(e.keycode); //이제는 필요 없는 코드 const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`); audio.currentTime = 0; audio.play();} currentTime currentTime은 HTML 내의 태그를 제어하기 위한 메소드다. currentTime = n; 을 통해 특정 수를 부여하면 audio는 해당 숫자에 해당되는 초로 이동한다.이에 따라, 위에서와 같이 currentTime=0; 을 사용하게 되면어떤 키가 눌렸을 때 해당 audio의 현재 플레이 위치는 0이 되는 것이다.즉, “재생이 정지된 것과 같은 효과 ⇒ 그에 따른 연타 가능”의 기능이 적용될 수 있는 것! 4. CSS 적용! 이제 CSS 적용만 하면 된다 :)audio에서 적용했던 논리와 동일하게 내가 누른 키에 해당하는 에만 css가 적용되도록 하면 됨! 123const key = document.querySelector(`.key[data-key=&quot;${e.keyCode}&quot;]`);key.classList.add('playing'); //미리 작성해둔 css 클래스를 적용 하지만…. 위의 코드만으론 css가 “적용”되기만 할 뿐, 키보드를 떼었을 때 css가 제거되지는 않는다. 5. 역트랜지션 구현 위의 키보드 div들의 .playing CSS의 적용과 트랜지션이 끝났을 때 곧바로 CSS가 제거되도록 코드를 짜주면 된다. 123456keys.forEach((key) =&gt; key.addEventListener('transitionend', transitionRemove));function transitionRemove(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing'); //transition이 끝난 div들의 playing css는 모두 제거된다.} 이제 모든 필요 기능들에 필요한 코드를 다 짰다. 아래는 그에 따른 최종 완성 코드다 :) 최종 완성 코드12345678910111213141516171819function playsound(e) { const key = document.querySelector(`.key[data-key = &quot;${e.keyCode}&quot;]`); const audio = document.querySelector(`audio[data-key = &quot;${e.keyCode}&quot;]`); if (!audio) return; //반드시 필요한 것은 아니지만, audio의 data-key에 해당하지 않는 키값이 입력됐을 때 함수가 종료되도록 //위와 같은 코드를 추가했음! audio.currentTime = 0; audio.play(); key.classList.add('playing');}function removeTransition(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach((key) =&gt; key.addEventListener('transitionend', removeTransition));window.addEventListener('keydown', playsound);","link":"/javascript/wesbos/01.%20Drum%20Kit%20/"},{"title":"2.네트워크의 구성","text":"네트워크를 구성하는 기기 네트워크 연결을 위해서는 기기와 기기 간의 연결이 필요하다.이러한 연결을 돕는 데에 가장 주요한 세 개의 기기가 존재한다. 라우터 레이어2 스위치 레이어3 스위치 데이터 전송처리 절차 네트워크 기기는 물리적 신호를 전달 받아 디지털 신호(0,1)로 변환하여 다른 기기로 다시 전송해준다. 데이터 수신 ⇒ 물리적 신호로 변환된 데이터를 받아서 디지털 신호로 변환한다. 데이터를 보낼 곳 결정 ⇒ 데이터에는 부가적인 제어 정보도 함께 담겨서 온다. 이를 활용해 네트워크 기기는 데이터 전송 대상을 설정한다. 데이터 전송 ⇒ 다시 디지털 신호(0,1)을 물리적 신호로 변환하여 송신 대상에게 데이터를 전송한다. 네트워크의 구체적 구성 네트워크 연결을 위해 우리는 일반적으로 인터페이스(포트)를 통해 각 기기를 연결한다. 이더넷 포트 ? LAN 포트? ⇒ 모두 이더넷 인터페이스를 통칭하는 말이다. 이더넷 인터페이스란, 현재 가장 널리 통용되는 인터페이스다. 💡 우리는 이 인터페이스를 통해 물리적 신호와 디지털 신호 등이 전송될 수 있도록 현관문의 역할을 해준다. LAN을 구축하는 방법 LAN은 근거리 네트워크를 의미한다.그렇다면 기기와 기기를 연결해서 어떻게 인터넷 네트워크를 구현한다는 것일까? LAN에도 당연히 라우터, 레이어2 스위치와 같은 네트워크 기기가 필요하다. ⇒ 그리고 PC 또는 노트북에 네트워크 연결을 위한 인터페이스가 존재해야 한다. 사용자 PC의 인터페이스(포트)에 LAN선을 연결하고, 이 선을 또 네트워크 기기의 인터페이스에 연결해준다. 그러면 이제 네트워크 기기를 통해 데이터를 주고 받을 수 있다.","link":"/cs/network/%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC/"}],"tags":[{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"Wesbos Challenge","slug":"Wesbos-Challenge","link":"/tags/Wesbos-Challenge/"}],"categories":[{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"프론트엔드","slug":"프론트엔드","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"},{"name":"백준","slug":"알고리즘/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"},{"name":"Network","slug":"CS/Network","link":"/categories/CS/Network/"},{"name":"Javascript","slug":"프론트엔드/Javascript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Javascript/"}]}