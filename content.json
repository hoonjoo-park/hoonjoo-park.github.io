{"pages":[],"posts":[{"title":"[Github] 협업을 위한 기초","text":"1. README 파일 관리 이전까지는 Github에 코드를 올릴 때 README의 중요성을 잘 알지 못했었다.”그냥 제목이랑 무슨 웹서비스인지 개괄적인 설명만 하면 되지 않을까?” 절~~대 아니다. 이는 오히려 나의 코드와 서비스에 대한 가능성을 저해하는 것과 마찬가지다. 내가 좋은 서비스와 코드를 배포했다면, 당연히 다른 사람들이 내 레포지토리를 확인하고 사용법 등을 읽어볼 것이라고 가정해야 한다. 즉, README 파일을 제대로 작성하지 않는 것은 사용 설명서 없이 전자제품을 판매하는 것과 같은 것이라 봐도 무방하다. 📝 README에 들어가야 하는 필수 요소 프로젝트 이름 배포 주소 설치 &amp; 실행 방법 디렉토리 구조 (Project Structure) 프로젝트 설명 핵심 기능 구현 예시 (gif, jpeg 등등) 핵심 코드 설명 프로젝트에 대한 회고 2. 팀원들과 원활한 협업을 위한 사전 약속 그동안 코딩을 할 때, 혼자 주로 해왔었기에 커밋, css, 디렉토리 구조 등등 다~~ 내 마음대로 했었다.물론 완전 체계없이 한 것은 아니었지만, 협업을 위해선 팀원들과의 사전 약속이 필요하다. 디렉토리 구조 아래와 같이 이번 프로젝트에서 우리는 CRA를 통해 React프로젝트 뼈대를 만들었고, 디렉토리 구조를 사전에 약속했다. 이렇게 사전에 디렉토리 구조를 약속하고 코드를 짜니 훨씬 소통도 잘 되고 협업하는 것도 수월했다. CSS 사용 방법 나는 styled-components를, 다른 팀원은 tailwind, 또 다른 팀원은 SASS를 선호한다고 해서 각자 서로 다른 CSS 스타일링을 하면 안된다. 따라서 팀원들 간의 합의를 통해 공통된 CSS 작성법을 약속해야 한다. Commit 메시지의 통일 팀원들이 각기 아래와 같이 통일감 없이 마음대로 커밋 메시지를 작성하면 팀원들을 차치하고서라도 다른 사람들이 봤을 때 프로젝트 진행 과정 등을 한 눈에 알아보기가 어렵다. 따라서 프로젝트 시작 전 팀원들 간에 commit 메시지 작성법을 정하는 것이 좋다. 커밋 메시지 예시 기능 추가 : 무한 스크롤 기능 추가하여 구현하였습니다! 무한 스크롤, CSS 스타일링, API KEY 수정 🔥 루트 디렉토리 test.js파일 삭제 그리고 **“습니다”, “반말”, “작업중“**과 같은 표현들은 커밋 메시지를 작성할 때 최대한 지양하는 것이 좋다. git commit 메시지 작성 예시 3. 제발 .gitignore 작성해주세요…. .gitignore를 작성하지 않고 push를 하면 사용자 입장에서 전~혀 필요 없는, 또는 올라와서는 안될 파일들이 github 레포지토리에 올라가게 된다. 우리가 어떤 미술 전시를 보러 갔는데 미술 작품만 걸려있는게 아닌, 해당 작가가 사용했던 물감, 붓, 펜, 포장지, 받침대 등등 잡다한 것들도 전부 다 전시되어있다면 어떨까? 같은 이치다. 물론 보안상의 이유도 물론 있지만, 우리의 코드를 받아서 쓰는 사용자들은 nodemodules나 build, .vscode와 같은 폴더 및 파일들이 전혀 필요 없다. 오히려 짐만 될 뿐이다. 따라서 보안상의 이유(env 파일 등)와 효율성을 위해 .gitignore파일을 생성하여 작성하자.","link":"/github/1.github_basic/"},{"title":"[Github] Remote와 Local","text":"Remote와 Local? 쉽게 설명하자면, remote는 git서버에 존재하는 저장소,local은 내 컴퓨터에 물리적으로 존재하는 저장소를 의미한다. Remote 생성 원격 repository를 생성하는 방법이다. 나의 github repositories에 들어가 우측 상단의 New버튼을 클릭한다. Repository 이름을 원하는대로 작성하고 공개 여부를 설정하여 생성해주면 끝이다. Local 세팅 Local은 말 그대로 내 컴퓨터에 있는 파일이다.하지만 이 Local 파일들이 git과 연동되도록 하려면 일련의 과정들이 필요하다. 원격저장소 (remote)와 현재 로컬 폴더를 연동 ⇒ 로컬과 연결하고자 하는 원격 저장소를 “저장” 또는 “지정” 되도록 하는 것 1$ git remote add origin [repo URL] upstream과 remote 분리 (upstream은 따로 있고 나의 레포에는 fork된 레포가 있을 경우) 1234### 1번은 위와 동일, 하지만 이는 나의 fork된 레포를 의미한다.$ git remote add origin [repo URL]### 2번은 내가 fork해온 오리지날 upstream 레포를 의미한다.$ git remote add upstream [repo URL] repo URL은 아래와 같이 확인 후 복붙해주면 된다. 로컬과 리모트의 연결상태 확인 123$ git remote -v$ git remote show 연동된 원격 저장소의 정보를 업데이트 12## 이걸 해줘야 remote의 브랜치 목록들을 최신화 하여 확인할 수 있다.$ git remote update 저장소명을 모르겠는 경우? 1$ git remote Local 저장소로 Remote 클론하는 방법1$ git clone [remote repo URL] ## 클로닝 🚨 git clone에는 아래와 같은 명령어들의 프로세스가 포함되어 있는 것이다. 123$ git init ## 현재 위치의 디렉토리를 빈 Git 저장소로 지정$ git remote add origin [remote repo URL] ## 지정된 Git 저장소에 원격 repository를 추가$ git fetch origin master ## remote 내의 master브랜치 데이터들 -&gt; 로컬로 데이터를 &quot;가져오기만&quot; 함 1$ git remote -v ##지정된 remote 목록을 확인할 수 있다.","link":"/github/2.remoteLocal/"},{"title":"[Github] 브랜치","text":"Git Branch란? 브랜치는 말 그대로 나뭇가지다.main이라는 브랜치의 기둥을 기준으로 뻗쳐있는 줄기들이라고 생각하면 된다. 처음 repository를 생성하면 이와 같이 main 브랜치가 만들어진다. 이러한 main 브랜치가 나무의 기둥이라고 생각하고, 그 기둥을 기준으로 여러 branch(나뭇가지)들이 뻗어있다고 생각해보자. 이와 같은 각 branch들은 독립적인 작업공간이라고 볼 수 있다. 만약 모두가 함께 main브랜치에서 작업을 하게 되면 서로의 작업에 의해 나의 코드에 영향을 주거나 예기치 못한 오류들이 발생할 수 있다. 따라서 각자 맡은 기능들을 개발하기 위한 독립적인 공간(branch)이 필요한데, 이게 branch의 존재 이유다. 일반적인 브랜치 구조 물론 일반화를 할 수는 없지만, 자주 사용되는 브랜치 작업 방법이다.이번 프로젝트에서도 이와 같이 브랜치를 만들어 작업했다. main브랜치를 기준으로 develop 브랜치를 생성한다. 기능별 브랜치를 생성한다. 하나의 기능 구현이 완료되면 develop브랜치에 push한다. 하나의 완성된 version이 구현되면 develop에서 main 브랜치로 최종본을 push한다. 이렇게 작업을 하다 보면 아래와 같이 여러 브랜치들이 생기는데, 기능 구현이 완료되어 develop브랜치로 이상없이 push됐다면 해당 브랜치를 삭제해주면 된다. git branch 명령어브랜치 만들기 1$ git branch [branch 이름] 원하는 브랜치로 이동하기 1234$ git checkout [branch 이름]## 브랜치를 만듦과 동시에 이동하기$ git checkout -b [branch 이름] 브랜치 확인하기 1$ git branch 브랜치 이름 변경 12### 이름 변경$ git branch --move [기존 이름] [바꿀 이름] 브랜치 삭제하기 1$ git branch -d [branch 이름]","link":"/github/3.branch/"},{"title":"[Github] push, pull","text":"push, pull, merge의 과정 개발이 완료 됐다면? → push + remote에도 브랜치 추가 → pull request → merge 항상 로컬 저장소의 파일을 원격 저장소에 최신화 하고자 할 때는 “add → commit → push“의 순서를 따르면 된다. commit 12## -a = add, -m = message (add -&gt; commit -&gt; push 순서)$ git commit -a -m &quot;메시지 넣으면 됨&quot; commit 되돌리기 1234# 만약 커밋을 이미 해버렸는데, 해당 커밋 내용에 추가적으로 변경되어야 할 사항이 필요할 경우$ git reset [commit 코드]# 그냥 커밋 자체를 취소하고 로컬에서 변경사항도 되돌리고싶을 경우$ git reset --hard [commit 코드] push방법 12## ex) git push origin function/a$ git push [저장소명] [브랜치명] 매번 저장소명과 브랜치명 작성하는게 귀찮을 경우! 1234567## 로컬의 브랜치를 remote repo에 업로드 (origin) =&gt; 이후에는 저장소와 브랜치명 작성 안해줘도 됨$ git push -u origin [브랜치명]## 만약 현재 브랜치에 바로 push를 하고싶다면?$ git push origin HEAD## 또는?$ git push origin HEAD/ Local 최신화 이제 remote 레포가 최신화 됐으므로, 나의 local 또한 최신화 해줘야 한다. develop 브랜치로 이동한다. (나의 경우는 main 아래에 develop을 두는 편이기에) 1$ git checkout develop 이전에 작업했던 브랜치를 develop과 merge 해준다. 1$ git merge [방금 작업했던 branch 이름] fetch vs pull? fetch : remote 데이터를 로컬로 “가져오기만” 함 (로컬 헤드가 변경되지 않음) pull : remote 데이터를 가져오고 + 병합까지 실행 (fetch + merge ⇒ 파일이 불러와지고, head도 옮겨짐)","link":"/github/4.pushPull/"},{"title":"리액트 기초","text":"리액트를 사용해야 하는 이유 리렌더링을 할 때 DOM 전체를 다시 갈아끼워 넣는 것이 아니라, 가상 DOM과 기존 DOM의 비교를 통해 변경된 사항만 갈아끼워 넣어 주기 때문에 굉장히 효율적인 View 구성과 리렌더링을 구현할 수 있다. ⇒ 따라서, 단순히 정적인 페이지만을 위한 웹사이트라면 굳이 React를 사용하지 않아도 된다. 하지만 굉장히 동적으로 데이터가 변화하고, View가 변화하는 경우 React를 통해 효율적인 리렌더링과 DOM의 조작을 기대할 수 있다. 렌더링 사용자의 화면에 View를 띄우는(보여주는) 것. 초기 렌더링 과정 ⇒ 렌더링 → HTML마크업 (문자열 코드 생성) → 이를 DOM에 주입 조화 과정 ⇒ 리렌더링이 일어났을 때 기존의 뷰와 변경된 뷰를 최소 연산으로 비교한 후 DOM트리를 업데이트 한다. DOM &amp; Virtual DOM DOM ⇒ Document Object Model, 트리형태의 객체로 문서 구조를 표현한다.ex) html → head, body → title, meta, h1, div 등등 Virtual DOM ⇒ 실제 DOM의 추상화된 사본 → React는 이 Virtual DOM을 사용해 변경사항만을 갈아 끼워 넣는다. JSX 자바스크립트의 확장된 문법으로, XML과의 형식을 띄지만 하나의 자바스크립트 객체다.바벨을 통해 createElement와 같이 자바스크립트 형태의 코드로 반환된다. 문법의 특징 한 컴포넌트에는 반드시 하나의 부모 엘리먼트만 존재해야 한다. 즉, 부모는 형제 엘리먼트가 있을 수 없다. 따라서 부득이한 경우 &lt;Fragment&gt; &lt;/Fragment&gt; 로 감싸서 이 Fragment를 의미없는 부모로써 사용하면 된다. 삼항연산자 (조건부 연산자)를 통한 조건부 렌더링 가능 태그는 반드시 닫혀야 한다. 따라서 &lt;input /&gt;과 같이 self-closing 방법을 사용해야 한다. 컴포넌트 재사용성이 높은 일종의 UI 조각으로, Export → App.js에서 import → 렌더링 Props props를 통해서 컴포넌트에서는 “여기에는 이런 인자가 들어갈거야!”⇒ App.js에서는 “응 그 인자의 값들은 이거야!” 하고 설정해주는 것 간단한 활용 예제 ⇒ Todo List에서 하단 “+”버튼을 누르면 해당 버튼의 색상이 rotate &amp; 색상변경 된다. 1234567891011const button = styled.`${props =&gt; // props 중에 open이라는 놈 있지? 그 놈이 true이면 ~~ props.open &amp;&amp; css ` background-color : #F73859; transform : translate(-50%, 40%) rotate(45deg);`}`// 위의 중괄호 안의 뜻은 ==&gt; button에 props가 있는데,// 그 props 중에 open이라는 녀석의 값이 true면 아래와 같은 css값을 줄거야! 12345678910function test() { // 우선 isOpened의 초기값은 false이고, setOpen()을 통해서 이걸 컨트롤 const [isOpened, setOpen] = useState(false); // onClick -&gt; onToggle 실행 ==&gt; setOpen(isOpened 기존값의 반대를 줄거야) const onToggle = () =&gt; setOpen(!isOpened); return ( // open이라는 props의 값은 isOpened의 값 &lt;button onClick={onToggle} open={isOpened} /&gt; );}","link":"/react/Basic/"},{"title":"React 슬라이딩 캐러셀 만드는 법 (Slider, Carousel)","text":"이전에 진행했던 ‘디스트리’ 프로젝트에서 끊기지 않는 무한 슬라이딩 캐러셀을 만들어보려다 실패한 경험이 있다. 당시에는 react는 물론이고 javascript도 잘 다루지 못했던 때라 이번 기회를 빌어 무한 슬라이딩 캐러셀 제작법을 정리해보려 한다. 메인 컨셉 가장 중요한 구현 컨셉은, 양쪽에 fake 배너를 만들어줘서 눈속임을 줘야 한다는 것이다.물론 실제로 모든 배너들이 3D로 연결되어 무한 슬라이딩을 구현하면 좋겠지만 쉽지 않은 것이 현실이다. 따라서 아래와 같이 가짜 배너를 양 끝에 배치시켜야 한다. 이해가 아직은 쉽지 않을 수 있는데 두 번째 그림을 보면 쉽게 이해될 수도 있다. 쉽게 설명하면 transition의 특성을 이용한 것이다.우리는 각 슬라이드들이 넘어가는 것을 어떻게 인지할까?첫 째,그림이 바뀌는 것을 인지하는 것, 그리고 둘 째, 같은 그림이더라도 넘어가는 과정의 transition을 통해 배너가 슬라이딩 되는 것을 인지한다. 하지만 아래와 같이 가짜 배너 1번이 화면 중앙에 위치해 있을 때 transition을 제거해주고 원래 진짜 1번의 위치로 이동시키면 트랜지션 효과도 없을 뿐더러 같은 그림에서 같은 그림으로 변경되기에 우리는 배너의 변화를 눈으로 알아챌 수 없다. 따라서 아래 그림에서와 같이, 진짜 4번 → 가짜 1번으로의 이동이 끝난 시점(transitionend)에 transition을 제거한 뒤 -&gt; 진짜 1번의 위치로 이동하게 되면, 사람의 눈으로 봤을 때 그대로 1번에 고정되어있는 것과 같은 착각을 일으킨다. 따라서 이 방법을 사용하면 슬라이드가 끊기지 않고 계속 연결되며 슬라이딩 되는 것과 같은 효과를 줄 수 있는 것이다. 각 배너들이 담길 Carousel을 만든다12345678// 기본 구성은 이하와 같다. main이라는 큰 틀 안에 carousel을 만들어주고, 그 안에 각자 이미지 배너들을 넣어주면 된다.&lt;div className=&quot;main&quot;&gt; &lt;ul className=&quot;carousel&quot;&gt; &lt;li className=&quot;banner&quot;&gt; &lt;img src=&quot;#&quot; alt=&quot;&quot; /&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 위치 조정 위에서 미리 짜둔 구조에 맞춰 이미지를 넣고 overflow:hidden 을 해주면 이와 같은 모양새가 나온다.하지만 이는 정렬이 되지 않은 날 것의 상태이기 때문에 transform:translateX() 를 통해 위치를 조정해줘야 한다. 이런 초기값에서 우리가 바라는 디폴트 값은 이와 같은 형태로 정렬된 상태여야 한다. 이를 위해선 transform:translateX()를 통해 얼만큼 움직여야 원하는 배너가 중앙에 위치할 수 있는지 계산해줘야 한다. 거리 계산 방법 (지극히 주관적) 우선, 좌측 끝에서 중앙에 위치시키고 싶은 배너의 좌측 끝부분 까지의 거리를 구한다. 그리고 해당 배너가 중앙에 위치하게 된다면 남게 될 좌측 공백의 거리를 계산한다. 이제 두 값을 빼면 transform을 통해 초기에 움직여야 하는 거리가 계산된다. 종합적인 그림 예시로 다시 요약을 하자면… 왼쪽끝 ~ 중앙에 위치하길 바라는 배너의 좌측 끝 (BannerWidth + margin)에서 해당 배너가 중앙에 위치했을 때 남는 좌측 공백값을 빼주면 얼만큼 이동해야 배너가 중앙에 위치하는지 계산할 수 있다. 그럼 이제 슬라이딩을 어떻게 구현하면 될까? 우선 슬라이드를 움직일 버튼 두 개를 만들고, 각 버튼의 onClick 이벤트에 함수를 걸어준다. 1234567// mdArrow는 방향표시 svg react icons이므로 크게 신경 쓸 필요 없다.&lt;button className=&quot;leftArrow&quot; onClick={moveLeft}&gt; &lt;MdArrowBackIosNew /&gt;&lt;/button&gt;&lt;button className=&quot;rightArrow&quot; onClick={moveRight}&gt; &lt;MdArrowForwardIos /&gt;&lt;/button&gt; moveLeft와 moveRight함수의 코드 로직 우선, 현재 가운데에 위치해 있는 배너가 몇 번째 배너인지 체크하기 위한 currentIndex state가 필요하다. 그리고 필자는 추가적으로 얼만큼 움직여야 하는지를 css에 전달해 줄 distance, 그리고 transition값을 css에 전달해 줄 timing이라는 state도 추가해 활용했다. 12345678910111213141516171819const moveLeft = () =&gt; { // 일반적인 transtion 슬라이딩일 경우에는 그냥 index값을 감소시켜주고, 트랜지션 값도 0.3초를 준다. // 그리고 계속 배너의 넓이 + margin값 만큼 좌측으로 이동시켜준다.(기존 거리 - 더 이동해야 하는 거리) if (currentIndex &gt; 2) { setCurrentIndex(currentIndex - 1); setTiming(0.3); setDistance(distance - 64.5); return; }};const moveRight = () =&gt; { if (currentIndex &lt; 12) { setCurrentIndex(currentIndex + 1); setTiming(0.3); setDistance(distance + 64.5); return; }}; 12345678910// SCSS에서 state를 이하와 같이 전달받아 활용했다.// useRef를 쓸까도 고민했지만, 일단 state로 관리하는게 더 편할 것 같아서 이와 같이 구현했다.const Slider = styled.div` position: relative; display: flex; width: 100%; height: 100%; transform: ${(props) =&gt; `translateX(-${props.distance}vw)`}; transition: ${(props) =&gt; `transform ${props.timing}s ease`};`; 슬라이드가 끝에 닿았을 때의 코드 로직 (중요) 이제 transition 값을 none으로 지정해준 뒤, 가짜 배너에서 진짜 배너로 이동시켜주는 눈속임을 행해야 할 때다. 123456789101112131415161718// 슬라이더 안에 props로써 distance, timing 들을 넣어준다.// 그리고 onTransitionEnd 이벤트를 리스닝 하도록 한다.&lt;div ref={slideCarousel} distance={distance} timing={timing} onTransitionEnd={handleFlip}&gt; &lt;Banner&gt;4&lt;/Banner&gt; // 가짜 &lt;Banner&gt;5&lt;/Banner&gt; // 가짜 &lt;Banner&gt;1&lt;/Banner&gt; &lt;Banner&gt;2&lt;/Banner&gt; &lt;Banner&gt;3&lt;/Banner&gt; &lt;Banner&gt;4&lt;/Banner&gt; &lt;Banner&gt;5&lt;/Banner&gt; &lt;Banner&gt;1&lt;/Banner&gt; // 가짜 &lt;Banner&gt;2&lt;/Banner&gt; // 가짜&lt;/div&gt; 이제 onTransitionEnd에 의해 실행되는 함수 handleFlip 코드를 작성해주면 된다. 예를 들어 가짜 9번으로 이동이 끝났을 때 (좌측이동) 진짜 9번으로 트랜지션 없이 이동하면 된다. 진짜 1번 → 가짜9번으로의 이동이 완전히 끝났을 때 트랜지션을 제거하고 눈속임을 줘야하기 때문에 onTransitionEnd에 함수를 걸어준 것이다. 12345678910111213141516const handleFlip = () =&gt; { if (currentIndex &lt;= 2) { // 진짜 9번의 인덱스인 11번으로 인덱스값 세팅 setCurrentIndex(11); // 트랜지션 0으로 지정 setTiming(0); // 진짜 9번이 화면 가운데에 위치했을 경우의 거리값 setDistance(626.5); } // 이쪽은 우측 이동했을 경우의 코드 if (currentIndex &gt;= 12) { setCurrentIndex(3); setTiming(0); setDistance(110.5); }};","link":"/react/Sliding_Carousel/"},{"title":"2. Redux Dispatch","text":"Dispatch 뷰(컴포넌트)에서 Dispatch를 통해 특정한 action을 실행시키고, 그에 따라 reducer가 실행된다.그리고 state가 지정해놓은 규칙에 따라 변경되어 구동하고 있는 컴포넌트들에 반환될 것이다. mapDispatchToProps 나는 userObject의 업데이트를 store에서 관리하고, 이를 필요한 컴포넌트에 뿌려주고싶다. 따라서 App.jsx에서 onAuthStateChanged 함수가 실행됐을 때 snapshot 함수 내에서 dispatch를 발동시켜줬다. 이에 따라 로그인을 했을 때, 혹은 유저 정보에 변화가 생겼을 때 userObject가 snapshot에 의해 업데이트 되고, 이후에 변경된 값이 dispatch를 통해 리듀서에 전달된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// App.jsconst userSnapshot = async (user) =&gt; { const userRef = doc(db, 'Users', auth.currentUser.email); // 유저 이름이 등록되어있지 않을 때 if (!user.displayName) { onSnapshot(userRef, async (snapshot) =&gt; { const newUserObject = { displayName: 'User', ...snapshot.data(), }; setUserObject(newUserObject); // updateUser 디스패치가 발동된다. props.updateUser(newUserObject); return setIsLoading(false); }); } // 등록되어 있을 때 onSnapshot(userRef, async (snapshot) =&gt; { setUserObject(snapshot.data()); // updateUser 디스패치가 발동된다. props.updateUser(snapshot.data()); return setIsLoading(false); });};// onAuthStateChanged를 통해 유저정보 변화를 listening한다useEffect(() =&gt; { onAuthStateChanged(auth, (user) =&gt; { if (user) { userSnapshot(user); } else { setUserObject(null); setIsLoading(false); } });}, []);// mapStateToProps는 구독중인 state를 받아올 수 있도록 한다.const mapStateToProps = (state) =&gt; { return { user: state.user, };};// dispatchconst mapDispatchToProps = (dispatch) =&gt; { return { // updateUser라는 이름으로 updateUser() 디스패치를 실행시켜 응답을 받아온다. updateUser: (user) =&gt; dispatch(updateUser(user)), };};export default connect(mapStateToProps, mapDispatchToProps)(App); 12345678910111213141516171819202122232425// .../redux/authentication/userUpdate.js// Actionexport const updateUserAction = 'UPDATE_USER';// Action Creatorexport const updateUser = (user) =&gt; ({ type: updateUserAction, payload: user });const initialState = { user: {} };function updateUserReducer(state = initialState, action) { // reducer가 이 action을 참조하는지 체크 if (action.type === updateUserAction) { // 만약 참조한다면, state를 복사 console.log(action.payload); return { ...state, // 그리고 새로운 값을 업데이트 해준다. // payload에 담긴 값을 spread operator를 통해 덮어준다. user: { ...state.user, ...action.payload }, }; } // 위 조건에 해당되지 않으면 그냥 기존 state값을 리턴해준다. return state;}export default updateUserReducer; 미들웨어 사용하기 logger와 composeWithDevTools를 통해 조금 더 쉽게 redux의 프로세스와 상태를 확인할 수 있다. 123456789// .../src/index.jsimport logger from 'redux-logger';import { composeWithDevTools } from 'redux-devtools-extension';const store = createStore( updateUserReducer, composeWithDevTools(applyMiddleware(logger)));","link":"/redux/Dispatch/"},{"title":"1. Redux 기초","text":"내가 userObject를 component에 전달하던 방식 이전까지는….최상단 루트인 App.js에 userObject를 두고, 유저 정보의 변경을 루트에서 하향식으로 각 컴포넌트에 뿌려줬다. 근데 이런 방식이 굉장히 불편하고 비효율적이라고 느껴졌다. 이에 따라, 가장 널리 알려진 상태관리 라이브러리 Redux를 통해 state들을 관리해보고자 한다.특히, userObject를 계속 props를 통해 컴포넌트에게 뿌려주는 것이 가장 귀찮고 번거로웠다… Redux 기본 컴포넌트 안에서만 사용되던 state를 이제 store라는 곳에 담아두고 사용한다.그리고 필요한 컴포넌트에서 해당 store를 구독(subscribe)하고, 해당 state가 변경되면 그 state를 구독하고 있는 컴포넌트가 리렌더링 된다. 기본 로직과 컨셉 -뷰에서 Dispatch를 통해 Action을 발동시킨다 -그리고 해당 Store에서, 정해진 reducer를 통해 state를 변경한다. -해당 state(store)를 구독하고 있는 컴포넌트는 리렌더링 된다. Redux 설치 참고로, Redux는 React를 위해서 만들어진 라이브러리가 아니다…순수 javascript 앱을 위해 만들어진 것이기 때문에 react-redux를 통해 redux와 react를 연결시켜줘야 한다. 12$ npm install redux react-redux redux-logger$ npm install --save redux-devtools-extension Reducers reducer는 하나의 함수다.현재 state와 action 오브젝트를 받고, 만약 필요하다면 state를 update해준다. 🔥 불변성을 지켜야 한다. Redux는 참조값을 기준으로 state가 업데이트 된 것인지 아닌지를 판단한다. 따라서 직접적으로 state를 업데이트 하면, 참조값이 변했다는 것을 인식하지 못한다. 12// 올바른 불변성 유지 방법state.something = {...something, action.something} Action 생성 action은 reducer를 실행시킨다.이 중에서도 type은 특정 action의 고유 주소값(이름)이라고 생각하면 된다.그리고 payload는 이 action의 실행에 필요한 어떠한 데이터다. 1234567// Actionexport const updateUserAction = 'Update_User';// Action Creatorexport const updateUser = (user) =&gt; ({ type: updateUserAction, payload: user,}); reducer 생성 12345678910111213141516const initialState = { user: { test: 'hello' } };function updateUserReducer(state = initialState, action) { // reducer가 이 action을 참조하는지 체크 if (action.type === updateUserAction) { // 만약 참조한다면, state를 복사 return { ...state, // 그리고 새로운 값을 업데이트 해준다. user: state.user, }; } // 위 조건에 해당되지 않으면 그냥 기존 state값을 리턴해준다. return state;}export default updateUserReducer; rootReducer 생성 위에서 생성한 개별 reducer를 하나로 합쳐줄 rootReducer를 만들어야 한다.‼️ 근데 만약 reducer가 하나라면 combineReducers를 사용해선 안된다. 123456import { combineReducers } from 'redux';import updateUserReducer from './authentication/userUpdate';const rootReducer = combineReducers({ updateUserReducer });export default rootReducer; Store 적용하기123456789101112131415161718192021222324// ../src/index.jsimport { createStore, applyMiddleware } from 'redux';import logger from 'redux-logger';import { composeWithDevTools } from 'redux-devtools-extension';import { Provider } from 'react-redux';// reducer가 여러개라면?import rootReducer from './reducers/rootReducer';// reducer가 하나라면 ?import updateUserReducer from './redux/authentication/userUpdate';const store = createStore( rootReducer, composeWithDevTools(applyMiddleware(logger)));ReactDOM.render( &lt;React.StrictMode&gt; &lt;GlobalStyle /&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 컴포넌트에서 redux 활용하기 이제 기본적인 세팅이 끝났으니, 각 컴포넌트에서 redux를 활용해볼 수 있다. 1234567891011121314151617181920// someComponent.jsximport { connect } from &quot;react-redux&quot;;const someComponent = (props)=&gt; { console.log(props) return ( &lt;div&gt;Welcome!!&lt;/div&gt; &lt;div&gt;{props.user}&lt;/div&gt; )}const mapStateToProps = (state) =&gt; { return { user: state.user }}const mapDispatchToProps = (dispatch)=&gt; { updateUserReducer}export default connect(mapStateToProps)(someComponent) 성공적으로 불러와졌다…!! 다음 포스팅에서는 이러한 redux state를 dispatch하여 변경시키는 것을 시도해보려고 한다.","link":"/redux/Redux_basic/"},{"title":"타입스크립트란? (Typescript)","text":"타입스크립트? 타입스크립트는 자바스크립트의 슈퍼셋 언어로, 쉽게 말해 자바스크립트 기반으로 만들어진 조금 더 확장되고 상위의 언어라고 할 수 있다. 원래 자바스크립트는 클래스 기반 객체지향 언어가 아닌, 프로토타입 기반 객체지향 언어다. 따라서 자바스크립트는 클래스를 정의하지 않아도 객체를 생성할 수 있다. 또한 동적 타입(dynamic typed)언어로써, 변수를 선언하기 전에 해당 변수의 타입을 지정할 필요가 없다. 이러한 이유들로 인해 바닐라 자바스크립트 자체는 클래스 기반 객체지향 언어와 달리 오류를 내기 쉬우며, 코드의 효율성이 떨어지는 문제를 야기할 수 있다. 이러한 자바스크립트의 문제점을 해결하고자 C#을 개발한 아네르스 하일스베르가 TypeScript를 개발했다. 타입스크립트의 특징 ES5와 ES6의 문법과 기능들을 모두 사용할 수 있다. React, Angular, Vue 등의 프레임워크에서 모두 호환 가능하다. 타입스크립트의 장점 ✨ 정적 타입을 지원 1234// 이렇게 하면 sum()에는 숫자만 들어갈 수 있고, 다른 타입이 입력되면 오류가 발생한다.function sum(a: number, b: number) { return a + b;} 정적타입을 지원하게 되면, 컴파일 단계에서 사전에 오류를 포착할 수 있다. 예를 들어 함수 sum(a,b) 에는 숫자만 들어가야 한다고 가정했을 때, 타입스크립트의 정적타입 지원성을 활용해 해당 함수에는 숫자만 입력되도록 설정할 수 있는 것이다. 따라서 우리는 타입스크립트를 사용하여 효율적으로 코드를 디버깅 할 수 있고, 코드 생산성을 높일 수 있다. IDE를 포함한 다양한 툴 활용 가능 타입 정보가 제공된다는 이유 하나만으로 타입스크립트는 매우 큰 장점을 선점할 수 있다. 즉, VSCode를 포함한 다양한 에디터에서 이 언어를 지원하고, 다양한 라이브러리와 툴킷들을 활용할 수 있다. 객체지향 프로그래밍 지원 큰 프로젝트나, 복잡한 코드를 짜야 하는 경우에는 클래스 기반 객체지향 프로그래밍이 필수적이다. 따라서 이제 자바스크립트도 타입스크립트의 도움을 받아 JAVA, C#에 못지 않게 큰 프로젝트에도 효율적으로 활용될 수 있고 다른 언어의 개발자들이 자바스크립트를 학습하는데 러닝커브를 낮춰줄 수도 있다. 브라우저 호환성을 높일 수 있다. Babel에서와 같이, 내가 작성한 코드를 오래된 버전의 javascript 언어로 컴파일 할 수도 있고, 최신 버전의 javascript로 컴파일 할 수도 있다. 따라서 상황에 따라 유연하게 활용할 수 있다는 장점을 갖는다. 타입스크립트의 단점 😓 브라우저 및 자바스크립트 환경에서 실행되지 못한다. 도대체 무슨 말일까….? 자바스크립트 슈퍼셋 언어인 타입스크립트가 브라우저나 자바스크립트 환경 자체에서 사용이 불가능 하다니…. 이러한 이유 때문에 타입스크립트라는 언어이자 하나의 도구는, 자동으로 javascript언어로 코드를 컴파일 해준다. 따라서 타입스크립트로 코드를 작성해도 javascript로 컴파일 되어 브라우저에서 사용 가능하다. babel과 같은 원리라고 보면 될 것 같다. 타입스크립트 설치 &amp; 설정 이제 전반적인 타입스크립트의 개념에 대해 알아봤으니 타입스크립트를 직접 설치해보고 활용해보면 될 것 같다. 설치 node.js도 필수적으로 설치해야 하나, 이전에 이미 node.js를 설치했기에 생략… 12345# 현재 프로젝트에 설치하고 싶다면?$ npm install typescript --save-dev# 컴퓨터 전체에 설치하고싶다면$ npm install -g typescript 리액트에서 사용할 경우1$ npx create-react-app [아무 이름] --template typescript","link":"/typescript/Typescript_Basic/"},{"title":"[타입스크립트] 기본 타입","text":"타입스크립트의 기본타입 자바스크립트는 string, number, boolean, object 등의 타입을 typeof를 통해 구별할 수 있다.물론 코드 내에서 if문을 걸어 타입의 검사가 가능하긴 하지만, 이는 개발 단계에서 버그를 잡아내는데 비효율적일 수 있다. 따라서 우리는 타입스크립트를 통해 변수의 타입을 미리 설정하고, 이를 통해 개발 단계에서 사전에 에러를 발견하여 즉각적으로 수정할 수 있다. number, string, boolean 타입 (기초) 아래와 같이 코딩을 하게 되면, 1은 string이고 2는 number이기 때문에 문자열로 변환되어 ‘12’가 반환된다. 12345678function sum(a, b) { return a + b;}const num1 = '1';const num2 = 2;console.log(sum(num1, num2)); 하지만 타입스크립트를 활용하여 아래와 같이 코딩을 하면 우리는 사전에 오류를 잡아낼 수 있고, 의도한 대로 코드의 결과 값을 반환 받을 수 있다. 123456789101112function sum(a: number, b: number, c: boolean) { if (c) { return a + b; }}const num1 = '1';const num2 = 2;const isTrue = true;console.log(sum(num1, num2, isTrue));//Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)// 이렇게 오류를 잡아주기 때문에 우리는 즉각적으로 잘못된 코드의 방향성을 바로잡을 수 있는 것이다. 초기화와 할당 변수를 선언할 때 할당이 이미 특정 타입으로 되어있는 것과, 그냥 생성+초기화만 되어있는 것과는 타입 할당 방법에 차이가 존재한다. 무슨 말인가 하면… 아래와 같이 이미 특정 변수에 특정 타입의 값이 선언되어 있다면, 타입스크립트는 해당 변수의 타입을 해당 값의 타입으로 할당해버린다. 12345// 이제 value의 타입은 number인 것이다.let value = 5;// 이 때문에 이와 같은 타입 지정은 중복 또는 반복이기에 굳이 타입을 할당해줄 필요가 없다.let value: number = 5; 하지만 아래와 같은 경우는 타입을 할당해주는 것이 옳다 123// 이렇게 변수의 생성과 할당이 분할되어 있는 경우에는 선언 당시에 타입을 할당해줘야 한다.let value: string;value = 5; 타입스크립트에서의 객체와 배열 타입 타입스크립트에서는 객체 안에 들어가는 value들의 타입도 손쉽게 사전 정의해줄 수 있다. 오브젝트의 기본 타입 선언법 12345678910111213141516// 이렇게 기본적인 오브젝트 타입 선언을 할 수 있다.const profile = { name: string; age: number;}// 아래는 조금 더 심화된 예시다.const profile = { name : string; age: number; friends: string[]; details: { uiv: string; gpa : number; }} 위의 심화 타입스크립트 코드를 JS코드로 표현하면 이와 같을 것이다. 그렇다면 **배열(Array)**은 타입스크립트에서 어떻게 다뤄질까? 위에서 약간의 힌트가 나왔지만, 해당 배열의 요소들이 가질 타입을 [] 앞에 선언해주면 된다. 1const friends: string[]; 근데 그러면 배열 안에 들어가는 요소들이 다양한 경우엔 어떻게 처리할까…? 아래와 같이 any를 사용해주면 된다. 하지만 any를 너무 남발하는 것은 타입스크립트의 이점을 제대로 활용하지 못하는 경우가 될 수 있으니 최대한 요소들의 타입을 고려하여 배열의 타입을 지정해줘야 한다. 123let friends: any[];friends = ['hoonjoo', 185, 77]; // 이렇게 어떤 타입이 들어와도 오류를 반환하지 않는다. 튜플 타입스크립트에는 튜플이라는 타입이 존재한다. 이는 배열과 모양새가 비슷한데, 위에서 설명한 것과 같이 배열 요소의 타입들이 순서에 따라 지정되어 있는 타입을 의미한다. 12const profile = [string, number];profile = ['age', 50]; // 이런식으로 순서를 반드시 고려하여 그에 맞는 타입을 집어 넣어주면 된다. enum enum 타입 또한 자바스크립트에는 존재하지 않는 타입이다.enum은 내가 사전에 정의한 특정 변수의 고정값을 두어 활용하고 싶을 때 사용한다. 글로만 보면 이해가 쉽지 않을 수 있는데, 아래의 코드를 보면 이해가 쉬울 수 있다. 1234567891011// 이렇게 enum을 사용하면, 사전에 특정 변수에 고정값을 지정해두고 활용 가능하다.enum Role { ADMIN = 0, READ_ONLY = 1, BANNED = 2,}const person = { name: 'hoonjoo', role: Role.ADMIN, // 0의 값이 자동으로 지정된다.}; 기타 타입 이제 타입스크립트에서의 모든 핵심 타입은 모두 훑어봤다.그 외의 타입들만 더 알아보면 될 것 같다…!! 조합 타입 우선 조합 타입이다. 이는 javascript의 삼항연산자와 비슷한 느낌이라고 볼 수 있는데or, || 과 같은 맥락이라고 보면 이해하기 쉽다. 123456function combine(a: number | string, b: number | string) { return a + b;}combine('hoonjoo', 'park'); // hoonjooparkcombine(5, 15); // 20 리터럴 타입 위에서 설명한 enum과 궤를 같이 한다고 볼 수 있다.특정 값을 조합(union)타입과 함께 사용할 수도 있는 조금 더 유연한 타입이다. 1234function combine(a: number | string, b: number | string, c: 'toNum' | 'toStr'){ c === 'toNum' ? return a + b || return a.toString() + b.toString();}; 근데…. 계속 이렇게 타입을 타이핑 하는게 귀찮을 땐 어떻게 방법이 없을까? type Alias를 사용하면 된다 🙂 123456789101112131415// 이렇게 타입을 변수화 하여 사용할 수 있다.type CalcType = number | string;function combine(a: CalcType, b: CalcType){ return a + b;}// 이런 방식도 물론 가능하다.type User = { name: string; age: number };function sayHello(user: User){ console.log(`Hi ${user.name}, you are ${user.age} years old right?')};sayHello('Jonh Doe', 33); 함수 타입 &amp; ‘절대’ 타입 &amp; ‘알 수 없는’ 타입함수 return 값의 타입 지정 타입스크립트에선 함수에서 내가 반환하고자 하는 값을 미리 산정하여 해당 타입의 값만 return 되도록 설정할 수 있다. 123456789// return값이 number만 반환될 수 있도록 지정한다.function sum(a: number, b: number): number { return a + b;}// return값이 아예 없도록 지정한다. (void)function sayHello(a: string): void { console.log(`hi ${a}!!`); // console.log는 return이 아니라는 점에 유의하자!} 함수 자체를 타입으로 지정해주기 특정 변수에 함수 자체를 담아야 하는 경우가 발생할 수도 있다.이런 경우에는 아래와 같이 함수를 타입으로 지정해주면 된다. 1234567891011const add(num1: number, num2: number) { return number1 + number2;};const combine(input1: string, input2: string) { return input1 + input2;};let sum: (a: number, b: number) =&gt; number;sum = add; // 두 함수의 들어가는 매개변수 타입이 동일하기 때문에 오류 없이 잘 실행될 수 있다.sum = combine // 이는 매개변수 타입이 서로 상이하기 때문에 오류가 발생된다. 콜백을 지정해주기12345678const add(num1: number, num2: number, (num: number)=&gt; void) { testCallback(num1 + num2);};// 위에서 콜백함수의 리턴값을 void로 지정해줬기 때문에, return이 아닌 console.log를 사용했다.add(5,10, (result)=&gt;{ console.log(result)})","link":"/typescript/Typescript_basicType/"},{"title":"[Node.js] 11047번 : 동전 0","text":"문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) 출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다. 풀이 과정 실수로 완전탐색 방식으로 풀어버릴 뻔 했다….처음 풀어보는 그리디 알고리즘 유형이었어서 여러 풀이법들을 참고했다. 그리디 알고리즘…? 그리디 알고리즘은 모든 경우의 수를 탐색하는 알고리즘이 아니다. 따라서 경우에 따라 내가 도출한 답이 최적의 답이 아닐 수도 있다. ( 하지만 빠를 수는 있음 ) 코드 로직 우선 N값과 K값을 선언해준다. 카운트를 세야 하기 때문에 count 변수 또한 선언해준다. 그리디 알고리즘이기 때문에, 작은 값에서 큰 값으로 탐색하는 것은 비효율적이다. 따라서, 배열의 가장 우측에서부터 차례대로 탐색하는 것이 빠른 해답을 찾기 위한 방법일 것이다. for문 또한 i가 감소하는 식으로 구성한다. 우측에서부터 진행되기 때문에 최소 조합을 구성하기 위해선 K/Arr[i]가 count에 담기면 된다. 그리고 K값은 해당 Arr[i]값으로 나눈 나머지, 즉 K%= Arr[i]가 되면 된다. 이렇게 반복문을 계속 돌리면 우측에서부터 탐색했을 경우의 최소 동전 집합의 개수를 구할 수 있다. 소스 코드123456789101112function coin(arr, NK) { // K와 N 선언 const N = NK[0]; let K = NK[1]; let count = 0; // 합이 K가 되는 동전 조합의 최소값 구하기 for (let i = N - 1; i &gt; 0; i--) { count += Math.floor(K / arr[i]); K %= arr[i]; } return count;}","link":"/algorithm/boj/11047/"},{"title":"[Node.js] 13305번 : 주유소","text":"문제어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다. 처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다. 예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다. 각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오. 입력표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 제일 왼쪽 도로부터 N-1개의 자연수로 주어진다. 다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 도시부터 순서대로 N개의 자연수로 주어진다. 제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 1이상 1,000,000,000 이하의 자연수이다. 리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다. 출력표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다. 풀이 과정 현재 가격과 다음 목적지의 가격을 비교하면 쉽게 풀 수 있을 것 같다. 우선 첫 시작점에서는 반드시 주유를 해야한다. 두번째 목적지에서 부터는 목적지별 주유비용을 서로 비교하며, 더 싼 가격이 나오기 전 까지는 같은 값을 유지한다. (거리만큼 계속 곱해나감) 그리고 더 저렴한 목적지가 나오면 그 뒤로부터는 다시 기준 주유비용을 현재 목적지의 주유비용으로 설정한다. 소스코드12345678910111213function gasStation(N, distance, cost) { let answer = distance[0] * cost[0]; for (let i = 1; i &lt; N - 1; i++) { if (cost[i] &lt; cost[i - 1]) { answer += cost[i] * distance[i]; } else { answer += cost[i - 1] * distance[i]; } } return answer;}gasStation(4, [2, 3, 1], [5, 2, 4, 1]);","link":"/algorithm/boj/13305/"},{"title":"[Node.js] 11399번 : ATM","text":"문제인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다. 사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다. 줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다. 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000) 출력첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다. 풀이 과정 최소한의 대기시간으로 사람들이 ATM업무를 처리할 수 있도록 하는 줄서기 배열을 구하고, 총 걸린 시간을 반환하면 된다. 앞 사람의 업무처리 시간이 길수록 뒷 사람들의 대기시간은 더 늘어난다. 따라서 업무처리 시간이 짧은 순서대로 사람들을 줄 세워야 한다. 업무처리 시간을 기준으로 오름차순 정렬하면 쉽게 풀 수 있는 문제다. tempSum : 자신을 제외한 이전까지의 합을 구하기 위한 변수 sum : 대기시간 + 업무처리 시간까지 모두 합한 해당 요소까지의 시간 소스코드123456789101112131415function ATM(n, arr) { // 우선 업무처리시간이 짧은 순으로 오름차순 정렬한다. arr.sort((a, b) =&gt; a - b); // 자신을 제외한 이전까지의 합을 담는 tempSum let tempSum = 0; // 자신을 포함한 모든 대기시간 + 업무처리시간의 합 let sum = 0; for (let i = 0; i &lt; n; i++) { // tempSum은 총 대기시간이 된다. (앞의 요소들의 업무처리 시간들의 합이기 떄문) // 또한 tempSum이 뒤에 연산되기 때문에 sum에 더해지는 tempSum은 이전까지의 대기시간 + 업무처리 시간이다 sum += tempSum + arr[i]; tempSum += arr[i]; } return sum;}","link":"/algorithm/boj/11399/"},{"title":"[Node.js] 1931번 : 회의실 배정","text":"문제한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. 입력첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다. 풀이 과정 최대한 회의실 사용 일정을 꽉꽉 채워 담아야 한다.따라서 이번에는 큰 수에서 내림차순으로 탐색하는 것이 아니라, 작은 수에서 오름차순으로 탐색해야 한다. 배열을 회의가 끝나는 시간이 가장 빠른 순으로 오름차순 정렬한다. 끝나는 시간 순으로 정렬을 했기 때문에, 시작 시간이 끝나는 시간보다 크거나 같으면 해당 미팅을 진행할 수 있다. 따라서, 미팅을 스케줄에 넣을 때 마다 endpoint가 방금 추가된 미팅의 끝나는 시간으로 설정되어야 한다. (아래 그림 참조) 반복문 활용 arr[i][0] === end라면 count를 더한다. 그리고 end값을 수정한다. 최종적으로 count를 return해준다. 소스코드12345678910111213141516function meetingRoom(arr, N) { // 보기에서는 끝나는 시간 순으로 이미 정렬되어 있었지만, 다른 인풋값이 들어올 경우를 대비해 정렬을 해줬다. arr.sort((a, b) =&gt; a[1] - b[1]); // 두 번째 시간부터 체크할 것이기 때문에 카운트는 1, end도 첫 째 미팅의 끝나는 시간으로 선언 let count = 1; let end = arr[0][1]; for (let i = 1; i &lt; arr.length; i++) { // 만약 현재 미팅의 시작시간이 전에 추가된 미팅의 끝나는 시간보다 크거나 같으면 추가할 수 있다. if (arr[i][0] &gt;= end) { // 카운팅을 하고, end값을 현재 미팅의 종료시간으로 갱신한다. count++; end = arr[i][1]; } } return count;}","link":"/algorithm/boj/1931/"},{"title":"[Node.js] 1541번 : 잃어버린 괄호","text":"문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다. 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오. 입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 출력첫째 줄에 정답을 출력한다. 풀이 과정 마이너스 앞에 있는 숫자를 최소로 만들고, 마이너스 뒤에 있는 숫자들의 크기를 가장 크게 만들면 주어진 조건을 만족할 수 있을 것 같다. -를 기준으로 문자열을 split 그리고 다시 +를 기준으로 split 각 배열들의 합을 우선 구한다. (map &amp; reduce) 그리고 그 합들을 모두 빼준다. (reduce) 소스코드12345678910111213function lost(input) { // -를 기준으로 String을 배열로 나눠준다. let arr = input.split('-'); // +를 기준으로 +가 들어있는 배열들을 다시 또 나눠준다. arr = arr.map((el) =&gt; el.split('+')); // 그리고 각자 배열들의 요소들을 reduce를 사용하여 더해준다. arr = arr.map((el) =&gt; el.reduce((prev, cur) =&gt; Number(prev) + Number(cur))); // 이제 각 값들을 빼주기만 하면 된다 let answer = arr.reduce((prev, cur) =&gt; Number(prev) - Number(cur)); return answer;}lost('55-50+40');","link":"/algorithm/boj/1541/"},{"title":"프로그래머스 - 큰 수 만들기 (Javascript)","text":"문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다.⇒1 &lt; k &lt; number.length 입출력 예 number k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 풀이 과정 각 경우의 수들을 모두 배열 형태로 나열해보고 → Number로 바꾼 뒤에 가장 큰 수를 찾아서 해당 값의 원본 배열에서의 index값을 찾는다. 배열화 하여 모든 요소들을 숫자로 변환한다. 반복문을 돌린다. while(answer.length &lt; length){} 만약 Math.max(…arr)의 값의 index+length &gt; arr.length-1이 아니라면 해당 값이 가장 첫번째 자리수다. 해당 max숫자의 index를 indexOf를 통해 찾는다. (maxIndex) 그리고 그 인덱스+1 이전의 배열들은 잘라낸다. (arr.slice(maxIndex+1)) 그리고 해당 max값을 answer에 담는다. (answer.push(max)) 다시 반복문을 재개한다. 소스코드 (1차시도) 시간초과 4회 123456789101112131415161718192021222324252627282930function solution(number, k) { let answer = []; const endpoint = number.length - k; let length = number.length - k; let arr = [...number]; arr = arr.map((el) =&gt; Number(el)); let sortedArr = [...number]; sortedArr = arr.map((el) =&gt; Number(el)); sortedArr.sort(); let minIndex = arr.length - length; let i = sortedArr.length - 1; while (answer.length &lt; endpoint) { let max = sortedArr[i]; let maxIndex = arr.indexOf(max); if (maxIndex &lt; 0) { i--; } else if (maxIndex &lt;= minIndex) { answer.push(max); arr = arr.slice(maxIndex + 1); length--; minIndex = arr.length - length; i = sortedArr.length - 1; } else { i--; } } answer = answer.join(''); return answer;} 소스코드 (2차시도)12345678910111213141516171819202122232425function solution(number, k) { let answer = []; let count = 0; for (let i = 0; i &lt; number.length; i++) { let current = number[i]; if (answer.length === 0) { answer.push(current); continue; } while (answer[answer.length - 1] &lt; current) { answer.pop(); count++; if (count === k) { return answer.join('') + number.slice(i); } if (answer.length === 0) { break; } } answer.push(current); } return answer.join('').slice(0, number.length - k);}solution('4177252841', 4);","link":"/algorithm/programmers/BiggerNumber/"},{"title":"프로그래머스 - 구명보트 (Javascript)","text":"문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이 과정 사람들을 우선 무게별로 내림차순 정렬한 뒤, 이중 포인터를 사용해서 풀이했다. sort((a,b) ⇒ b-a)를 통해 무게별 내림차순 정렬한다. 다중 포인터를 선언한다 (i,j) 양 끝값이 limit보다 작거나 같으면 포인터를 모두 좁힌다. 만약 위의 조건을 통과하지 못하면 좌측 포인터를 한칸 우측으로 이동시킨다 (가장 무거운 사람) 소스 코드123456789101112131415161718192021222324function solution(people, limit) { people.sort((a, b) =&gt; b - a); let rescued = 0; let count = 0; // 초기 i,j값은 각각 양 끝이다. let i = 0; let j = people.length - 1; // 구조된 사람의 숫자와 기존 사람 숫자가 같아지면 반복문을 종료한다. while (rescued &lt; people.length) { // 만약, 양 끝의 합이 limit보다 작거나 같으면 두 사람을 우선 구조한다. j--, i++ if (people[i] + people[j] &lt;= limit) { j--; i++; count++; rescued += 2; // 근데 둘의 합이 100을 넘으면 i의 사람을 먼저 구조하고 i++를 한다.(정렬되어 있기 때문에 어차피 누구와도 같이 못탐) } else { i++; rescued++; count++; } } return count;}","link":"/algorithm/programmers/Boat/"},{"title":"프로그래머스 - K번째 수 (Javascript)","text":"문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 number k return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 풀이 과정 시간복잡도 때문에 최대한 반복문 안에 sort나 slice 등의 O(N) 메소드를 사용하지 않아보려고 했는데…도저히 떠오르지 않아서 일단 그냥 풀어봤다. 원본 배열 array는 손상되어서는 안된다. (tempArray 만들어줌) commands의 길이만큼 array에서 배열을 잘라내어 정렬하고 (slice), n번째 숫자를 알아내야 한다. 잘라내야 하는 횟수는 commands.length와 같다 따라서 for문도 commands.length를 기준으로 돌리면 된다. slice를 통해 잘라내고, 바로 오름차순으로 정렬한다. 그리고 해당하는 값을 anwer에 push해준다. commands.length는 최대 50까지다. 소스 코드12345678910function solution(array, commands) { let answer = []; let tempArray = []; for (let i = 0; i &lt; commands.length; i++) { tempArray = array.slice(commands[i][0] - 1, commands[i][1]); tempArray.sort((a, b) =&gt; a - b); answer.push(tempArray[commands[i][2] - 1]); } return answer;}","link":"/algorithm/programmers/KthNumber/"},{"title":"프로그래머스 - 완주하지 못한 선수 (Javascript)","text":"문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participan completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 설명예제 #1”leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2”vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3”mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 풀이 과정 생각보다 풀기는 수월했던 문제다. completion의 참가자들을 for문을 통해 object화 한다. key : 이름, value: count participant 배열을 다시 for문 돌려서 object에 해당 key가 존재하는지 체크한다. 존재하면 obj에서의 value를 1씩 차감시킨다. 만약 해당 참가자의 이름에 해당하는 value가 0이면 해당 참가자가 완주하지 못한 참가자다 소스코드123456789101112131415function solution(participant, completion) { var answer = ''; let obj = {}; for (let person of completion) { obj[person] ? obj[person]++ : (obj[person] = 1); } for (let person of participant) { if (!obj[person]) { answer = person; break; } obj[person]--; } return answer;}","link":"/algorithm/programmers/RetardRunner/"},{"title":"프로그래머스 - 모의고사 (Javascript)","text":"문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 풀이 과정 반복문을 돌려서 각 학생들이 가진 정답패턴으로 몇 개의 정답을 맞힐 수 있는지 계산하면 된다 answers는 1~마지막 문제 까지의 정답이 담긴 배열이다. 우선 각 학생들의 찍기 패턴을 선언한다. answers의 길이가 학생의 찍기패턴 한 단위보다 길 수 있다. 따라서 이 경우도 생각해줘야 한다. object 하나를 만들어서 각 학생별 정답 수를 카운팅한다. 각각 반복문을 돌린 뒤 (i는 answers의 포인터로, j는 학생의 찍기패턴 포인터로) 정답이 맞을 때마다 object[1~3]++를 해준다. object의 values들을 체크하여 비어있으면 [1,2,3]을, 비어있지 않다면 Math.max를 통해 최대값을 산출한다 최종적으로 해당 max와 일치하는 value값을 갖는 object를 찾아주고 answer 배열에 push해준다. 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function solution(answers) { let answer = []; const student1 = [1, 2, 3, 4, 5]; const student2 = [2, 1, 2, 3, 2, 4, 2, 5]; const student3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; let obj = {}; for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student1.length) { j = 0; } if (answers[i] === student1[j]) { if (!obj[1]) { obj[1] = 1; } else { obj[1]++; } } j++; } for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student2.length) { j = 0; } if (answers[i] === student2[j]) { if (!obj[2]) { obj[2] = 1; } else { obj[2]++; } } j++; } for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student3.length) { j = 0; } if (answers[i] === student3[j]) { if (!obj[3]) { obj[3] = 1; } else { obj[3]++; } } j++; } // 오브젝트에 담아줬기 때문에 각 값들을 다시 풀어준다. let values = Object.values(obj); // 만약 values가 비어있다면 아무도 한 문제도 못 맞힌 것이다. if (values.length === 0) { return [1, 2, 3]; } let max = Math.max(...values); // 반복문을 통해 object 안에 있는 key들의 value가 max와 일치하는 것들을 answer에 push한다 for (let i = 1; i &lt; 4; i++) { if (obj[i] === max) { answer.push(i); } } return answer;} 소스코드 (2차 풀이) 위의 코드가 너무 지저분해서 한번 리팩토링을 해봤다. 생각해보니 j값을 따로 두고 계속 학생의 정답패턴의 끝에 닿을 때 초기화 시킬 필요 없이 %를 사용하면 쉽게 해결할 수 있는 문제였다. 12345678910111213141516171819function solution(answers) { let answer = []; const s1 = [1, 2, 3, 4, 5]; const s2 = [2, 1, 2, 3, 2, 4, 2, 5]; const s3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; const s1Count = answers.filter((a, i) =&gt; s1[i % s1.length] === a).length; const s2Count = answers.filter((a, i) =&gt; s2[i % s2.length] === a).length; const s3Count = answers.filter((a, i) =&gt; s3[i % s3.length] === a).length; const max = Math.max(s1Count, s2Count, s3Count); if (s1Count + s2Count + s3Count === 0) return [1, 2, 3]; s1Count === max &amp;&amp; answer.push(1); s2Count === max &amp;&amp; answer.push(2); s3Count === max &amp;&amp; answer.push(3); return answer;}","link":"/algorithm/programmers/SemiTest/"},{"title":"프로그래머스 - 위장 (Javascript)","text":"문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_‘ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명 예제 #1headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. yellow_hat blue_sunglasses green_turban yellow_hat + blue_sunglasses green_turban + blue_sunglasses 예제 #2face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. crow_mask blue_sunglasses smoky_makeup 풀이 방법 경우의 수를 구하는게 참 빡센 알고리즘이었다. 오브젝트로 된 옷장을 만들어 관리하는게 효율적일 것 같다. 사실 어떤 옷이 들어갔느냐는 중요하지 않다. 각 카테고리별 몇 개의 옷이 들어갔는지가 중요하다. 따라서 오브젝트 형태로 관리해서 경우의 수를 계산해주면 된다. 옷장 closet 객체를 생성해준다. clothes.length만큼 반복문을 돌려서 각 카테고리별 옷의 개수를 카운팅 해준다. 마지막으로 경우의 수를 카운팅 해준다. 조합에 대한 경우의 수의 경우 만약 A,B,C 카테고리가 존재한다면 A+B+C+AB+AC+CB+ABC가 경우의 수를 도출하는 공식이 된다. 따라서 (A+1)(B+1)(C+1)-1을 해주면 위의 공식을 간략화 하여 도출할 수 있다. 소스코드1234567891011121314function solution(clothes) { let closet = {}; let answer = 1; for (let i = 0; i &lt; clothes.length; i++) { closet[clothes[i][1]] ? (closet[clothes[i][1]] += 1) : (closet[clothes[i][1]] = 1); } for (let key in closet) { answer *= closet[key] + 1; } // 아무 것도 안입었을 경우를 제해줘야 한다. return answer - 1;} 소스코드21234567891011121314151617181920212223function solution(clothes) { let array = []; let answer = 0; while (true) { let temp = clothes[0]; temp = temp[temp.length - 1]; let temparry = clothes.filter((part) =&gt; part[1] === temp).length; array.push(temparry); clothes = clothes.filter((part) =&gt; part[1] !== temp); if (clothes == false) { break; } } answer += array[0]; for (let i = 1; i &lt; array.length; i++) { let num = array[i] + 1; answer = answer * num + array[i]; } return answer;}","link":"/algorithm/programmers/Spy/"},{"title":"프로그래머스 - 체육복 (Javascript)","text":"문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve 5 [2,4] [1,3,5] 5 [2,4] [3] 3 [3] [1] 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 풀이 과정 체육복의 여분을 가져온 학생은 우선적으로 reserve에서 제외되어야 한다! 우선 object에 각 key에 대한 카운트를 한다. for문을 통해 reserve에 lost에도 똑같은 값이 있는지 체크하고, 해당 값을 양측에서 모두 제거해준다. ⇒ 단, 그냥 splice를 해버리면 배열의 length가 도중에 줄어들어서 반복문이 배열의 끝에 닿지 못한다. 이번에는 plus, minus 값이 object에 있는지 없는지 체크하고 있다면 해당 값들을 제거한다. 각 조건문마다 answer++를 걸어서 최종적으로 answer값을 도출해주면 된다. 소스코드1234567891011121314151617181920212223242526function solution(n, lost, reserve) { lost.sort(); reserve.sort(); let obj = {}; lost.forEach((el) =&gt; !obj[el] &amp;&amp; (obj[el] = 1)); let answer = n - lost.length; for (let i = 0; i &lt; reserve.length; i++) { if (obj[reserve[i]]) { obj[reserve[i]]--; answer++; reserve.splice(i, 1, 'del'); } } for (let i = 0; i &lt; reserve.length; i++) { let minus = reserve[i] - 1; let plus = reserve[i] + 1; if (obj[plus]) { obj[plus]--; answer++; } else if (obj[minus]) { obj[minus]--; answer++; } } return answer;} 프로그래머스 고인물의 풀이…. (filter 활용)12345678910function solution(n, lost, reserve) { return ( n - lost.filter((a) =&gt; { const b = reserve.filter((c) =&gt; Math.abs(c - r) &lt;= 1); if (!b) return false; reserve = reserve.filter((d) =&gt; d !== b); }) );}","link":"/algorithm/programmers/greedy1/"},{"title":"프로그래머스 - 조이스틱 (Javascript)","text":"문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 🔼 - 다음 알파벳🔽 - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다. 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.따라서 11번 이동시켜 “JAZ”를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 Name Return “JEROEN” 56 “JAN” 23 풀이 과정 예전에 백준에서 비슷한 문제를 풀어본적 있던 것 같다.아래의 아스키 코드를 활용하면 될 것 같고, 거리계산을 효율적으로 하면 풀 수 있을 것 같다. 😅 …는 나의 헛된 망상이자 꿈이었다….ㅋㅋ 😅 아스키코드 Cheat Sheeta~z : 97122**AZ** : 6590**09** : 48~57 우선 String을 배열로 split한다 그리고 각 배열의 요소들을 charCodeAt을 통해 아스키 코드로 변환한다 어떻게 위로 올리는게 효율적인지, 아래로 내리는게 효율적인지 판단할까? ⇒ Math.min(Math.abs(bottom - num), Math.abs(top - num)) 바닥값과 천장값 사이의 거리 중에 가장 가까운 것을 선택하면 된다. 좌우 커서 이동의 경우의 수 ⇒ 총 4개의 케이스를 고려한다. Case1 : 우측으로만 이동할 때 Case2 : 좌측으로만 이동할 때 Case3 : 우측으로 시작했는데 도중에 좌측으로 꺾을 때 Case4 : 좌측으로 시작했는데 도중에 우측으로 꺾을 때 저 네 개의 Case 중에 가장 최솟값을 answer에 더해주면 된다. 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function solution(name) { let answer = 0; let arr = name.split(''); arr = arr.map((el) =&gt; el.charCodeAt(0)); let indexes = []; // 상하 이동값부터 계산 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] !== 65) { answer += Math.min(Math.abs(65 - arr[i]), Math.abs(91 - arr[i])); // A가 아닌 값들의 index를 관리하기 위한 indexes 배열을 만들어 활용했음 indexes.push(i); } } // 처음 값이 A가 아닐 경우에는 어차피 커서 좌우 이동에 영향을 주지 않기 때문에 그냥 indexes에서 빼줘도 된다. if (arr[0] !== 65) { indexes.shift(); } // 만약에 길이가 하나면, 굳이 아래의 모든 케이스를 돌려볼 필요가 없다. // 따라서 우측으로 이동하는게 더 나은지, 좌측으로 이동하는게 더 나은지만 판단하면 된다. if (indexes.length === 1) { let left = Math.abs(arr.length - indexes[indexes.length - 1]); let right = indexes[0]; answer += Math.min(left, right); console.log(left, right); return answer; } // 이제 좌우값 체크 // #Case1 : 우측으로만 갈 때 let case1 = arr.length - 1; // #Case2 : 좌측으로만 갈 때 let case2 = Math.abs(arr.length - indexes[0]); // #Case3 : 우측으로 시작했는데 한 번 꺾을 때 let case3 = 0; // 만약에 첫 값이 A가 아니라면 그 값을 건너 뛰어서 시작해야된다. let i = arr[0] !== 65 ? 1 : 0; // 단지 let case3BCount = 0; while (true) { if (case3BCount !== 0 &amp;&amp; arr[i + 1] === 65) { break; } else if (case3BCount === indexes.length - 1) { break; } if (arr[i + 1] !== 65) { case3BCount++; i++; } else { i++; } } // 한번 갔다가 같은만큼 돌아오기 때문에 2를 곱해준다. case3 = i * 2 + arr.length - indexes[case3BCount]; // #Case4 : 좌측으로 시작했는데 한 번 꺾을 때 let case4 = 0; let j = arr[arr.length - 1] !== 65 ? arr.length : arr.length - 1; let case4BCount = 0; while (true) { if (case4BCount !== 0 &amp;&amp; arr[j - 1] === 65) { break; } else if (case4BCount === indexes.length - 1) { break; } if (arr[j - 1] !== 65) { case4BCount++; j--; } else { j--; } } case4 = (arr.length - j) * 2 + indexes[indexes.length - case4BCount - 1]; return answer + Math.min(case1, case2, case3, case4);}","link":"/algorithm/programmers/JoyStick/"},{"title":"Udemy - Big O (빅오 표기법)","text":"Big O? 💡 Big O표기법이란, 코드의 상대적 성능과 효율성을 측정할 수 있는 지표다. 왜 사용해야 하는가? 코드 작동과 성능에 대한 명확한 측정 척도가 필요하다. 같은 솔루션 내의 서로 다른 코드의 성능을 상대적으로 비교하는데 도움이 된다. 내 코드의 비효율적인 부분을 찾아서 해결할 수 있다. 그리고…. 면접에 단골 출제된다…!! 뭐가 더 나은 코드일까? 속도가 빠른 코드 ?⇒ 컴퓨터 성능에 따라 상이, 측정값이 정확하지 않다 메모리 점유율이 낮은 코드 ? 가독성이 좋은 코드 ? Big O의 기본 컴퓨터가 처리해야 하는 작업의 횟수를 계산 (컴퓨터 하드웨어와는 무관) O(1) ⇒ n값이 변하던 말던 처리 작업 횟수는 동일함! (일직선 수평 그래프) O(n) ⇒ 1차함수 그래프 O$$(n^2)$$ ⇒ 2차함수 그래프, 중첩 반복문 Big O 심플 계산법 (간소화) n 앞 뒤의 사칙연산 등은 무시해도 된다. 가장 큰 n제곱이 Big O의 n값이 된다. 특정 조건에 따라 리턴값이 달라질 경우 ? 무한대를 가정하고 풀면 된다. 1234567function logAtMost10(n) { // 이 경우 0~9까지는 다른 값들이 출력되는데 10부터는 계속 1~10이 출력된다. // 따라서 무한대를 가정하면 이 시간복잡도는 O(1)이 된다. for (let i = 1; i &lt;= Math.min(n, 10); i++) { console.log(i); }} 공간 복잡도 입력값(n)이 증가함에 따라 알고리즘이 차지하는 공간이 어떻게 변하는지?즉, 알고리즘이 차지하는 메모리에 초점을 맞춤 규칙들 불린, 숫자, undefiend, null은 모두 같은 크기의 공간을 차지한다. 문자열(String)은 O(n)의 크기를 필요로 한다. 배열과 오브젝트 또한 O(n)의 크기를 필요로 한다. 계산 방법 ⇒ 선언되는 변수, 즉 차지하는 메모리에 집중한다. (시간 복잡도는 차치)그리고 이전과 같이 무한대를 가정하기도 한다. 예시11234567function logUpTo(n) { // 이 경우 n값이 아무리 증가해도 메모리 공간은 &quot;i=&quot; 한 자리만 변화하며 필요하기 때문에 // 이 알고리즘의 공간 복잡도는 O(1)이다. for (let i = 1; i &lt;= n; i++) { console.log(i); }} 예시21234567891011function onlyElementsAtEvenIndex(array) { var newArray = Array(Math.ceil(array.length / 2)); // 이 경우는 array의 길이가 증가할 때마다 차지하는 공간도 커진다. // 따라서, 이 알고리즘의 공간 복잡도는 O(n)이다. for (let i = 0; i &lt; array.length; i++) { if (i % 2 === 0) { newArray[i / 2] = array[i]; } } return newArray;} 로그와 섹션 재생 로그 복잡도의 사용 이유 몇몇 검색 알고리즘에서 종종 사용된다. 효율적인 정렬 알고리즘은 로그를 포함한다. 재귀 알고리즘에서 로그 공간 복잡도를 사용한다.","link":"/algorithm/udemy/1.%20BigO/"},{"title":"Udemy - 버블 정렬","text":"정렬 알고리즘에는 정말 많은 종류가 존재한다.하지만 모두 상황에 따라 사용해야 하며, 어떤 상황에서나 완벽하게 적용되는 단 하나의 정렬 알고리즘은 존재하지 않는다.따라서 오늘은 가장 일반적인 버블정렬 알고리즘에 대해 정리해보고자 한다. 정렬을 왜 배워야 하는가? 프로그래밍 또는 알고리즘에서 정말 자주 사용되는 알고리즘이기 때문이다. 삽입, 선택, 버블, 쉘, 병합, 힙, 퀵 정렬 등의 다양한 정렬 알고리즘들이 존재한다. 💡 가장 기초적인 정렬 알고리즘은 버블, 선택, 삽입 정렬 알고리즘이다. (효율성도 조금 떨어짐)=&gt; 그래도 특정 상황에서는 매우 효율적일 수 있음 상황에 따라 효율적인 정렬 알고리즘이 있다. (장단점들이 각기 존재함) 면접에 빈출되는 주제다. sort 자바스크립트 내장함수 평소에 자주 사용했던 sort() 자바스크립트 내장 함수다.시간복잡도는 기본적으로 O(N)이지만 MDN에 따르면 인풋의 크기에 따라 복잡도가 달라질 수 있다고 한다. sort()내장함수는 때에 따라서는 굉장히 손쉽게 사용할 수 있지만, 모든 정렬 기준이 배열 내의 값들을 유니코드(String)으로 변환한 후 → 해당 값을 기준으로 정렬을 한다. 따라서 내가 원하는 결과값을 얻지 못할 확률이 높다. 이를 방지하기 위해 comparator함수를 활용할 수 있다. 12345// 오름차순 정렬somethig.sort((a, b) =&gt; a - b);// 내림차순 정렬something.sort((a, b) =&gt; b - a); 버블 정렬 자주 사용되지는 않는 정렬 알고리즘이다.그래도 이 정렬 알고리즘을 배워야 하는 이유는, 다른 알고리즘들이 얼마나 효율적인지 역체감을 할 수 있기 때문이다. 물론 이와 같이 배열의 순서를 반복문 안에서 계속 변경해줘야 한다는 점과, 지속적인 순회를 해야된다는 점이 까다롭다. 하지만 매 반복마다 순회해야 하는 배열의 길이가 짧아진다는 점도 잊어서는 안된다. 위치 바꾸기 위와 같이 ES6 문법을 사용해서 쉽게 두 요소의 위치를 바꿔줄 수 있다. 기본 예제 배열 요소들을 오름차순으로 정렬하는 버블 정렬 알고리즘을 작성하시오.j와 i 포인터 활용 1234567891011121314151617function bubble(arr) { let i = arr.length - 1; let j = 0; while (i &gt; 0) { if (j === i) { j = 0; i--; } if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } j++; } return arr;}bubble([29, 10, 14, 37, 14]); 버블정렬 최적화 버블정렬의 특성상, 매우 긴 배열에서 이미 정렬이 끝났음에도 불구하고 계속 i가 1에 닿을 때 까지 반복문을 돌린다. 이는 굉장히 비효율적이므로 최적화를 통해 이러한 문제점을 해결해야 한다. 123456789101112131415161718192021222324function bubble(arr) { let i = arr.length - 1; let j = 0; // isSwap이라는 변수를 활용한다. let isSwap; while (i &gt; 0) { // j가 끝에 닿아서 다시 0부터 탐색을 해야 할 때 isSwap을 체크한다. if (j === i) { if (!isSwap) break; // isSwap, 즉 위치 변경이 일어났다면 다시 isSwap을 false로 초기화 시킨다. isSwap = false; j = 0; i--; } // 만약 j가 i에 닿을때 까지 정렬이 한번도 안일어나면 초기의 isSwap=false 값이 유지될 것이다. // 이에 따라 반복문은 break 된다. if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; isSwap = true; } j++; } return arr;} 버블정렬의 시간복잡도 정렬이 이미 많이 된 배열에 대해서는 O(N)의 시간복잡도를 가질 수 있다. (위에서 활용한 isSwap을 사용) 하지만 일반적인 경우의 버블정렬 시간복잡도는 O($$n^2$$)이다.","link":"/algorithm/udemy/10.%20Bubble/"},{"title":"Udemy - 선택 정렬","text":"선택정렬이란? 선택정렬은, 버블정렬과 반대로 가장 작은 값을 찾아서 배열의 제일 앞에 쌓는 방식을 사용한다.따라서 버블정렬과 알고리즘 메카니즘 자체는 굉장히 비슷하다고 볼 수 있다. 위와 같이 배열의 가장 첫 요소부터 검사를 시작하며, 해당 값보다 작은값이 있는지 계속 체크한다. 기준 값보다 작은 값을 발견하면, 버블 정렬처럼 바로 Swap을 해주는 것이 아니라 포인터를 그 값으로 우선 이동시킨다. 그리고 해당 포인터의 값을 기준으로 다시 남은 끝부분까지 검사를 반복하며 배열에서 “가장 작은 값”을 찾아내어 제일 앞으로 이동시키는 것이다. 따라서 선택 정렬의 핵심은 가장 작은 값을 찾아서 앞으로 옮겨주는 것이라고 할 수 있다. 선택정렬 기본 예제 주어진 배열을 선택 정렬 방식으로 정렬하는 알고리즘을 작성하시오. 1234567891011121314151617181920212223function selection(arr) { // i는 배열의 시작점을, tempMin은 계속 변경될 최소값을, j는 비교를 위한 포인터를 의미한다. let i = 0; let tempMin = i; let j = tempMin + 1; while (i &lt; arr.length - 1) { if (j &gt; arr.length - 1) { [arr[i], arr[tempMin]] = [arr[tempMin], arr[i]]; i++; tempMin = i; j = tempMin + 1; } if (arr[tempMin] &gt; arr[j]) { tempMin = j; j++; continue; } j++; } return arr;}selection([22, 10, 3, 14, 30, 14]); 선택 정렬의 시간 복잡도 $O(n^2)$ 의 시간복잡도를 갖는다.이 또한 그리 효율적이지는 않은 알고리즘이지만, 그래도 swap을 버블정렬보다는 덜 하기 때문에 조금 더 나은 선택이 될 수는 있다.","link":"/algorithm/udemy/11.%20Selection/"},{"title":"Udemy - 삽입 정렬","text":"삽입 정렬이란? 삽입 정렬 또한 가장 초급 수준의 정렬 알고리즘이다.버블정렬, 선택정렬과 맥락이 비슷하지만, 그래도 이 셋중에는 가장 활용도가 높고 상대적으로 효율적인 정렬 알고리즘이라고 할 수 있다. 위의 예시에서 보이는 바와 같이, 계속 한 칸 옆의 배열을 그 앞의 배열들과 비교하여 중간에 삽입할 곳을 찾는다. 즉, 기준점 포인터를 기준으로 순회 포인터 i를 통해 계속 우측으로 이동하며 검색한다. j가 다음 대상으로 이동했을 때, 0~i의 수들을 i-- 하며 계속 숫자를 i와 비교하고, 좌측 값이 i값보다 작거나 같으면 그 값의 오른쪽에 삽입시키면 된다. 삽입 정렬 기본 예제 주어진 배열들을 오름차순으로 삽입 정렬하는 알고리즘을 작성하시오. 1234567891011121314151617181920function insertion(arr) { // 기준 값을 저장할 currentVal 변수를 선언한다. let currentVal; // 0은 좌측에 비교할 대상이 어차피 없기 때문에 1부터 시작한다. for (let i = 1; i &lt; arr.length; i++) { // 우선 currentVal에 현재 값을 저장해둔다. currentVal = arr[i]; // j가 0에 닿을 때 까지 for문을 돌리고 j는 1씩 감소해 나간다. // 그리고 j를 var로 선언한 이유는 해당 for문 블록 스코프 바깥인 상위 for문에서 j값을 활용해야 하기 때문이다. for (var j = i - 1; j &gt;= 0; j--) { // 근데 만약 currentVal이 왼쪽값보다 크거나 같으면 그 왼쪽 값들은 더 탐색할 필요가 없다. // 따라서 그냥 break를 해주고 반복문에 의해 j--를 해준다. if (arr[j] &lt;= currentVal) break; arr[j + 1] = arr[j]; } // 그리고 아까 전 j값 오른쪽(j+1)에 currentVal을 위치시킨다. arr[j + 1] = currentVal; } return arr;} 삽입 정렬 시간 복잡도 보통의 경우는 $O(n^2)$의 시간복잡도를 갖는다.하지만, 정렬이 잘 되어있는 경우에는 더 효율적으로 정렬이 수행될 수 있다. ⇒ 완전히 역순으로 정렬된 배열의 경우 최악의 시간복잡도를 보일 수 있다….! 이 링크를 참고해보면 각 정렬 알고리즘별 시간복잡도 및 효율성을 한 눈에 쉽게 확인해볼 수 있다.Sorting Algorithms Animations","link":"/algorithm/udemy/12.%20Insert/"},{"title":"Udemy - 병합 정렬","text":"병합 정렬? 1948년 수학자 조나단 벤자민 뉴이맨이 만든 알고리즘이다.널리 알려져있고, 매우 빠른 속도를 자랑하는 정렬 알고리즘 중 하나이다. 분할점령 접근법을 활용한다.이전에 분할점령(Divide and Conquer)을 활용해본적이 있다. 분할점령은 배열을 쪼개가며 특정 값을 빠르게 찾아나가는 알고리즘이었는데, 병합 정렬 또한 비슷한 접근법을 취한다. 우선, 초기 배열을 이등분하고, 지속적으로 배열이 개별 원소들로 쪼개질 때 까지 n등분한다. 그리고 다시 원소들을 단계별로 병합하며 작은 수부터 정렬해 나가는 것이다. 사실 글로 표현하기엔 다소 어려운 부분이기에 아래의 시각자료를 보면 쉽게 이해할 수 있을 것이다. 병합을 하는 방법 (step1) 분할을 해서 가장 작은 단위로 만들고, 점점 조합(병합)해 나가며 정렬하겠다는 것은 알겠다.그렇다면 그 병합은 어떻게 이루어지는 걸까? 기본 병합 예제 주어진 정렬된 두 배열을 병합하여 완전히 정렬된 배열로 만들기 1234567891011121314151617181920212223242526function merge(arr1, arr2) { let answer = []; let i = 0; let j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr1[i] &lt;= arr2[j]) { answer.push(arr1[i]); i++; } else { answer.push(arr2[j]); j++; } } while (i &lt; arr1.length) { answer.push(arr1[i]); i++; } while (j &lt; arr2.length) { answer.push(arr2[j]); j++; } return answer;}merge([1, 10, 50], [2, 14, 99, 100]);merge([1, 14, 17, 22, 101], [2, 14, 99, 100]); 병합 정렬 알고리즘 구현 (step2) 위의 병합 알고리즘과 재귀 알고리즘을 합치면 병합 정렬 알고리즘을 구현할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637function mergeSort(arr) { // 병합 알고리즘 파트 (비교와 정렬이 일어남) const merge = (arr1, arr2) =&gt; { let answer = []; let i = 0; let j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr1[i] &lt;= arr2[j]) { answer.push(arr1[i]); i++; } else { answer.push(arr2[j]); j++; } } while (i &lt; arr1.length) { answer.push(arr1[i]); i++; } while (j &lt; arr2.length) { answer.push(arr2[j]); j++; } return answer; }; // 병합 정렬 재귀 알고리즘 파트 (실질적으로 분할이 일어나는 곳) // 1. endpoint를 지정해준다. if (arr.length &lt;= 1) return arr; // 2. 분할을 위해 중간값, 좌측 배열, 우측 배열을 선언해준다. let mid = Math.floor(arr.length / 2); // 0~mid까지 =&gt; 계속 콜스택에 쌓아 끝까지 분할하기 위해 재귀호출 let left = mergeSort(arr.slice(0, mid)); // mid~끝까지 let right = mergeSort(arr.slice(mid)); // left와 right가 각각 정립되면 merge 함수를 호출해 병합하고 정렬해준 값을 리턴해준다. return merge(left, right);} 시간복잡도와 공간복잡도 시간 복잡도 : O(nlogn) 공간 복잡도 : O(n)","link":"/algorithm/udemy/13.%20Merge/"},{"title":"Udemy - 퀵 정렬","text":"퀵 정렬이란? 병합 정렬과 비슷하게 분할과 재귀함수를 사용하여 정렬한다.하지만 퀵 정렬에서의 분할(피버팅)은 병합에서의 분할과는 조금 다르다. 위에서 보이는 바와 같이 특정 피벗(pivot)숫자를 하나 고르고, 그 숫자를 기준으로 그 숫자보다 작은 수는 자신의 왼쪽으로 무작위로 보내고, 큰 수는 우측으로 무작위로 보낸다. 그리고 좌측 숫자들을 다시 포인터를 내려가며 순회 정렬하고 우측 또한 마찬가지로 정렬하면 된다. 쉽게 생각하면 피벗숫자를 기준으로 배열을 이등분 하고 각 배열들의 숫자들을 차례대로 정렬하는 것이다. 피벗 헬퍼 알고리즘 (step 1) 위에서 설명했듯이, 퀵정렬을 하기 위해선 피벗 헬퍼 함수를 활용해야 한다.우선 특정 숫자 기준 작은 수들은 좌측으로, 큰 수들은 우측으로 옮겨준다. 기본 코드 예시 123456789101112131415161718function pivot(arr, start = 0, end = arr.length - 1) { // 1. 첫 번째 숫자를 pivot 숫자로 삼는다 arr[start]. let swapIdx = start; // 2. 해당 숫자를 기준으로 자신보다 작은 수를 우선 우측에 배치시킨다. for (let i = start + 1; i &lt;= end; i++) { if (arr[start] &gt; arr[i]) { swapIdx++; [arr[swapIdx], arr[i]] = [arr[i], arr[swapIdx]]; } } // 3. 그리고 그 작은 숫자들의 가장 끝 인덱스와 자리를 바꾼다. [arr[swapIdx], arr[start]] = [arr[start], arr[swapIdx]]; // 4. 그러면 이제 좌측에는 자신보다 작은 숫자들만 존재하고, 우측에는 자신보다 큰 숫자들만 존재하게 된다. console.log(arr); return swapIdx;}pivot([4, 8, 2, 1, 5, 7, 6, 3]); 퀵 정렬 구현 (step 2) 이제 pivot helper 함수를 구현해 뒀으니, 퀵 정렬 알고리즘만 구현하면 된다.상당히 재귀 과정이 복잡하고 어렵다… 1234567891011121314151617181920// javascript에서는 함수 매개변수가 undefined(완전 처음 실행 시)일 경우에 default값을 아래와 같이 지정해줄 수 있다.function quickSort(arr, left = 0, right = arr.length - 1) { // 재귀함수의 endpoint는 right가 left에 닿았을 때이다 (arr.length === 1이 될 때) if (left &lt; right) { // 우선 초기 배열을 피버팅 해준다. =&gt; 그러면 첫 배열 pivot값이 정렬 됐을 때의 index값이 리턴된다. let pivotIdx = pivot(arr, left, right); //3 //left // 여기부터 재귀함수가 실행된다. 배열 전체가 보내지지만 left ~ pivotIdx-1 까지만 피버팅이 다시 되도록 한다. // 먼저 pivotIdx를 기준으로 좌측 부분들이 모두 정렬될 때 까지 아래의 함수는 실행되지 않는다. quickSort(arr, left, pivotIdx - 1); //right // 좌측이 모두 정렬되면 이제 쌓여있던 콜스택이 비워지고 이 함수호출이 실행된다. // 계속 재귀함수를 실행하며 우측 또한 마찬가지로 정렬된다. quickSort(arr, pivotIdx + 1, right); } // 그러면 이제 최종적으로 정렬된 arr이 최하단 콜스택에 의해 반환된다. return arr;}quickSort([4, 8, 2, 1, 5, 7, 6, 3]); 퀵 정렬의 시간복잡도 시간 복잡도 : O(nlogn) 하지만, 퀵 정렬은 잘 정렬되어 있는 배열에 대해서는 비효율적일 수 있다","link":"/algorithm/udemy/14.%20Quick/"},{"title":"Udemy - 지수 정렬","text":"지수 정렬이란? 이전까지 공부했던 정렬들은 모두 “비교 정렬” 방식을 기반으로 했다.하지만 지수 정렬은 숫자가 가지는 특성, 즉, 이진법에 의한 자릿수를 기반으로 정렬을 한다. 사실 이렇게만 설명하면 이해가 쉽지 않기 때문에 아래의 시각자료를 보며 이해하면 좋을 것 같다. 10진수 기준 각 자리수의 값(0~9)을 각각 하나의 상자들로 구성해준다고 생각한다. 그리고 가장 첫번째 자리수 부터 검사를 시작하는데, 첫 자리수가 0이면 0에 담고, 8이면 8에 담듯 숫자의 절대적 크기는 고려하지 않은채 각 자리수의 크기로만 배열을 골라낸다. 그렇게 가장 긴 자리수 까지 검사를 완료하면 숫자가 오름차순으로 올바르게 정렬되는 것을 확인할 수 있다. 이는 각 숫자들의 절대적 크기를 비교한 것이 아닌, 각 자리수를 비교하며 정렬을 한 것이기 때문에 이전의 정렬 방식과는 큰 차이점을 보인다고 할 수 있다. getDigit 헬퍼 (step 1) 우리는 자리수 별로 숫자들을 비교해나가야 하기 때문에, 각 숫자들의 n자리수 값이 무엇인지 반환해주는 getDigit() 헬퍼 함수가 필요하다. 1234567function getDigit(num, i) { // (num의 절대값을 10의 i제곱으로 나눈 값) % 10 =&gt; 내림처리 // 만약 i가 2라면, 100의자리수를 구하는 것이기 때문에 10의 2제곱인 100으로 num을 나누게 된다 // 그리고 그 값은 자리수가 얼마나 크건간에 나눗셈에 의해 1의 자리수가 된다. // 이를 10으로 나눈 나머지는 1의자리수만 남게 되기 때문에 해당 자리수를 쉽게 구할 수 있다. return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;} digitCount 헬퍼 (step 2) 이제 자리수들을 도출하는 헬퍼 함수를 구현했으니, 반복문을 돌리기 위해 각 숫자들의 총 자리수가 몇인지 반환해주는 digitCount() 헬퍼함수를 구현해야 한다. 1234567function digitCount(num, i) { // 0log10의 값은 -Infinity가 나오기 때문에 0의 경우에는 아래와 같이 처리해줘야 한다. if (num === 0) return 1; // 10의 몇 제곱을 해야 num이 나오는지 반환해준다. 1234의 경우 10의 3제곱이 1000이다. // 따라서 3 + 1을 해주면 1000의 자리에 해당하는 4가 올바르게 반환될 수 있다. return Math.floor(Math.log10(Math.abs(num))) + 1;} maxDigit 헬퍼 (step 3) 위에서 각 숫자들의 총 자리수 길이를 구하는 헬퍼함수를 구현했다.따라서 이제 해당 숫자들 중에서 가장 긴 자리수를 반환해주는 maxDigit() 헬퍼 함수만 구현해주면 된다. 12345678function maxDigit(arr) { let maxDigits = 0; for (let i = 0; i &lt; arr.length; i++) { // 여기서 위에서 구현해둔 digitCount 헬퍼함수를 호출해서 사용하면 된다. maxDigits = Math.max(maxDigits, digitCount(arr[i])); } return maxDigits;} 지수 정렬 구현 (step 4) 이제 위의 모든 헬퍼 함수들을 활용해서 지수 정렬을 구현해주기만 하면 된다. Array.from() 전혀 활용하고 있지 못했던 메소드다…. 신세계였어서 한번 정리를 해봤다. 12let testArray = Array.from({ length: 10 }, () =&gt; []);// 이렇게 하면 testArray는 10의 길이를 갖고, 각 요소들이 빈 배열 []로 채워지는 배열이 된다. 지수 정렬 구현12345678910111213141516171819function radixSort(arr) { // 최대 자리수 카운트 반환 let maxDigits = maxDigit(arr); // 최대 자리수를 기준으로 첫 번째 반복문 구성 for (let i = 0; i &lt; maxDigits; i++) { // 체크하는 자리수가 바뀔 때마다 bucket 초기화 let bucket = Array.from({ length: 10 }, () =&gt; []); for (let j = 0; j &lt; arr.length; j++) { let digit = getDigit(arr[j], i); // n번째 자리수가 m인 숫자들을 bucket[n]에 각각 담아줌 bucket[digit].push(arr[j]); } // 그리고 그 자리수별 숫자들을 풀어서 arr의 값을 해당 값들로 바꿔줌 arr = [].concat(...bucket); } return arr;}radixSort([8, 10, 345, 25, 777, 1928, 1994]); 지수 정렬의 시간복잡도 지수 정렬에 대한 시간복잡도는 두 쟁점이 존재한다.하나는 지수정렬이 O(nk)라는 주장과, O(nlogn)이라는 주장이다. 아래 위키피디아에 들어가면 이에 대한 내용이 잘 정리되어 있다. 위키피디아_기수정렬","link":"/algorithm/udemy/15.%20Jisoo/"},{"title":"Udemy - 자료구조","text":"자료구조란? 나는 이전까지 데이터를 담는 도구로써 배열, 오브젝트만을 사용해 왔었다.하지만 배열과 오브젝트는 특정 상황에서 최고의 효율을 보이지 못하기에 다른 자료구조(Data Structure)가 필요하다. 다양한 자료구조의 종류 자료구조를 왜 배워야 하는가? 지도 어플리케이션을 만든다고 가정을 했을 때는 그래프 자료구조가, 양 끝의 데이터를 계속 추가 및 삭제해야하는 경우에는 연결 리스트 등이 가장 효율적이다. 따라서 우리는 앞으로 다양한 알고리즘들을 효율적으로 풀기 위해 여러 대표적인 자료구조들을 배워야 한다. 그렇다면 최고의 자료구조는 무엇일까? 최고의 자료구조란 없다. 따라서 우리는 다양한 대표적 자료구조들을 익히고, 상황에 알맞게 가장 효율적인 자료구조를 골라 사용해야 한다. Javascript에서의 객체지향 프로그래밍 (OOP) 앞으로 배울 자료구조들을 효율적으로 활용하기 위해선 ES6 문법도 잘 알아야 한다.그리고 이를 기반으로 자바스크립트에서 클래스를 통해 인스턴스를 뽑아내는 객체지향 프로그래밍 방식을 반드시 알아야 한다. OOP를 위한 기본지식 클래스 클래스란, 미리 정의한 프로퍼티와 메소드를 기반으로 객체를 만들기 위한 설계도라고 생각하면 된다. 객체 클래스의 인스턴스라고도 불리며, 클래스에 선언된 그대로 생성된 실체다. 인스턴스 클래스로부터 객체를 만드는 과정을 인스턴스화 라고 칭한다.그리고 특정 클래스로부터 생성된 객체를 해당 클래스의 인스턴스라고 한다. 조금 더 자세히 얘기하면, 클래스라는 설계도를 기반으로 구현된 구체적인 실체다. 이렇게 실체화 된 인스턴스는 메모리에 할당된다. 클래스 키워드 클래스의 선언과 기본 123456789101112class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe);// Me {name: &quot;hoonjoo&quot;, gender: &quot;male&quot;, location: &quot;seoul&quot;, constructor: Object} 위와 같이 Me라는 class를 통해 aboutMe라는 인스턴스를 반환 받을 수 있다. class는 하나의 공장 또는 설계도와 같아서 new OOO을 하면 해당 클래스 내에 존재하는 constructor에 의해 그에 알맞은 인스턴스가 반환된다. 인스턴스 메소드 위에서 constructor를 통해 특정 인스턴스의 구조를 만들었다면이제는 해당 구조를 컨트롤 할 수 있는 method에 대해 알아봐야 한다. 12345678910111213141516171819202122class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; this.eat = 0; } // introduce라는 메소드 introduce() { return `my name is ${this.name} and I live in ${this.location}`; } // 내가 먹은 끼니를 더해주고, 총 몇 끼를 먹었는지 반환해주는 메소드 food() { this.eat++; return `저는 오늘 ${this.eat}끼를 먹었습니다.`; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe.introduce()); // my name is hoonjoo and I live in seoulconsole.log(aboutMe.food()); // 저는 오늘 1끼를 먹었습니다. 클래스 메소드 (정적 메소드) 클래스 메소드는 클래스 전체에 대한 메소드를 정의할 수 있게 해준다.쉽게 설명하면 인스턴스가 직접 참조할 수는 없고 클래스 본체를 통해서만 호출할 수 있는 메소드다. 1234567891011121314151617181920class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; this.eat = 0; } // introduce라는 메소드 introduce() { return `my name is ${this.name} and I live in ${this.location}`; } static sayHi() { return '안녕하세요!'; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe.sayHi()); // 오류가 난다.console.log(Me.sayHi()); // 잘 호출된다.","link":"/algorithm/udemy/16.%20DataStructure/"},{"title":"Udemy - 배열과 오브젝트의 성능 평가","text":"💡 BigO(빅오)의 관점에서 자바스크립트의 배열과 객체는 어떻게 작동하는가? 객체 (Object) 객체란, 순서가 배정되지 않은 “키-값” 구조로 저장된 데이터 구조다. 12345let family = { Dad: 'Kim', Mom: 'Lee', Son: 'Kim.JR',}; 특징 순서가 없다는 특징 때문에 접근 및 삽입/제거가 빠르다. O(1) 객체 탐색의 경우는 O(N)으로, 이 또한 속도가 빠른 편이다. 배열 (Array) 순서가 존재하는 데이터 구조. 1const dogs = ['jake', 'ppoya', 'apple']; 시간 복잡도 배열의 첫 번째 인덱스에 삽입이나 제거 등의 동작이 일어날 때, 효율성에 문제가 생길 수 있다.( 그 뒤의 아이템들이 밀리거나 당겨지며 인덱스가 변하기 때문) 접근 : O(1) 끝부분 삽입 : O(1) 앞부분 삽입 : O(N) 앞부분 제거 : O(N) 이동 : O(N)","link":"/algorithm/udemy/2.%20Arr_Obj/"},{"title":"Udemy - 문제 해결 접근법","text":"정말 못 풀겠는 문제가 나왔을 때 우리는 어떻게 접근해야 하는가? 알고리즘이란?5%E1%86%B8%200f73cc9e30234d4b88395850f07235ab/Untitled.png) 특정한 기능이나 업무를 하기 위해 수행해야 하는 과정이나 단계들의 집합! 💡 알고리즘 실력을 늘릴 수 있는 방법 ? 💡 문제를 해결하기 위한 계획을 세운다. 일반적인 문제풀이 패턴을 마스터 한다. 🍪 문제 해결 전략 문제를 완벽히 이해한다. 구체적 예시를 꼼꼼히 탐색한다. 문제를 쪼갠다 문제를 풀고 → 단순화 한다 복기 &amp; 리팩토링 1️⃣ 문제를 완벽히 이해하기 해당 문제를 나만의 표현으로 바꿔서 설명할 수 있는가? 입력값은 무엇인가? 출력값은 무엇인가? 출력값을 얻는데 오로지 입력값만이 활용되는가? (정보의 충분성) 데이터에 어떤 이름을 붙여줘야 하는가? 예시 123456789// 두 인풋값을 받아 그 합을 출력하는 함수를 작성하시오function add(a, b) { // 1. 나만의 표현 : 입력값 두개의 합을 반환하는 함수를 제작한다. // 2. 입력값은 ? : a와 b 둘 다 정수 // 3. 출력값은 ? : 하나의 정수 (a와 b의 합) // 4. 정보의 충분성 : a와 b만 있으면 되므로 충분하다. // 5. 데이터 네이밍 : sum이 필요할 것 같다.} 2️⃣ 구체적 예시를 꼼꼼하게 탐색하기 문제를 이해하는데 큰 도움을 줄 수 있고 + 조금 더 뚜렷한 청사진을 그릴 수 있으며 + 더 다양한 추론을 이끌어낼 수 있다. 두 세가지 간단한 예시들을 그 입력값 &amp; 출력값과 함께 같이 적어 내려간다. 조금 더 복잡한 예시로 넘어간다. 유효하지 않은 입력값을 고려한다. (null, undefined, 유효하지 않은 타입 등등) ⇒ 즉, 다양한 변수들을 고려해야 한다. 3️⃣ 문제 단계별로 세분화 하기 주석을 활용해 문제를 풀 때 단계별로 필요한 로직과 코드를 차례대로 작성한다. 문제가 이해 됐어도 무작정 코드를 작성하지 않는다. 차례대로 가장 먼저 해야 할 것과 가장 나중에 해야 할 것을 정리하며문제 해결 과정을 차례대로 써 내려간다. 설령 시간이 부족해 코드를 반밖에 짜지 못했어도, 접근 방식 자체가 면접관에게 플러스 요인이 될 수 있다.Ex) “아 주석을 보니, 얘는 시간만 있으면 충분히 풀 수 있었겠구나” 4️⃣ 문제풀이 &amp; 단순화 단순화란 ?⇒ 풀 수 없는 것은 두고, 내가 풀 수 있는 것들만 먼저 해결하는 것 (부분점수 취하기 전략) 문제해결에 있어 가장 어려운 부분을 찾아낸다. 그 어려운 부분을 일단 무시한다. 간단한 솔루션들을 우선 도출한다. (풀 수 있는 단계들만 우선적으로 해결) 어려운 부분을 추후에 구현하여 통합한다. 5️⃣ 복기와 리팩토링 더 나은 개발자가 되기 위해선, 솔루션을 낸 후에도 코드를 복기 및 리팩토링 하는 습관을 들여야 한다.즉, 더 효율적인 코드가 될 수 있도록 자신의 코드를 더 발전시켜야 한다는 것이다. 체크리스트 다른 방식의 결과도 도출이 가능한가? 한 눈에 이해하기 쉬운가? 다른 문제에도 이 알고리즘과 솔루션을 적용할 수 있는가? 성능과 효율성을 더 개선할 여지가 존재하는가? 다른 사람들은 어떻게 풀었을까?","link":"/algorithm/udemy/3.%20Approach/"},{"title":"Udemy - 문제 해결 패턴","text":"일반적인 문제풀이 패턴에 대해서 정리해보았다. 1️⃣ 빈도수 세기 패턴 🎯 2중으로 중첩된 반복문 보다는, 단일 반복문 두 개를 사용하는 것이 훨씬 좋다. 빈도수 세기 알고리즘 패턴 (전체 코드) 12345678910111213141516171819202122function same(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } let frequencyCounter1 = {}; let frequencyCounter2 = {}; for (let val of arr1) { frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1; } for (let val of arr2) { frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1; } for (let key in frequencyCounter1) { if (!(key ** 2 in frequencyCounter2)) { return false; } if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) { return false; } } return true;} 패턴 분석 (단계별) 두 배열의 길이 비교 만약 두 배열의 길이가 다르다면? → 중복된 값이 있거나, 생략된 값이 있는 것을 의미한다. 1234// 두 배열의 길이가 같지 않다면, false를 반환하고 함수를 종료한다.if (arr1.length !== arr2.length) { return false;} 객체 생성 for문을 활용하여 대상객체와 도구객체 하나씩을 만든다. “그리고 위에서도 설명했듯, 중첩 반복문 보다는 단일 반복문 여러개가 더 낫다.” 123456789101112let frequencyCounter1 = {};let frequencyCounter2 = {};for (let val of arr1) { // 아래의 코드는 이러한 결과를 도출한다 =&gt; { val : (val or 0) + 1 } // 즉, 해당 값이 존재하면 그 값 +1을 해주고, 없으면 0+1을 해준다. frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;}for (let val of arr2) { frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;}// 이렇게 하면, 두 개의 도구대상 객체가 생성된다. 반복문 내에서 도구/대상 비교하기 객체에 대한 반복문에서는 반환값이 value가 아닌, key가 반환된다. 123456789101112for (let key in frequencyCounter1) { // {key:1} -&gt; {key^2:1}의 구조에서, // key^2의 값이 fC2의 키값에 존재하는지 체크하는 조건문 if (!(key ** 2 in frequencyCounter2)) { return false; } // {key^2 : n}에서 n값이 fC1의 {key: n}에서의 n값과 같은지 같지 않은지 체크 if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) { return false; }}// 이 모든 조건문을 통과하면 =&gt; true를 리턴한다. for ... in vs for ... of for ... in : 객체에서도 사용 가능하다. for ... of : 객체에서 사용 불가능하다 (문자열, 배열, Set 등등) ✏️ 예제 ( 애너그램 함수 ) 위의 빈도수 체크 알고리즘을 활용해 두 문자열을 비교하는 함수를 만들어보자. (소문자만 고려) 객체 만들기 1234567891011121314function validAnagram(a, b) { if (a.length !== b.length) { return false; } let aObj = {}; let bObj = {}; for (let val of a) { aObj[val] = (aObj[val] || 0) + 1; } for (let val of b) { bObj[val] = (bObj[val] || 0) + 1; } console.log(aObj, bObj);} 객체의 key와 value 일치여부 각각 체크하기 12345678for (let key in aObj) { if (!(key in bObj)) { return false; } if (aObj[key] !== bObj[key]) { return false; }} 💡 최종 솔루션 (1) 12345678910111213141516171819202122function validAnagram(a, b) { if (a.length !== b.length) { return false; } let aObj = {}; let bObj = {}; for (let val of a) { aObj[val] = (aObj[val] || 0) + 1; } for (let val of b) { bObj[val] = (bObj[val] || 0) + 1; } for (let key in aObj) { if (!(key in bObj)) { return false; } if (aObj[key] !== bObj[key]) { return false; } } return true;} 💡 이외의 솔루션 (2) 123456789101112131415161718192021222324function validAnagram(first, second) { if (first.length !== second.length) { return false; } const lookup = {}; for (let i = 0; i &lt; first.length; i++) { let letter = first[i]; lookup[letter] ? (lookup[letter] += 1) : (lookup[letter] = 1); } for (let i = 0; i &lt; second.length; i++) { let letter = second[i]; // 만약 a를 예로 들면, {a : 0}이어도, 객체에선 이를 존재하지 않는다고 계산한다. if (!lookup[letter]) { return false; } else { lookup[letter] -= 1; } // value가 0이면 false로 인식하기 때문에, 굳이 마지막에 모든 key의 value들이 0인지 더블체킹 할 필요는 없다. } return true;} 2️⃣ 다중 포인터 패턴 다중 포인터 패턴이란, 배열 또는 문자열 등의 index를 가리키는 포인터가 두 개 이상 활용되는 알고리즘 패턴을 의미한다. 🏋️ 서로의 합이 0이 되는 숫자 조합 찾기 내가 평소에 사용하던 중첩 for문 : O($n^2$)123456789function pointer(arr) { for (let i = 0; i &lt; arr.length; i++) { for (let j = i + 1; j &lt; arr.length; j++) { if (arr[i] + arr[j] === 0) { return [arr[i], arr[j]]; } } }} O(N) 버전12345678910111213141516171819// arr이 정렬되어 있음을 가정한다.// [-4,-3,-2,-1,0,1,2,3,10]function pointer2(arr) { let start = 0; let end = arr.length - 1; while (start &lt; end) { let sum = arr[start] + arr[end]; if (sum === 0) { return [arr[start], arr[right]]; } else if (sum &gt; 0) { // end가 상대적으로 더 크다는 뜻이고, 일단 start에 맞는 값이 있는지 없는지 체크해야 되기 때문에 end--를 한다. end--; } else { // sum &lt; 0이 되어버리면 이전 start에 맞는 end값이 존재하지 않는다는 뜻이다. // 따라서 start++ 해준다. start++; } }} 고유 숫자 세기 (Count Unique Nums) 시간 복잡도 O(N)1234567891011121314151617181920function countUniqueValues(arr) { // arr이 텅 빈 배열이라면 그냥 0을 반환 if (arr.length === 0) { return 0; } let first = 0; let second = first + 1; while (second &lt; arr.length) { // 두 값이 같으면 두번째 포인터를 한 칸 우측으로 이동 if (arr[first] === arr[second]) { second++; } else { // 두 값이 같지 않으면 ? =&gt; 두 포인터를 모두 한 칸 우측으로 옮기고, 두 번째 포인터가 가리켰던 값을 first의 다음 자리에 원래값과 치환시킨다. second++; first++; arr[first] = arr[second - 1]; } } return first + 1;} for문 활용 ( 더 간결한 코드 )1234567891011function countUniqueValues(arr) { if (arr.length === 0) return 0; let i = 0; for (let j = 1; j &lt; arr.length; j++) { if (arr[i] !== arr[j]) { i++; arr[i] = arr[j]; } } return i + 1;} 3️⃣ 기준점 이동 배열 패턴 ( Sliding Window ) 평소에 자주 접했던, 배열을 한 묶음씩 묶어서 체크하는 반복문을 활용한 알고리즘 패턴이다. 🤔 배열 내에서 N개로 묶은 묶음의 합 중 가장 큰 값을 구하시오 시간복잡도 : O($n^2$) 1234567891011121314151617181920function maxSubarraySum(arr, num) { if (num &gt; arr.length) { return null; } let max = -Infinity; for (let i = 0; i &lt; arr.length - num + 1; i++) { sum = 0; for (let j = 0; j &lt; num; j++) { // num 묶음의 서브 배열의 총합을 구한다. sum += arr[i + j]; } if (sum &gt; max) { // 만약 그 총합의 값이 max보다 크면, 해당 값을 max에 대입하여 갱신한다. max = sum; } } return max;}maxSubarraySum([2, 6, 9, 2, 1, 8, 5, 6, 3], 3); 시간복잡도 : O(n) → Sliding Window 1234567891011121314151617181920212223function maxSubarraySum(arr, num) { let maxSum = 0; // tempSum은 일시적 합을 의미한다. let tempSum = 0; // num의 값(묶음의 단위)이 배열의 길이보다 크다면 그냥 null을 반환한다. if (arr.length &lt; num) return null; // 우선 maxSum의 초기값을 첫 묶음의 총합으로 설정한다. for (let i = 0; i &lt; num; i++) { maxSum += arr[i]; } // 일시적 합인 tempSum의 초기값도 이와 일치시켜준다. tempSum = maxSum; for (let i = num; i &lt; arr.length; i++) { // 일시적 합 = 기존값 - 기존 묶음에서의 가장 첫번째 요소의 값 + 새로운 그 다음 값 tempSum = tempSum - arr[i - num] + arr[i]; // 두 수 중에 더 큰 값이 maxSum이 된다 maxSum = Math.max(maxSum, tempSum); } return maxSum;}maxSubarraySum([2, 6, 9, 2, 1, 8, 5, 6, 3], 3); 4️⃣ 분할 점령 ( Divide and Conquer ) 퀵 정렬과 합병 정렬 등에도 사용될 만큼, 활용도가 높은 알고리즘 패턴이다.이름 그대로, 데이터를 분할해서 → 점령(활용)한다.ex) 큰 배열을 더 작은 단위로 쪼개서 다음 단계로의 이동을 더욱 효율적으로 가져간다. 이진탐색(Binary Search)에서의 활용 : O($log_n$) 1234567// arr에 11이 포함되는지 찾기let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];// arr의 중간값 도출 -&gt; 중간값보다 찾는 값이 큰지 작은지 체크// 작으면 arr = 0~중간값;// 크면 arr = 중간값~arr.length-1// 이런 과정을 계속 반복하면서 효율적으로 원하는 값을 탐색한다.","link":"/algorithm/udemy/4.%20Solution_Pattern/"},{"title":"Udemy - 포인터 기본 예제","text":"1️⃣ 빈도수 체크 (같은 빈도수 찾기) 두 개의 정수의 자릿수들이 서로 빈도수가 일치하는지 체크 ! 12345678910111213141516171819202122function sameFrequency(a, b) { // 나 같은 경우엔 두 정수들을 toString해서 문자열로 바꾼 뒤 풀이했다. let aStr = a.toString(); let bStr = b.toString(); // 당연히 두 인풋의 길이가 다르면 각 빈도수도 절대 같을 수 없다. if (aStr.length !== bStr.length) { return false; } let checker = {}; // a의 각 자리수가 몇개씩 들어있는지 오브젝트로 만든다. for (let i = 0; i &lt; aStr.length; i++) { checker[aStr[i]] ? (checker[aStr[i]] += 1) : (checker[aStr[i]] = 1); } for (let i = 0; i &lt; bStr.length; i++) { if (!checker[bStr[i]]) { return false; } else { checker[bStr[i]]--; } } return true;} 2️⃣ 빈도수 체크 (다중 포인터 사용) 주어진 입력값들 중에 중복값이 있는지 체크하는 다중포인터 함수 짜기 나의 풀이12345678910function areThereDuplicates(...input) { let list = {}; input.map((item) =&gt; (list[item] ? (list[item] += 1) : (list[item] = 1))); for (let val in list) { if (list[val] &gt; 1) { return true; } } return false;} 다중포인터 풀이법1234567891011121314function areThereDuplicates(...args) { // 아.. sort를 사용해도 되는지 몰랐다 ㅜ (시간복잡도에 어떤 영향을 줄지 몰랐음) args.sort((a, b) =&gt; a &gt; b); let start = 0; let next = 1; while (next &lt; args.length) { if (args[start] === args[next]) { return true; } start++; next++; } return false;} O$$(nlog_n)$$ 풀이방법🤔 Set()이란?⇒ Set은 하나의 객체로, 자료형에 관계 없이 유일한 값만을 저장할 수 있다. 즉, Set()오브젝트에 담기게 되면 중복된 값이 제거된다.⇒ object.has(), object.size 등을 통해 특정 값의 포함 여부와 객체의 길이를 측정할 수 있다.1234function areThereDuplicates(...args) { // 중복이 제거된 배열 -&gt; 객체화 -&gt; 사이즈가 기존 배열의 길이와 다르면 중복값이 존재한다는 뜻이다. return new Set(args).size !== args.length;} 3️⃣ 다중 포인터 ( 평균값 묶음 찾기 ) 주어진 입력 정수 리스트 중에, 주어진 평균값이 도출될 수 있는 묶음이 있는지 여부를 반환하는 함수 작성! 나의 풀이123456789101112131415161718192021222324252627282930313233343536373839404142function averagePair(arr, target) { // 배열이 빈 배열이면 무조건 false if (arr.length === 0) { return false; } // 다중 포인터에서 앞 부분의 포인터는 start, 뒤의 포인터는 end로 선언했다. let start = 0; let end = start + 1; // i는 두 포인터 사이의 간격이다. let i = 0; // 아래에서 사용될 arr[start]~arr[end]까지의 합을 구하기 위한 함수다. const sumMaker = (input) =&gt; { return input.reduce((prev, cur) =&gt; prev + cur); }; // 두 포인터의 간격은 배열의 길이 -2까지만 허용된다. // 따라서, arr.length - 1보다 작을 때 까지만 반복문이 실행되어야 한다. while (i &lt; arr.length - 1) { // 만약 end 포인터가 배열의 끝에 닿으면 간격을 늘리고 다시 처음 묶음부터 체킹해야 된다. if (end &gt; arr.length - 1) { // 간격을 늘리고 i++; // 두 포인터의 위치 또한 초기화 시킨다. start = 0; end = start + i + 1; } // 배열을 두 포인터까지로 잘라낸다. let sliced = arr.slice(start, end + 1); // 합을 구하고, 이를 통해 평균을 구한다. let sum = sumMaker(sliced); let avg = sum / sliced.length; // 만약 구한 평균값과 target값이 같으면 true를 반환한다. if (avg === target) { return true; } else { // 그게 아니라면, 두 포인터를 한칸씩 이동시킨다. start++; end++; } } // 반복문을 마쳤는데도 true가 안나왔으면 false인거다. return false;} 4️⃣ 다중 포인터 ( 부분 문자열 찾기 ) 첫 째 입력값(String)의 character들이 두 번째 입력값(String)에 모두 포함되는지 체크하는 함수를 작성단, 첫 째 입력값의 순서가 뒤바뀌어서는 안된다. 나의 솔루션 코드 ( 애 좀 먹었다… )123456789101112131415161718192021222324252627282930313233343536373839function isSubsequence(a, b) { // a 문자열의 길이가 더 길면 정답일 수가 없다. if (a.length &gt; b.length) { return false; } // 추출 결과가 담길 test 배열을 만든다. let test = []; // a,b 두 문자열을 모두 배열에 담는다. let aArr = [...a]; let bArr = [...b]; // 포인터 두 개 만들기 let i = 0; let j = 0; while (i &lt; aArr.length) { // i는 a를, j는 b를 순회하며 체크한다. // 만약 두 배열의 요소 값이 같아지는 경우가 발생하면 해당 값의 첫 번쨰 index값을 test에 담는다. if (bArr[j] === aArr[i]) { test.push(bArr.indexOf(bArr[j])); // a는 이제 다음 요소를 체크해도 되므로 i++해준다. // j는 다시 0으로 초기화 시킨다. i++; j = 0; } else { // 같지 않으면 j++ 시키며 계속 순회하도록 한다. j++; } // 하지만 j가 끝에 닿으면 0으로 초기화 시키고, i또한 다음으로 넘긴다. if (j === bArr.length) { j = 0; i++; } // 이미 요소들이 다 담겼는데 끝까지 반복문을 돌릴 필요는 없다. if (test.length === aArr.length) { break; } } // 만약 test에 담긴 각 요소들의 index값이 오름차순이 아니면 이는 false를 출력할 것이다. return test.reduce((prev, cur) =&gt; prev &lt; cur);} 반복문 풀이법 (현타… 온다…)1234567891011function isSubsequence(str1, str2) { var i = 0; var j = 0; if (!str1) return true; while (j &lt; str2.length) { if (str2[j] === str1[i]) i++; if (i === str1.length) return true; j++; } return false;} O(1) 풀이법 (하….) 재귀함수를 사용했는데, 굉장히 획기적인 풀이 방법인 것 같다. 123456function isSubsequence(str1, str2) { if (str1.length === 0) return true; if (str2.length === 0) return false; if (str2[0] === str1[0]) return isSubsequence(str1.slice(1), str2.slice(1)); return isSubsequence(str1, str2.slice(1));} 5️⃣ Sliding Window ( 최대값 찾기 ) 주어진 숫자의 묶음 중에서 최대값을 찾는 알고리즘을 작성단, 묶음은 연속된 요소로만 구성된다. 나의 솔루션 코드 : O(N)1234567891011121314151617181920function maxSubarraySum(arr, num) { if (arr.length &lt; num) { return null; } // 일시적 합을 담을 temp, 최대값을 담을 max let temp = 0; let max = 0; // 우선 0~num까지의 합을 temp와 max에 담아줌 for (let i = 0; i &lt; num; i++) { temp += arr[i]; } max = temp; // temp에서 이전 첫째값을 빼고, 그 다음 값을 더해주고 max와 비교 // 더 큰 값이 max에 담긴다. for (let i = num; i &lt; arr.length; i++) { temp = temp - arr[i - num] + arr[i]; max = Math.max(temp, max); } return max;} 6️⃣ Sliding Window ( 최소 길이 찾기 ) 각 요소의 값의 합이 num이 되는 조합 중, 가장 짧은 길이를 갖는 조합의 length를 출력하는 알고리즘 작성 나의 솔루션 코드 : O(N)12345678910111213141516171819202122function minSubArrayLen(arr, num) { let sum = 0; let start = 0; let end = 0; let minLen = Infinity; while (start &lt; arr.length) { if (sum &lt; num &amp;&amp; end &lt; arr.length) { sum += arr[end]; end++; } else if (sum &gt;= num) { minLen = start === 0 ? Math.min(minLen, end - start + 1) : Math.min(minLen, end - start); sum -= arr[start]; start++; } else { break; } } return minLen === Infinity ? 0 : minLen;} 7️⃣ Sliding Window ( 가장 긴 독립 문자열 찾기 ) 주어진 문자열에서 중복되지 않는 Character가 어디까지 이어지는지 그 길이를 출력하는 알고리즘을 작성 나의 솔루션 코드1234567891011121314151617181920212223242526272829function findLongestSubstring(input) { if (input.length === 0) { return 0; } // 초기 최대값 가장 작은 값으로 설정 let max = -Infinity; // 독립적 문자들을 담을 checker 객체를 생성 let checker = {}; let i = 0; let j = i; while (i &lt; input.length) { // j포인터가 끝에 닿았거나, 해당 글자가 checker 오브젝트에 존재한다면? if (j === input.length || checker[input[j]]) { // max값 갱신 max = Math.max(max, j - i); // checker는 다시 초기화 checker = {}; // i++ -&gt; 가장 처음값 담음 i++; checker[input[i]] = 1; // j는 i의 다음값부터 체크하면 되므로 i+1로 초기화 j = i + 1; } else { checker[input[j]] = 1; j++; } } return max;}","link":"/algorithm/udemy/5.%20Questions/"},{"title":"Udemy - 재귀","text":"백준 알고리즘을 풀 때도 가장 어렵게 느껴졌고, 잘 와닿지 않았던 알고리즘 유형이다.재귀란 말 그대로, 다시 돌아온다는 뜻이다.쉽게 말해, 함수가 사전에 정의된 엔드포인트에 도달할 때 까지 계속 재실행되며 반복되는 것이다. 🤔 재귀함수를 사용하는 이유 정말 많이 활용되는 알고리즘 패턴이다. ex) JSON.parse, JSON.stringify, getElementById 등등 트리나 그래프 형태의 복잡한 데이터 구조를 탐색하거나 순회해야 할 때 필요하다 📦 콜스택 (Call Stack) 콜스택은 LIFO(Last In, First Out) 방식을 따르며, 콜스택에 함수가 차례대로 쌓인다.가장 위에 있는 함수부터 return값이 반환되며 종료될 때마다 스택(함수)이 지워진다. 즉, 재귀함수에서는 같은 함수가 endpoint에 닿을 때 까지 콜스택에 지속적으로 쌓인다. 일반적으로 발생하는 재귀에서의 문제들 엔드포인트가 명시되지 않은 경우 ⇒ 콜 스택이 오버플로우 되며 오류를 발생시킨다. 실수로 재귀 함수의 입력값을 고정시킬 경우에도 위와 같은 문제점이 발생할 수 있다. 즉, 재귀함수를 활용할 때는 스택 오버플로우를 반드시 방지해야 한다. 헬퍼 메소드 재귀 함수 안에 또 다른 재귀함수가 존재하는 경우를 통칭한다. 12345678910111213141516171819function collectOddValues(arr) { let result = []; // 이와 같은 헬퍼 재귀함수가 내장되어 있다. function helper(helperInput) { // 앞부분이 계속 slice되다 보면 input의 길이가 0인 지점에 다다른다. if (helperInput.length === 0) { return; } if (helperInput[0] % 2 !== 0) { result.push(helperInput[0]); } // 계속 배열의 앞 부분을 잘라 나가며 함수를 재귀 호출 한다. helper(helperInput.slice(1)); } helper(arr); return result;}collectOddValues([1, 2, 3, 4, 5, 6, 7, 8, 9]); 일반 재귀 헬퍼 메소드 함수를 사용하지 않은, 순수한 단독 재귀함수다. 🍯 꿀팁 배열 사용 시 : slice와 spread operator 활용을 고려 문자열 사용 시 : slice, substr, substring 등을 활용 객체 사용 시 : Object.assign 또는 spread operator 활용 1234567891011121314151617function collectOddValues(arr) { let newArr = []; // 배열의 길이가 0에 다다르면 newArr 반환하며 함수 종료 if (arr.length === 0) { return newArr; } // 만약 배열 맨 앞의 요소가 홀수라면 ? -&gt; newArr에 push if (arr[0] % 2 !== 0) { newArr.push(arr[0]); } // 앞에서 정의된 newArr와 맨 앞이 잘린 arr을 합친다. // newArr = [...newArr, ...collectOddValues(arr.slice(1))] newArr = newArr.concat(collectOddValues(arr.slice(1))); return newArr;}collectOddValues([1, 2, 3, 4, 5]);","link":"/algorithm/udemy/6.%20Recursion/"},{"title":"Udemy - 재귀 예제","text":"1️⃣ Power 첫번째 인풋의 두번째 인풋 제곱값을 구하는 재귀함수 알고리즘을 작성 🙂 12345678function power(a, b) { // b가 1보다 작으면 1을 반환하는 endpoint를 설정 if (b &lt; 1) { return 1; } // 아래와 같은 재귀 함수가 반복되며 b가 0에 닿을 때 까지 a*(b-1)이 쌓인다. return a * power(a, b - 1);} 2️⃣ 팩토리얼 말 그대로 팩토리얼(내림차순 곱)을 구현하는 재귀함수 알고리즘을 작성하면 된다. 12345678function factorial(num) { // endpoint가 0이면 안되는 이유는, n*0 = 항상 0이 되기 때문이다. if (num &lt; 1) { return 1; } // 재귀함수 호출 return num * factorial(num - 1);} 3️⃣ 배열의 모든 수 곱하기 주어진 배열의 모든 요소들을 곱한 값을 반환하는 재귀함수 알고리즘을 작성하시오 12345678function productOfArray(arr) { // arr의 길이는 매 재귀호출마다 slice에 의해 1씩 줄어든다. // 따라서 arr의 길이가 0에 닿았을 때 곱셈에 영향을 주지 않는 1을 return한다. (그냥 return만 해도 됨) if (arr.length &lt; 1) { return 1; } return arr[0] * productOfArray(arr.slice(1));} 4️⃣ 1씩 증가하는 등차수열의 합 0~N까지의 합을 계산하여 반환하는 재귀함수 알고리즘을 작성하시오 123456789function recursiveRange(num) { // 이 문제는 합을 구하는 문제이기 때문에, 덧셈에 영향을 주지 않는 0을 return하는 것이 안전하다. if (num &lt; 1) { return 0; } // 꼭 증가하는 등차수열이라고 해서 값을 더해 나갈 필요는 없다. // N~0까지의 합을 구해도 됨 return num + recursiveRange(num - 1);} 5️⃣ 피보나치 수열의 index 찾기 입력 받은 숫자가 피보나치 수열 내에서 몇번 째의 숫자인지 반환하는 재귀함수 알고리즘을 작성하시오 123456function fib(num) { if (num &lt;= 2) { return 1; } return fib(num - 1) + fib(num - 2);}","link":"/algorithm/udemy/7.%20Recursion_Q/"},{"title":"Udemy - 탐색 알고리즘","text":"탐색(검색) 알고리즘이란?쉽게 설명하자면, 특정한 배열, 또는 객체 등에 존재하는 특정값을 찾아내는 알고리즘이다. 탐색 알고리즘의 종류 선형 탐색 이진 탐색 순수 탐색 KMP String 탐색 📏 선형 탐색 (Linear Search) 배열 내에 존재하는 값들을 하나씩 체크하며 검색해 나가는 방식의 탐색 알고리즘이다. Array.indexOf() 시간복잡도는 O(N)으로, 반복문 안에서 사용에 주의해야 한다. 해당 값이 존재하면 해당 값의 가장 선두에 있는 index값을 반환해준다. 해당 값이 존재하지 않으면 -1을 반환한다. Array.includes() 시간복잡도 : O(N) 특정 값이 존재하면 true를, 존재하지 않으면 False를 반환 Set.has() 시간복잡도 : O(1) Array.includes()와 비슷하지만, 이는 배열이 아닌 set에서 사용하는 함수다. const OOO = new Set() 을 통해 Set을 생성할 수 있고, set에는 중복값을 담을 수 없다. 기본 예제 주어진 숫자의 index값을 찾는 탐색 알고리즘을 작성하시오 : O(N) 12345678function linearSearch(arr, target) { for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === target) { return i; } } return -1;} 선형 탐색의 BIG O O(1) : 베스트 👍 O(N) : 평균 or 워스트 👎⇒ 배열의 길이가 1만개라면, 1만번의 탐색을 수행해야 함, 하지만 일반적인 경우에는 그리 최악은 아님 📖 이진 탐색 (Binary Search) 선형 탐색보다 훨~~씬 빠른 탐색 알고리즘이다.이전에 잠깐 맛만 봤던 “분할 점령 패턴”의 실질적인 활용 예라고 보면 된다. ⚠️ 배열이 정렬되어 있는 경우에만 사용 가능하다.. 기본 로직 배열을 절반으로 쪼갠다⇒ 진짜 배열을 slice하는건 아니고, 이중 포인터를 사용한다 중간값을 기준으로 좌측을 잘라낼지, 우측을 잘라낼지 결정하도록 한다. 기본 예제 코드 이진 탐색 방식으로 주어진 숫자의 index값을 반환하는 알고리즘을 작성하시오. 12345678910111213function binarySearch(arr, target) { // left와 right 포인터를 선언 let left = 0; let right = arr.length - 1; // 초기 값에 대한 중간값(middle) 선언 let middle = Math.floor((left + right) / 2); // 중간값이 target과 같아지거나, left가 right보다 커지면 반복문 종료 while (arr[middle] !== target &amp;&amp; left &lt;= right) { target &lt; arr[middle] ? (right = middle - 1) : (left = middle + 1); middle = Math.floor((left + right) / 2); } return arr[middle] === target ? middle : -1;} 이진 탐색의 BIG O O(1) : 베스트 👍 O(logn) : 기본 ☺️ 🍼 순수 탐색 (Naive String Search) 어떤 String에 특정한 subString이 포함되는지 탐색하는 알고리즘ex) “my name is hoonjoo”에 “hoon”이 포함되는가? 💡 원래는 String.includes() 를 사용하면 되지만, 순수 탐색 방법을 활용하면 첫 글자를 비교 → 같으면 두 번쨰 글자를 비교 / 다르면 비교대상의 첫 글자 인덱스를 우측으로 이동 기본 예제 코드 주어진 target String이 기준 String에서 몇 번 나타나는지 반환하는 순수 탐색 알고리즘 코드를 작성하시오. 12345678910function naiveSearch(base, target){ let count = 0; for(let i = 0; i &lt; base.length; i++){ for(let j = 0; j &lt; target.length; j++){ target[j] !== base[i+j] &amp;&amp; break; j === target.length - 1 &amp;&amp; count++; } } return count;}","link":"/algorithm/udemy/9.%20Search/"},{"title":"2. 네트워크의 구성","text":"네트워크를 구성하는 기기 네트워크 연결을 위해서는 기기와 기기 간의 연결이 필요하다.이러한 연결을 돕는 데에 가장 주요한 세 개의 기기가 존재한다. 라우터 레이어2 스위치 레이어3 스위치 데이터 전송처리 절차 네트워크 기기는 물리적 신호를 전달 받아 디지털 신호(0,1)로 변환하여 다른 기기로 다시 전송해준다. 데이터 수신 ⇒ 물리적 신호로 변환된 데이터를 받아서 디지털 신호로 변환한다. 데이터를 보낼 곳 결정 ⇒ 데이터에는 부가적인 제어 정보도 함께 담겨서 온다. 이를 활용해 네트워크 기기는 데이터 전송 대상을 설정한다. 데이터 전송 ⇒ 다시 디지털 신호(0,1)을 물리적 신호로 변환하여 송신 대상에게 데이터를 전송한다. 네트워크의 구체적 구성 네트워크 연결을 위해 우리는 일반적으로 인터페이스(포트)를 통해 각 기기를 연결한다. 이더넷 포트 ? LAN 포트? ⇒ 모두 이더넷 인터페이스를 통칭하는 말이다. 이더넷 인터페이스란, 현재 가장 널리 통용되는 인터페이스다. 💡 우리는 이 인터페이스를 통해 물리적 신호와 디지털 신호 등이 전송될 수 있도록 현관문의 역할을 해준다. LAN을 구축하는 방법 LAN은 근거리 네트워크를 의미한다.그렇다면 기기와 기기를 연결해서 어떻게 인터넷 네트워크를 구현한다는 것일까? LAN에도 당연히 라우터, 레이어2 스위치와 같은 네트워크 기기가 필요하다. ⇒ 그리고 PC 또는 노트북에 네트워크 연결을 위한 인터페이스가 존재해야 한다. 사용자 PC의 인터페이스(포트)에 LAN선을 연결하고, 이 선을 또 네트워크 기기의 인터페이스에 연결해준다. 그러면 이제 네트워크 기기를 통해 데이터를 주고 받을 수 있다.","link":"/cs/network/Network_Composition/"},{"title":"Udemy - 재귀 심화문제","text":"허허….😅 1️⃣ reverse ( 거꾸로 출력하기 ) 입력된 String을 거꾸로 출력하는 재귀함수 알고리즘을 작성! 123456789function reverse(input) { // 1. Endpoint 조건 작성 // input의 length가 1에 닿으면 -&gt; 그 하나 남은 값을 출력하면 된다. if (input.length &lt; 2) { return input[input.length - 1]; } // 2. input의 가장 끝 값을 잘라나가면서 String에 붙여준다. return input[input.length - 1] + reverse(input.slice(0, -1));} 2️⃣ isPalindrome ( 앞뒤가 똑같은 단어 찾기 ) 주어진 String 입력값이 앞뒤로 반전을 해도 같은 단어라면 true를, 아니라면 false를 출력하는 재귀 함수 작성 1234567891011121314function isPalindrome(input) { // 1. Endpoint 작성 // 1-1. input.length가 짝수인 경우 마지막 단계에서 두 개의 char가 남는다. if (input.length === 2) { return input[0] === input[1]; // 하지만, 홀수인 경우 마지막에 하나의 char만 남으므로, 이는 뒤집어도 가운데에 위치하기에 true를 반환해주면 된다. } else if (input.length === 1) { return true; } // 2. 재귀함수 실행 (&amp;&amp;을 사용하면 하나라도 false일 시에, false가 반환됨) return ( input[0] === input[input.length - 1] &amp;&amp; isPalindrome(input.slice(1, -1)) );} 3️⃣ someRecursive ( 하나라도 만족하는가? ) 주어진 배열 입력값 중에, 주어진 조건을 하나라도 충족하면 true를, 아니면 false를 출력하는 재귀함수 알고리즘을 작성하시오 123456789101112function someRecursive(arr, callback) { // 만약 arr.length가 0이 될 때까지 true가 반환되지 않았다면, false를 반환해주면 된다. if (arr.length === 0) { return false; } // callback(arr[0])의 값이 true면 true를 반환한다. if (callback(arr[0])) { return true; } // 위 두 조건을 모두 만족시키지 못한다면 배열을 잘라나가며 재귀함수를 실행시킨다. return someRecursive(arr.slice(1), callback);} 4️⃣ flatten ( 중첩 배열 풀어내기 ) [ [ ], [ [ ] ]] 와 같은 중첩 배열들을 하나의 배열로 풀어서 반환하는 재귀함수 알고리즘을 작성하시오 나의 솔루션1234567891011// 뭐가 문제인지는 모르겠으나... 나의 솔루션은 계속 알 수 없는 오류가 난다.function flatten(arr) { // 새로운 배열을 반환해야 한다고 했으니 일단 newArr에 담아준다. let newArr = arr; // 만약 모든 요소 중 어떤 것도 배열이 아니라면? =&gt; 해당 newArr 반환 if (!newArr.some((el) =&gt; Array.isArray(el))) { return newArr; } // 위의 조건 통과하지 못하면 -&gt; newArr를 flat해서 다시 재귀 return flatten(newArr.flat());} 제시된 솔루션12345678910111213function flatten(oldArr) { let newArr = []; for (let i = 0; i &lt; oldArr.length; i++) { if (Array.isArray(oldArr[i])) { // 여기서는 concat을 사용했다. // concat 안에서 재귀가 이뤄진다. newArr = newArr.concat(flatten(oldArr[i])); } else { newArr.push(oldArr[i]); } } return newArr;} 5️⃣ capitalizeFirst ( 첫 글자 대문자로 바꾸기 ) 주어진 배열 내의 String들의 첫 글자를 대문자로 바꾸는 재귀함수 알고리즘을 작성하시오 아스키 코드 (10진수) A-Z : 65~90 a-z : 97~122 123456789101112function capitalizeFirst(arr) { // 만약 arr.length가 1에 닿으면 -&gt; 첫 글자 대문자로 치환 + 나머지 글자 합친 것 return if (arr.length === 1) { return [arr[0][0].toUpperCase() + arr[0].slice(1)]; } // 위 조건 충족하지 못하면 // 첫 글자 대문자로 치환 + 뒷 글자들 붙임, 뒤의 나머지 배열 요소들 또한 재귀를 통해 첫글자 대문자화 return [ arr[0][0].toUpperCase() + arr[0].slice(1), ...capitalizeFirst(arr.slice(1)), ];} 6️⃣ nestedEvenSum nested 오브젝트 내에 존재하는 모든 짝수 value들의 합을 구하는 재귀함수 알고리즘을 작성하시오 주어진 object 1과 2 12345678910111213141516// typeOf Object를 활용하면 될 것 같다.function nestedEvenSum(obj, sum = 0) { // for ... in 반복문을 통해 오브젝트의 key값들을 활용 for (let key in obj) { // key = 오브젝트의 key // 만약 key의 value의 타입이 object라면 재귀 대상 if (typeof obj[key] === 'object') { // 이렇게 해당 오브젝트가 함수에의해 다시 들어가면 for문에 의해 계속 벗겨질 것 sum += nestedEvenSum(obj[key]); // 만약 해당 key의 value가 숫자이고, 짝수라면? -&gt; sum에 그 값을 더해주기 } else if (typeof obj[key] === 'number' &amp;&amp; obj[key] % 2 === 0) { sum += obj[key]; } } return sum;} 7️⃣ capitalizeWords (모든 문자 대문자화) 배열에 담긴 모든 문자열들을 대문자로 치환하는 재귀함수 알고리즘을 작성하시오 123456function capitalizeWords(arr) { if (arr.length === 1) { return [arr[0].toUpperCase()]; } return [arr[0].toUpperCase(), ...capitalizeWords(arr.slice(1))];} 8️⃣ stringifyNumbers nestedObject의 values들 중에 ‘숫자’인 값들을 찾아서 모두 stringify하여 반환하는 재귀함수 알고리즘을 작성하시오 💡 Array를 typeof를 통해 검사하면 ‘object’가 반환된다는 것을 처음 알았다…. 123456789101112131415161718// 처음엔 그냥 기존 obj를 수정하는 방식으로 했는데, TDD에서 원본 오브젝트는 건들지 말란다...// 그래서 newObj={}라는 입력값을 추가했음function stringifyNumbers(obj, newObj = {}) { // obj에 대한 for문을 돌린다. for (let key in obj) { // 만약 해당 value가 오브젝트이고, 배열이 아니라면 -&gt; 재귀 대상 if (typeof obj[key] === 'object' &amp;&amp; !Array.isArray(obj[key])) { // newObj의 해당 key값의 value는 수정된 object가 된다. newObj[key] = stringifyNumbers(obj[key]); } else if (typeof obj[key] === 'number') { newObj[key] = obj[key].toString(); } else { // 여기는 value가 오브젝트도 아니고, 숫자도 아닐 경우 -&gt; 그냥 그대로 newObj에 넣음 newObj[key] = obj[key]; } } return newObj;} 9️⃣ collectStrings ( String만 모으기 ) 주어진 nestedObject 안에서 String Value값들만을 한 배열에 모아서 반환하는재귀함수 알고리즘을 작성하시오 1234567891011121314// 최종 리턴할 배열을 arr=[]와 같이 입력해줬다.function collectStrings(object, arr = []) { for (let key in object) { // object면? -&gt; 스프레드 연산하여 arr에 담아준다 // 재귀가 되며 지속적으로 object 속을 탐색한다. if (typeof object[key] === 'object') { arr.push(...collectStrings(object[key])); // value가 string인 것이 발견되면 arr에 푸시한다 } else if (typeof object[key] === 'string') { arr.push(object[key]); } } return arr;}","link":"/algorithm/udemy/8.%20Recursion_HQ/"},{"title":"3. TCP&#x2F;IP","text":"TCP/IP란? 네트워크 아키텍처란, 하나의 언어이자 약속의 집합이다. 이러한 언어 중에서도 통용되는 언어가 있는데 그게 바로 TCP/IP다. TCP/IP의 계층구조 (OSI 4계층) 네트워크 아키텍처는 프로토콜들(규약)의 집합이다. 효율적 통신을 위해 이러한 프로토콜들을 계층화 하는데, 가장 널리 쓰이는 계층화 구조는 4계층 구조이다. (물론 OSI 7계층도 존재한다) 네트워크 인터페이스층 ⇒ 같은 네트워크 안에서의 데이터를 전송하는 역할 인터넷층 ⇒ 서로 다른 네트워크 간에 데이터를 전송하는 역할 (중개자) 트랜스포트층 ⇒ TCP or UDP를 통한 데이터의 배분 (to 특정한 복수의 애플리케이션) 애플리케이션층 ⇒ 애플리케이션의 기능을 실행하기 위해, 그에 맞는 데이터의 형식과 처리 방법 등을 결정하는 역할(HTTP, SMTP, POP3, DHCP, DNS 등의 프로토콜이 존재) 데이터의 송수신 규칙 (feat. 헤더) 위에서 설명했듯이, 프로토콜들은 계층화 되어 있다.따라서 애플리케이션이 정상적으로 데이터를 주고받기 위해선 이러한 프로토콜들을 조합해야 한다. 캡슐화와 역캡슐화 헤더에는 데이터의 출발지 주소, 그리고 목적지 주소가 담긴다. 그리고 이러한 헤더는 다음 프로토콜에 송신되어, 또 다시 새로운 헤더로 포장된다. 즉, 계층별 출발지와 목적지 정보가 차근차근 입력되며 쌓이는 것이다. 클라이언트(브라우저)에서 서버로 데이터를 전송하는 과정 위의 그림과 같이 브라우저~이더넷을 거치며 각 헤더들이 캡슐화되어 쌓인다.그리고 마지막으로 이더넷에서 물리적 신호로 변환하여 전송 매체로 데이터를 보낸다. 데이터를 수신하는 입장인 서버는 이러한 헤더를 받아 이더넷에서 쌓인 FCS와 이더넷 헤더를 읽고 자신한테 전달된 데이터가 맞는지 확인한다. 이후 역순으로 IP - TCP - HTTP 헤더들을 차례대로 벗겨내며 읽어나간다. 데이터별 명칭 HTTP(애플리케이션층) : HTTP메시지 TCP(트랜스포트층) : TCP 세그먼트 IP(인터넷층) : IP 패킷 이더넷(네트워크 인터페이스층) : 이더넷 프레임 IP (Internet Protocol) IP의 역할은 ‘엔드투엔드 통신’을 하는 것이다.즉, 특정 PC에서 다른 PC로 데이터를 전송하는 것이다. 보내고자 하는 데이터를 IP 패킷으로 포장한다. IP헤더에는 출발지 IP주소와 목적지 IP주소가 담긴다. 이를 참조하여 데이터는 다른 목적지 IP를 가진 컴퓨터로 전송되는 것이다. 하지만 만약 해당 목적지 주소가 다른 네트워크에 존재한다면, 라우터를 통해 다른 네트워크로 데이터가 전송된다. 이를 라우팅이라 한다. IP는 어떻게 구성될까 도트형으로 10진 표기된다. (ex. 192.168.0.1) 위에서는 컴퓨터(호스트) 자체의 주소를 IP라고 설명했다. 하지만 사실 IP는 호스트의 인터페이스를 식별하는 것이다. 따라서, 한 호스트가 여러 인터페이스를 보유하고 있을 경우 (유선 인터페이스, 무선LAN 인터페이스 등등) 인터페이스마다 IP주소를 설정할 수 있다. IP의 목적지 유니캐스트, 브로드캐스트, 멀티캐스트 유니캐스트 : 단 하나의 주소로 데이터를 전송 할 때(가장 일반적) 브로드캐스트 : 같은 네트워크 안에 있는 모든 호스트에게 똑같은 데이터를 전송할 때 멀티캐스트 : 특정 그룹을 지정하여 똑같은 데이터를 전송할 때 IP주소의 구성 IP주소는 네트워크부 + 호스트부로 구성된다. (고정되지 않고 가변적임) 네트워크부는 말 그대로 네트워크 자체를 식별한다 (이 네트워크로 보내줘!)⇒ 서브넷 마스크를 통해 IP주소 안에서 어디까지가 네트워크부인지 식별할 수 있다. 호스트부는 네트워크 안에서의 호스트를 식별한다. (이 호스트에게 보내줘!) 네트워크 접속 네트워크 접속에는 두 단계가 존재한다.물리적 접속 → 논리적 접속 물리적 접속 네트워크 인터페이스 층에서 이루어지며, 말 그대로 물리적인 신호를 주고받을 수 있도록 하는 것이다. 예를 들어 LAN선을 기기에 연결시키거나, 와이파이 연결을 위해 무선LAN 엑세스 포인트에 접속하는 것이다. 논리적 접속 위에서 설명했던 것 처럼, 네트워크 연결을 위해서는 인터페이스에 IP주소가 반드시 필요하다. 이러한 IP를 설정하는 것이 논리적 접속의 단계다. 물론 IP주소를 직접 설정하는 것은 전문가가 아니라면 어렵기 때문에 DHCP라는 기술을 통해 자동으로 IP주소를 설정할 수 있다. IP의 역할과 활동 공인 IP주소 : 인터넷에서 사용!사설 IP주소 : 특정 네트워크 안에서만 사용! (다른 네트워크에서의 사설 IP와 중복 가능) 그럼 사설 IP주소로 인터넷에 접속하면 어떻게 될까? 우선.. 전송 자체는 상관 없는데… 결국 IP패킷이 폐기되어 아무 것도 전달되지 않는다.따라서 NAT을 통해 사설 IP를 공인 IP로 변환하여 인터넷과 통신해야 한다. 근데 그러면… IP에 담긴 데이터가 잘 전달 됐는지 어떻게 확인할까? **ICMP(Internet Control Message Protocol)**를 사용하면 된다. ICMP의 주요기능 에러 리포트 : 우선, ICMP를 통해 IP패킷이 폐기되면 도달불능 메시지가 메아리 처럼 다시 출발지로 전달된다.진단기능(Ping) : ping커맨드를 통해 지정한 IP주소와 통신할 수 있는지 확인할 수 있다. MAC주소로의 변환 : ARP 위에서는 IP를 통해 네트워크 간 데이터를 전송한다고 했었다.근데… 갑자기 MAC주소로 데이터가 전송된다고 하니 참 헷갈린다… IP주소는 결국 MAC주소를 포함한다고 볼 수 있다. IP주소가 MAC주소 (컴퓨터의 물리적 주소)로 변환되어 해당 목적지까지 전달될 수 있는 것이다. 따라서 IP통신 내부에 MAC주소 통신이 포함되어 있는 것이고, 쉽게 말하면 IP통신은 MAC통신의 연속적 과정의 합이라고 볼 수 있다. IP주소가 MAC주소로 변환되는 것 : ARP ARP는 쉽게 말하면 번역가다.ARP를 통해 우리는 목적지 IP에 대응하는 목적지 MAC주소를 얻어내고(주소 해석), 이를 ARP 캐시에 저장한다. 알맞은 목적지 기기에 데이터가 도달했다면 ? 포트번호(PORT)를 통해 애플리케이션을 식별하고 → 알맞은 애플리케이션으로 데이터를 전송한다.포트번호는 TCP 또는 UDP 헤더에 저장된다. TCP와 UDP TCP : 신뢰성이 보장된 애플리케이션 간의 데이터 송수신을 위한 프로토콜(수신확인 가능)UDP : 서버에 도착한 데이터를 애플리케이션에 “배분”만 해주는 프로토콜 TCP의 작동 프로세스 -우선, 애플리케이션 간에 신뢰성 보장을 위해 TCP커넥션을 맺는다. -그리고 데이터를 서로 주고받은 뒤 (TCP헤더와 애플리케이션 데이터 헤더가 추가됨) ACK(수신확인)를 한다. (시퀀스번호를 통해 전송하는 데이터의 순서를 담기도 한다) -마지막으로 TCP커넥션을 끊는다. UDP UDP는 위에서도 설명했듯이, 데이터의 배분만을 담당한다. 따라서 데이터가 올바르게 도착했는지에 대한 확인이나, 데이터의 분할 등의 기능은 하지 못한다. 주로 IP음성통화 등에 활용되고. 여분처리 과정이 없기 때문에 데이터 전송 효율이 상대적으로 좋다는 장점도 있다. DNS 근데 생각해보니 IP도 알겠고, MAC도 알겠는데….우리는 어떻게 상대방의 IP를 알아서 이를 MAC주소로 변환시키고 네트워크 통신을 하는걸까? 사실 우리는 호스트명만 알고 있을 뿐, IP주소는 DNS에 담겨있다. 우리가 www.naver.com(호스트명)을 입력하면 자동으로 네트워크의 전화번호부라고 할 수 있는 DNS서버에 IP주소 질의를 한다 (DNS 리졸버). 그러면 DNS에서 해당 호스트명에 대응하는 IP주소를 반환해준다(이름해석). 그러면 이를 통해 우리는 해당 IP주소를 통해 네트워크 통신을 하는 것이다. 그렇다면 나의 IP주소는 어떻게 설정되는걸까…? 위에서 잠깐 언급했던 DHCP를 통해 자동으로 우리의 IP가 설정된다. 우선 우리의 컴퓨터는 대개 DHCP클라이언트로 설정되어 있다. 이 설정이 되어있다면 DHCP클라이언트(내 컴퓨터)는 DHCP서버에 사용할 수 있는 TCP/IP 설정정보를 질의하고, 응답을 받은 뒤 해당 IP주소를 점유한다. 이렇게 우리의 IP주소는 자동으로 설정되는 것이다.","link":"/cs/network/TCP:IP/"},{"title":"1. 네트워크의 기본","text":"네트워크란 무엇인가? 네트워크란, 한 마디로 “연결”을 의미한다.학교도 선생님과 학생들을 이어주는 네트워크, 회사도, 집도 모두 네트워크의 일환이다. 컴퓨터 네트워크 ⇒ 하지만 컴퓨터 네트워크는 “데이터를 주고 받기 위한 네트워크”를 의미한다. 카톡 메시지를 주고 받는 것, 인터넷에서 정보를 검색하거나 작성하는 것 모두 데이터의 전달 과정이 그 기반이 된다. 사설 네트워크 (인트라넷) 사설 네트워크는 사용자의 제한을 두는 제한적인 네트워크다. ⇒ 인트라넷, LAN 등이 이에 포함될 수 있다. 인터넷 누구나 접속이 가능한 네트워크다 ⇒ 해커, 옆집 강아지(?), 할아버지 할머니 등등 브라우저를 통해 누구든지 인터넷에 접속할 수 있다. LAN과 WAN LAN과 WAN은 사설 네트워크(인트라넷 등)에 사용되는 네트워크다. LAN (Local Area Network) ⇒ 가까운 범위 내의 기기들을 라우터 등을 통해 연결시키고, 기기 간의 데이터 통신 등이 가능하도록 네트워크를 구성한다. 즉, 가까운 거리에 있는 기계와 기계를 연결시킨다! WAN (Wide Area Network) ⇒ 위의 LAN을 다른 거점의 LAN과 연결시킬 수 있도록 연결해주는 역할을 한다.즉, LAN과 LAN의 연결을 돕는 징검다리라고 생각하면 편하다. 인터넷 그렇다면 근거리 기기간의 통신이 아닌, 각기 떨어져 있는 세상의 모든 사람들과 통신할 수 있는 방법은 뭘까? → 바로 인터넷이다. AS와 ISP AS : 자율 시스템(Autonomous System)⇒ 전세계의 다양한 조직들이 운영하는 네트워크조직 등을 구성하는 네트워크 생태계 ISP : Internet Service Provider⇒ 쉽게 설명하자면, 네트워크 서비스를 제공해주는 기업을 의미한다. 1티어 ISP로는 SKT, KT, LG U+ 등이 있다. 하위 티어의 영세 ISP도 많은데, 이들의 통신은 어쩔 수 없이 1티어 ISP를 경유할 수밖에 없다즉, 우리는 인터넷을 이용하고자 한다면… 1티어 ISP를 반드시 사용하게 된다. 서버와 클라이언트, 그리고 애플리케이션 인터넷을 통해 데이터를 주고받는다는 것은 알겠다.그렇다면 그 데이터가 도대체 어떻게 저장되고 어디에 저장되는 것인가? 서버와 클라이언트 클라이언트 서버 일반적인 우리들의 컴퓨터 굉장히 좋은 컴퓨터 주로 서버에 데이터를 “요청(Reuest)” 클라이언트로 부터 요청을 처리 (Response) ⇒ 클라이언트(우리)는 서버에 어떠한 특정 요청을 보내고 → 서버는 이러한 요청을 처리한 뒤 응답(Response)를 보내준다. 고객이 레스토랑에서 웨이터에게 주문을 하는 것과 같다고 보면 된다. 이러한 이유 때문에 서버의 컴퓨터 성능은 고성능이 요구된다. 애플리케이션 서버에서 데이터를 받아 처리하는 역할을 하는 것이 애플리케이션이다.클라이언트 사이드에서 반환된 데이터를 받아내는 것 또한 클라이언트의 애플리케이션이다. 네트워크 아키텍처와 프로토콜 그럼 어떤 방식으로 데이터를 주고 받을까?⇒ 네트워크를 통한 올바른 데이터 송수신을 위해선 규칙과 규약 등이 필요하다. 프로토콜 ⇒ 우리가 한국어를 사용할 때 막 사용하는 것이 아니듯이, 네트워크 또한 통신을 할 때 자기가 원하는 대로 규칙없이 대화를 하지는 않는다. 한국어에도 문법, 훈민정음, 발음, 상황에 따른 용법 등 다양한 규칙과 기준이 존재하듯, 네트워크 통신에도 이러한 다양한 규칙(프로토콜)들이 존재한다. 즉, 프로토콜은 네트워크 통신을 위한 규약이자 규칙들의 단편들이다. 네트워크 아키텍처 ⇒ 위의 프로토콜들이 종합된 것이 네트워크 아키텍처다.한국어, 영어와 같이 하나의 언어라고 생각하면 된다. TCP/IP 전세계적으로 영어가 공용어로 통하듯이, 대부분 통용되는 네트워크 아키텍처의 표준은 TCP/IP다. 이러한 네트워크 아키텍처를 효율적으로 운용하기 위해 아키텍처는 프로토콜들을 단순히 집약해놓은 것이 아니라, 계층화 하여 기능별로 구분해 둔다. TCP/IP의 계층 애플리케이션 계층 트랜스포트 계층 인터넷층 네트워크 인터페이스층 클라우드 네트워크 전통적인 방식은 회사 등이 자체적으로 서버를 구축하여 운용하고 관리하는 것이었다.하지만 시대가 변함에 따라, 인터넷만 통해서 가상의 (물리적으로 떨어져있는) 서버를 구축할 수 있게 되었고, 우리는 이를 클라우드 서비스라고 부른다. 클라우드 서비스의 종류 Iaas : 하드웨어만 사용 가능 Paas : 하드웨어와 OS, Middleware등의 시스템 플랫폼을 활용 가능하다. Saas : 하드웨어와 플랫폼 뿐만 아니라, 애플리케이션 기능까지 모두 사용 가능하다⇒ 대표적인 예로 AWS를 들 수 있다.","link":"/cs/network/Network_Basic/"},{"title":"4. 웹사이트의 동작원리","text":"그동안 아무 의심이나 궁금증 조차도 없이, 인터넷과 웹 브라우저를 사용해왔던 것 같다.우리의 일상이 된 웹 브라우저는 어떻게 동작할까? 웹사이트는 문서다 처음에는 잘 와닿지 않았다. HTML, CSS, Javascript를 코딩하는 것 모두 브라우저가 읽을 수 있는 문서를 작성하는 것이다. 뭔가 굉장히 공학적이고 트렌디하다고 생각했던 프론트엔드 단에서의 코딩도 결국 문서 작성이었다니… 뭔가 기분이 새로웠다. 이러한 문서는 HTTP 통신을 통해 송수신된다. 웹브라우저 (클라이언트)는 웹서버에 데이터(HTML) 요청을 보낸다. → 그리고 웹서버는 그에 맞는 데이터를 반환해준다 → 그리고 우리는 전달받은 HTML 파일을 웹브라우저 상에 띄운다. 결국 이게 핵심이다. 우리는 HTTP(Hyper Text Transfer Protocol) 통신을 통해 데이터를 주고받는 것이다. 이러한 웹사이트 HTTP통신에서의 프로토콜은 아래와 같다. 웹사이트 접속에서의 프로토콜 HTTP TCP IP 이더넷 등 URL ? URI? &lt;스킴&gt;:// &lt;호스트명&gt;/&lt;경로명&gt;http://hoonjoo-park.github.io/about Uniform Resource Locator vs Uniform Resource Indentifier의 약자들이다. 하지만 URI가 정식 명칭이지만, 모두 같이 통용되어 불려지고 있다. 위의 예에서 스킴은, 웹브라우저가 웹서버의 데이터에 접속하기 위한 하나의 프로토콜이다. 대표적으로 http, https, ftp 등이 있다. 그리고 호스트명은 IP주소가 DNS서버에 의해 호스트명으로 변환된 것으로, 실제로는 IP주소를 의미한다. 마지막으로 경로명은, 쉽게 말해 파일의 위치를 나타내는 경로다. /about이면 about에 대한 HTML파일이 그 경로에 존재하는 것이다. HTTP Request 우리가 가장 자주 사용하는 Request요청에는 GET과 POST 등이 있다.이러한 리퀘스트는 리퀘스트 라인, 메시지 헤더, 엔티티 바디 세 가지로 분류될 수 있다. 리퀘스트 라인 HTTP 리퀘스트의 첫 째 라인으로, method, URI, 버전 등에 대한 정보가 담긴다. 메시지 헤더 웹브라우저의 종류와 버전, 그리고 대응하는 데이터 형식 등이 기술되어 있다. 엔티티 바디 POST method를 사용할 때 사용된다. ✋ HTTP통신 전에 웹브라우저와 웹서버는 서로 TCP 커넥션을 맺는다. 그리고 HTTP통신을 통해 데이터를 주고 받는 것이다. ✋ HTTP Response Request와 비슷하게 Response 또한 리스폰스 라인, 메시지 헤더, 엔티티 바디로 구성된다. 리스폰스 라인 버전, 상태코드, 설명문으로 구성되어 있다. 상태코드는 우리가 흔히 아는 1xx, 2xx, 3xx, 4xx등으로 이루어져 있고 각 코드마다 특정한 의미가 존재한다. (1xx : 추가 정보가 있음, 2xx: 서버가 요청을 성공적으로 처리했음 등등) 메시지 헤더 간단하게 데이터 형식이나 갱신 날짜 등이 기술된다. 엔티티 바디 웹브라우저에 돌려보낼 데이터가 담긴다. (주로 HTML파일) ✋ HTTP통신에는 Request와 Response만 달랑 존재하는게 아니다. DNS를 통해서 이름해석도 해야되고, ARP를 통해 MAC주소를 반환받기도 해야하는데, 이는 웹브라우저가 알아서 해준다! ✋ 쿠키 쿠키는 하나의 저장 데이터라고 생각하면 된다.웹서버 애플리케이션이 웹브라우저에 쿠키를 보내고, 웹 브라우저가 이를 허용하면 이후의 request에는 쿠키가 담겨져서 전송된다. 쿠키를 통해 세션 정보를 주고 받으며 웹페이지 내에서의 인증정보를 관리하고 활용할 수도 있고, 웹서버가 사용자의 로그인 정보나 웹페이지 열람 이력 등을 관리하며 이를 활용할 수도 있다. (지난 번에 검색했던 상품 기반으로 관련된 상품을 추천해준다던지..?)","link":"/cs/network/Website/"},{"title":"콜백과 프로미스 (Callback &amp; Promise)","text":"콜백 함수 (Callback Function) 비동기 처리 방식의 문제점을 해결하기 위해, 특정 로직 수행이 완료됐을 때 원하는 동작을 실행시킬 수 있도록 하는 함수! 레스토랑 예약을 예시로 들 수 있다. 우리는 레스토랑 예약을 통해 우리가 원하는 시간대에 웨이팅 없이 식사를 편하게 즐길 수 있고, 웨이팅을 하는 대신 그 시간을 자유롭게 활용할 수 있다. 즉, 예약한 시간대**(로직 수행이 완료됐을 때)에 우리는 식당에 가서 먹기로 했던 메뉴를 시켜먹으면 되는 것이다(동작)**. 😈 콜백 지옥 우리는 가끔, 비동기 처리를 위해 콜백함수를 중첩하여 사용하는 경우를 맞이하는데…이를 콜백 지옥(Callback Hell)이라고 부른다.이렇게 콜백 함수가 꼬리에 꼬리를 무는 형식은 가독성도 떨어지고 변경 및 유지보수가 어렵다. ⇒ 이러한 콜백 지옥 문제를 해결하기 위해 필요한 것이 Promise와 Async다. 🤙 프로미스란? “A promise is an object that may produce a single value some time in the future” =&gt; 자바스크립트 비동기 처리에 사용되는 객체로, 미래에 특정한 value를 생성해낸다.“미래에 하나의 value를 생성해낼 것이라는 약속!” 콜백 함수와 프로미스의 차이점? 콜백 함수와 프로미스 모두 비동기적 처리 방식의 문제점을 해결하기 위한 함수라는 점에서는 동일하다.하지만 Promise는 이러한 콜백함수들이 한 객체로써 뭉쳐서 중첩되어있지 않고분리된 객체로써 논리적으로 상호 연결될 수 있도록 하는 하나의 절차적 함수라고 보면 된다. 프로미스의 구조 new Promise() resolve() then() 프로미스의 상태(state) Pending(대기) : 비동기처리 로직이 아직 미완료된 상태 123new Promise(function (resolve, reject) { // ...}); Fullfilled(이행) : 비동기 처리가 완료 → 프로미스가 결과값을 반환 123456789101112//resolve가 됐고, 이제 then을 활용해 처리 결과값을 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { const data = 100; resolve(data); });}// resolve()의 결과 값 data를 resolvedData로 받음getData().then(function (resolvedData) { console.log(resolvedData); // 100}); Rejected(실패) : 비동기 처리의 오류/실패 12345678910111213//이렇게 리젝트에 대한 결과값(실패 이유)을 아래의 catch()를 통해 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { reject(new Error('Request is failed')); });}// reject()의 결과 값 Error를 err에 받음getData() .then() .catch(function (err) { console.log(err); // Error: Request is failed }); Iterator &amp; Iterable *이터레이터 : 반복자이터러블 : 반복 가능한* 자바스크립트에서는 “반복 가능한(Iterable)” 요소들만 순회 또는 반복될 수 있다. ex) 배열 이터레이터는 next, done, value의 구성을 갖는다!done : 이터레이터가 아직 루프중인지 확인value : 루프중일 때 해당하는 값을 반환 이터레이터와 배열의 차이? 이터레이터는 next 메서드만 기능할 수 있기 때문에, 배열의 기능적 부분집합이라고 볼 수 있다. 하지만… 일반적으로 배열이 이터레이터보다 무겁고 배열이 이터레이터보다 메모리 효율성이 떨어진다. 이터레이터는 다음 값 호출을 받았을 때, 그 때 필요한 값만 계산하는 것이 가능하기 때문이다. (next) 제너레이터 (Generator) 이터레이터를 사용할 수 있도록 해주는 함수 == 제너레이터이터레이터 + 이터러블의 조합 == 제너레이터 기본 문법 1234567function* gen() { yield 1; yield 2; yield 3;}var g = gen(); // &quot;Generator { }&quot; 사용 예시 (무한 반복자) 1234567891011function* idMaker() { var index = 0; while (true) yield index++;}var gen = idMaker(); // &quot;Generator { }&quot;console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// ...","link":"/javascript/base/Callback_Promise/"},{"title":"Javascript는 어떻게 작동하는가?","text":"💡 사전 지식 Parse : 컴퓨터가 이해할 수 있도록 프로그래밍 언어가 데이터를 가공하고 읽기 위해 일정한 포맷으로 변환하는 것. (쉽게 말하면, 사람의 언어 구조 → 컴퓨터의 언어 구조로 변환되는 것이라 봐도 될 것 같다) Thread : 프로그램 내에서의 작업 또는 프로세스의 경로 자바스크립트 개요 JS는 컴파일이 필요 없는 Interpreter 언어이다. JS는 변수를 설정할 때 특정 문자열타입을 지정하지 않고 let과 const에 구분없이 담을 수 있다. (동적 타입) 이러한 타입 시스템의 부재로 정적타입 언어인 C, C++에 비해 자바스크립트는 효율성이 떨어지고 느리다. 그렇다면 이렇게 비효율적이고 느린 언어를 계속 사용하는가? 이를 이해하기 위해선, 자바스크립트의 역사에 대해 간략히 짚고 넘어가야 한다. JS의 역사 1990년대의 웹 브라우저들은 매우 정적이고 비상호적인 페이지들을 띄우는 역할만을 담당했었다. 하지만 이후 웹 브라우저에서의 상호작용성을 더하기 위해 1995년 Netscape의 브랜든 아이크(Brendan Eich)에 의해 10일만에 개발된 Javascript가 세상에 공개되었고, 이는 혁신을 일으켰다. 하지만 여러 경쟁사들이 이러한 동적이고 상호적인 브라우저 언어의 개발에 뛰어들었고, 브라우저마다 언어가 달랐기에 호환성 등의 문제가 발발했다. 이에 따라 ECMA Script라는 브라우저 언어에 대한 약속이자 문법을 담은 문서가 개발된 것이다. 그렇게 표준화 되어가는 것 처럼 보이던 ECMA Script에 의한 브라우저 언어의 안정성과 호환성은 마이크로소프트 사의 ECMA 참여 거부로 점점 불안정해지기 시작한다. 그러나, Jesse James라는 개발자가 AJAX를 제안했고, 2008년 생태계 교란종이라고 할 수 있는 강력한 Chrome의 등장으로 위기를 느낀 다른 브라우저들의 협력을 통해 ES5, ES6 등의 문서들이 이후 작성되었다. 드디어 JS는 성숙하고 안정된 언어로 자리잡을 수 있게 된 것이다. 이제 JS가 브라우저에서 어떻게 “실행(Implemented)”되어야 하는지는 ES에 의해 정의됐다.그렇다면 “어떻게” 작동되어야 하는지는 무엇이 결정하는가? ⇒ JS엔진에 대한 이해가 필요하다. 자바스크립트 엔진 모든 브라우저는 JS코드를 실행하기 위한 JS 엔진을 탑재하고 있다 (Netscape는 SpiderMonkey라는 엔진을, Chrome은 V8엔진을 사용한다). 가장 기초적인 엔진구조(SpiderMonkey)는 JS소스코드를 컴파일 하여 Bytecode로 만드는 baseline compiler → 그리고 이 Bytecode를 머신코드(Binary Code)로 변환하여 최종적으로 CPU에서 실행되게 하는 Interpreter가 존재한다. 하지만 이러한 기초적 엔진구조는 컴파일 시간의 단축에만 집중할 뿐, 코드의 최적화에는 목적을 두지 않는다. 따라서 위와 같은 기초적 엔진구조는 아주 동적이고 인터렉티브한 웹 어플리케이션을 구동하는데 무리가 있다. 이러한 문제점들을 해결하기 위해 구글(Google)은 V8엔진을 사용한다. V8은 Baseline Compiler로써 Full-Codegen을 사용하고, 최적화를 위한 Crankshaft를 사용한다. 기존과 같이 Full-Codegen은 최적화를 신경쓰지 않고 최대한 빨리 Binary Code를 반환한다. 하지만 이러한 과정 중에 소스코드의 최적화를 진행해 최적화된 코드를 Full-Codegen이 반환한 코드의 일부와 대체한다. 즉, 빠른 컴파일과 최적화를 행한다는 것이다. 어떻게 작동되는지에 대한 프로세스는 이제 알겠다. 그렇다면 그 “최적화”라는 것은 어떻게 이루어지는가? 자바스크립트의 최적화 위에서 설명했듯, JS는 타입 시스템이 없고, 더 나아가 프로파일링 데이터(Profiling Data)를 수집하며 느리게 실행되는 코드를 감별하느라 CPU에 부담을 준다. 이에 따라 2017년에 새로 개발된 것이 새로운 V8엔진이다. 새로운 버전의 V8 엔진에는 Ignition이라는 파이프라인이 추가됐다. 이는 **베이스라인의 기능( JS 소스코드 → 바이트 코드로 변환) + 인터프리터의 기능(바이너리 코드로의 변환)**이 이루어지는 파이프라인이다. 그리고 Turbo Fan은 Ignition으로 부터 프로파일링 데이터를 넘겨받아 Hot코드 (CPU에 부담을 주는 코드)를 최적화 할 지, 말 지를 결정한다. 런타임에서의 JS 자바스크립트는 single-threaded 언어다. 즉, 자바스크립트는 코드가 실행될 때 모든 코드가 한 덩어리로써 한번에 실행된다는 것이다. 이러한 싱글 스레드 방식의 문제점은, 실행시간이 오래걸리는 코드가 중간에 껴있으면, 그 후의 코드 실행에 악영향을 미친다는 것이다. 따라서 이러한 블락(또는 무한루프) 문제점이 발생하면 브라우저의 모든 기능들은 중단된다는 문제점을 갖는다. 하지만 다행히도, 이제는 대부분의 브라우저들이 멀티탭 기능들을 탑재하고 있기에, 브라우저별 스레드가 아닌 탭(Tab)별 스레드가 적용되기 때문에 하나의 탭에만 싱글 스레드 문제점이 적용된다. 이렇듯 자바스크립트는 싱글 스레디드 언어이기 때문에 하나의 힙 메모리와 하나의 스택을 갖는다. 스택에서의 코드 실행 방식과 pop 방식은 아래와 같이 LIFO(후입선출)를 따른다. 이와 같은 싱글 스레드 방식만을 따르면, 브라우저는 HTTP 요청을 보내거나 받는 동안 다른 모든 핵심 기능들을 (캐싱, 데이터베이스 스토리지, DOM 이벤트 리스닝 등등) 사용하지 못할 것이다. 이를 해결하기 위해 자바스크립트만의 스레드는 독립적으로 두되, 브라우저 자체 내에서 다른 스레드를 구성하여 DOM 이벤트 리스닝, 캐싱, 데이터베이스 스토리지 등을 자바스크립트와는 독립적으로 기능할 수 있도록 하는 것이다. 이러한 독립적 스레드를 사용하는 브라우저 기능 중에는 Web API 요청을 위한 fetch() 가 있다. 이 fetch()는 자바스크립트 엔진 내의 스레드를 사용하지 않기 때문에 비동기적으로 작동하고, 이러한 비동기 방식 때문에 우리는 fetch()를 사용할 때 콜백함수를 사용하고, async await과 같은 비동기 처리 방식들을 사용하는 것이다. 1234567891011121314151617function printHello() { console.log('Hello from baz');}function three() { setTimeout(printHello, 3000);}function two() { three();}function one() { two();}one(); Event Loop : 콜스택과 콜백 큐를 주시하며, 콜스택이 비어있고, 콜백 큐에 처리해야 할 스택이 존재한다면 해당 스택을 콜스택으로 옮겨 쌓아 올리는 역할을 한다. 이와 비슷하게 setTimeout() 또한, 콜스택과 메시지큐, 이벤트루프에 의한 독립적 스레드에 의해 효율적으로 작동된다. 먼저 위의 코드를 보면 one() → two() → three() 순으로 코드가 실행될 것이다. 하지만 three()의 setTimeout()내의 콜백함수인 printHello()는 자바스크립트에 의해 webAPI로 보내질 것이고 자바스크립트 엔진 자체에서 3초를 기다리는 것이 아닌, 자바스크립트 자체는 이후 바로 다음 라인의 코드로 넘어간다. 하지만 다음 라인의 코드가 없기에 자바스크립트는 콜스택에서 three two one을 순서대로 pop할 것이다. 하지만 3초 뒤 콜백함수(printHello)는 webAPI에 의해 메시지큐에 담길 것이고, 이벤트루프가 이 콜백함수를 다시 콜스택 위에 올릴 것이다. 그렇게 setTimeout과 그 안의 콜백함수가 실행되는 것이다.","link":"/javascript/base/javascript-howItWorks/"},{"title":"var, let, const의 차이","text":"var var은 ES5까지 자바스크립트에서 모든 선언을 담당했던 키워드였다.근데 var은 참 많은 문제점들을 보유하고 있었다고 한다. 그럼 var 키워드의 특징들에는 무엇이 있는지 알아보자. 함수레벨 스코프(Function-Level-Scope) 기본적으로 var은 **함수레벨스코프(Function-Level-Scope)**로, 선언된 함수 안에서만 해당 변수를 사용할 수 있도록 한다. 즉, 함수의 코드블록 범위 까지만을 스코프로 인정하는 것이다. 12345678function test() { for (var i = 0; i &lt; 5; i++) { continue; } console.log(i); // 5}// 근데 함수 밖에서 쓰면 ?console.log(i); // ReferenceError: i is not defined ⇒ ⚠️ 만약 함수 밖에 전역적으로 var 선언을 했다면, 이는 전역변수가 된다. 따라서 var를 잘못 사용하면 전역변수의 오남용을 초래할 수 있다. 재선언이 가능하다. 아래와 같이 변수의 재선언이 가능하기 때문에, 변수 명을 헷갈려 실수로 같은 변수명을 사용하는 등의 오류 발생을 초래할 수 있다. 123var name = 'hoon';var name = 'joo';console.log(name); // 아무 오류도 발생하지 않고 joo가 출력된다. 변수를 호이스팅 한다. 아래에서 호이스팅에 대해 조금 더 자세히 다룰 것이다.우선, var은 호이스팅이 되기 때문에 변수를 선언하기 전에 console.log()를 찍어도 에러가 나지 않는다. 12console.log(name); // undefinedvar name = 'hoon'; ⇒ 하지만 let과 const는 위와 같은 코드를 실행시켰을 때 undefined가 아닌 ReferenceError: i is not defined 등의 결과가 나타난다. 스코프? 한 마디로, 변수에 접근할 수 있는 범위를 의미한다. 전역 스코프 ⇒ 전역적으로 선언된 변수는 전역 스코프에 해당한다. 따라서 어디서든지 변수에 접근하여 이를 활용할 수 있다. 지역 스코프 ⇒ 지역 스코프는 특정 지역(범위)에서만 해당 변수를 접근할 수 있다. 🎣 호이스팅 쉽게 말해 “감아올리다”라는 의미다.호이스팅은 모든 선언문들을 해당 선언문이 적용받은 스코프의 최상단으로 옮겨진 것처럼 작동하도록 한다.즉, 스코프의 최상단으로 해당 선언문을 끌어올리는 것이다. 호이스팅을 설명하기에 앞 서, 기본적으로 변수가 생성되는 과정은 선언 → 초기화 → 할당과 같다. 선언단계 (Declaration Phase) 변수 객체에 변수가 등록된다. 초기화 단계 (Initialization Phase) 해당 변수를 메모리에 할당한다. 그리고 변수는 undefined로 초기화 된다. 12// 선언 + 초기화var name; 할당 단계 (Assignment Phase) undefined로 초기화된 변수에 원하는 값을 할당한다. 12345// 선언 + 초기화var name; // undefined// 할당name = 'hoon';console.log(name); // hoon 호이스팅과 변수 생성 과정의 차이에 따라 아래와 같은 차이점들이 나타난다. var var의 경우에는 생성과 동시에 초기화가 이루어진다. 따라서 아래와 같이 console.log(name)만으로도 생성 + 초기화가 이루어진다. 123456console.log(name); // undefinedvar name;console.log(name); // undefinedname = 'hoon';console.log(name); // hoon let 하지만 let의 경우에는 생성과 초기화의 과정이 분리되어 있다. 따라서 아래와 같이 초기화를 하기 전에 변수를 사용하려고 하면 에러가 난다. 12console.log(name); // ReferenceError: name is not definedlet name; ES6 : let과 const의 등장 ES6 에서 부터 let과 const가 등장했다.이 둘은 var과 어떻게 다르며, 또 let과 const는 서로 어떻게 다를까? 함수레벨 스코프 vs 블록레벨 스코프 let과 const는 블록레벨 스코프다. 즉, 변수가 특정한 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언됐다면, 이 코드 블록 내에서만 변수에 접근할 수 있다. 12345// 그래서 아래와 같이 for문 안에서 선언된 let은 for문 밖에서 접근할 수 없다.for (let i = 0; i &lt; 5; i++) { continue;}console.log(i); // ReferenceError: i is not defined 재선언과 재할당 let과 const는 var과 달리 재선언이 절대 불가능하다. 하지만, 그럼에도 let과 const에는 차이점이 있다. let은 재할당이 가능하다. 123let name = 'hoon';name = 'joo';console.log(name); // joo const는 재할당마저도 불가능하다. 123const name = 'hoon';name = 'joo';console.log(name); // 오류 발생 TypeError: &quot;name&quot; is read-only","link":"/javascript/base/var_let_const/"},{"title":"Wesbos - Clock","text":"CSS와 JS를 이용해 아날로그 시계를 구현해보는 챕터다.시침 분침 초침이 시간에 따라 움직이도록 하려면 어떻게 해야할까? 로직시간이 변할 때 시간이 지날 때마다 침들의 deg에 변화를 준다. (rotate) = 1초, 1분, 1시간을 기준으로! = 각도는 360도를 기준으로! 침이 움직일 때 (CSS) = transition 효과를 줘서 실제 시계 침의 움직임과 유사하도록 구현 (째깍째깍의 느낌) 코딩 과정1. 초침, 분침, 시침을 지정해주자123const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand'); 그렇다면….. 시간의 흐름을 어떻게 get하고 표현해야할까? 2. 현재 시, 분, 초를 불러오기현재 시,분,초에 따라 침들의 각도가 달라져야 하기 때문에, 시분초를 불러오는게 가장 먼저 해야 할 일 ! Date(), getHours(), getMinutes(), getSeconds() 👉 new Date()를 통해 현재 년월일 시분초를 불러올 수 있다. 이후, Date 내에서 getOOO을 통해 시 분 초를 골라서 사용할 수 있음 ! 123456function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds();} 3. 현재 시, 분, 초에 따른 침들의 각도 지정하기! 👉 transform = rotate(OOdeg); 를 활용 ! 123456const secondsDegrees = (seconds / 60) * 360 + 90;secondsHand.style.transform = `rotate(${secondsDegrees}deg)`;const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90;hoursHand.style.transform = `rotate(${hoursDegrees}deg)`;const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90;minutesHand.style.transform = `rotate(${minutesDegrees}deg)`; 4. setInterval을 활용한 함수의 주기적 실행 👉 현재 시간에 따라 침이 변화해야 하는데 setInterval( ) 을 추가하지 않을 시 위의 setDate( ) 함수는 한번밖에 실행되지 않아 시계가 멈춰있게 된다. setInterval() 👉 일정한 시간 간격을 기준으로 특정 코드블록을 반복 실행할 수 있도록 하는 함수 setInterval(실행할 함수 이름, 시간 간격 기준) 단, 시간 간격은 ms가 기본 단위이다 (1000에 1초) 12setInterval(setDate, 1000);//1초에 한번씩 setDate함수를 실행하겠다는 뜻 최종 완성 코드123456789101112131415161718const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand');function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds(); const secondsDegrees = (seconds / 60) * 360 + 90; secondsHand.style.transform = `rotate(${secondsDegrees}deg)`; const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90; hoursHand.style.transform = `rotate(${hoursDegrees}deg)`; const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90; minutesHand.style.transform = `rotate(${minutesDegrees}deg)`;}setInterval(setDate, 1000);","link":"/javascript/wesbos/02.%20Clock/"},{"title":"환율 계산기","text":"프리온보딩 구현 과제 API를 통해 환율값을 받아 와, 실시간 환율 계산을 할 수 있도록 하는 계산기를 구현해봤다. 배포 주소http://beefplz.s3-website.ap-northeast-2.amazonaws.com 사용 기술 및 스택 Stack React Hooks styled-components fetch Deploy : Netilfy Other : Git / GitHub Build Tool (Create React App) Code Quality Tool (Prettier) 디렉토리 구조 (CRA Project Structure)123456789101112131415161718192021222324src│├─components│ │ │ └─SelectConverter │ SelectBox.jsx│ │ SelectConverter.jsx│ └─TabConverter│ FormBox.jsx│ ResultBox.jsx│ TabConverter.jsx│├─constants│ index.js│├─pages│ MainPage.jsx│├─styles│ GlobalStyles.js│├─utils│ dateConverter.js│ 표기법 케이스 약속 폴더명 소문자로 작성 파일명 파스칼케이스 (PascalCase) 변수명 카멜 케이스 (camelCase) constants 대문자 + 언더바 조합 (BACKGROUND_COLOR) 레이아웃 MainPage.jsx의 기본 레이아웃은 화면에 가득 차도록 하여 그 안에 들어오는 두 계산기 컴포넌트들이 절반씩을 차지할 수 있도록 flex를 준다. 그리고 각 계산기 컴포넌트의 컨테이너는 50vw만큼을 준 뒤, display: flex를 주고 모두 중앙 정렬 시킨다. 탭 계산기 (박훈주, 이주영) 레이아웃 및 UI 설계 (input, select 로 입력값 설정 후 하단의 탭박스에 결과값 출력) 선택된 통화의 종류에 따라 Tab의 구성이 유동적으로 변화되도록 구현ex) 드롭다운 메뉴를 “USD” → “CAD”로 바꿀 경우, 탭 내부의 “CAD”는 제거되고 “USD” 추가. 선택된 Tab의 border-bottom만 제거되도록 구현 input 박스에 숫자만 입력되도록 설정 후 회계/통화 형식에 맞춰 콤마(,)가 천의 자리마다 찍힐 수 있도록 구현 ex) ‘2000’ 입력 시 ‘2,000’ 으로 출력 API를 통해 실시간으로 환율 데이터를 가져와서 환율 계산기 구현.환율 연산식 : `input 입력값 * (탭에서 선택된 통화 / 드롭다운에서 선택된 통화)` 컴포넌트 레이아웃TabConverter의 컴포넌트 구성 12345// TabConverter.jsx&lt;TabConverterContainer&gt; &lt;FormBox /&gt; &lt;ResultBox /&gt;&lt;/TabConverterContainer&gt; 기능 구현 기준통화를 변경할 때마다 아래의 Tab 리스트가 변경되어야 한다. 입력값이 1000 이상일 때는 셋째 자리수마다 콤마가 찍혀야 한다. 선택된 기준통화에 따른 국가들의 환율 환산값이 계산되어야 한다. 1. 기준통화 변경될 때마다 Tab 리스트 변경하기 constants에 tab에 들어갈 고정된 국가별 통화들을 배열로 입력해뒀다. 그리고 기준통화가 변경될 때마다 filter()를 활용해 tab배열이 변화되도록 구현했다. 123// ../constants/index.jsexport const TAB_CURRENCY = ['USD', 'KRW', 'JPY', 'CAD', 'HKD', 'CNY']; 12345678910111213// ResultBox.jsxuseEffect(() =&gt; { // useEffect를 통해 기준통화가 변경될 때마다 아래 함수가 실행되도록 했다. const handleTab = () =&gt; { // TAB_CURRENCT 상수를 불러와 filter한다. (기준통화와 같지 않은 값들만 필터링된다) let changedTabs = TAB_CURRENCY.filter((tab) =&gt; tab !== currency); // 그리고 Tabs에 기준통화가 제외된 새로운 배열이 담긴다 setTabs(changedTabs); // 그리고 첫 번째 탭으로 지정되어야 할 국가가 currentTab에 저장된다.(첫 탭이 디폴트로 선택되도록 하기 위함) setCurrentTab(changedTabs[0]); }; handleTab();}, [currency, setCurrentTab]); 2. 숫자에 콤마 표시, 그리고 소수점 자리수 제한 toLocaleString() 을 활용했으며, 원활하고 즉각적인 input value를 받아오기 위해 onChange와 onKeyUp 이벤트를 같이 사용했다. 12345678// onChange, onKeyUp 모두 사용&lt;input type='text' placeholder='값을 입력하세요' value={inputValue} onChange={(e) =&gt; handleType(e)} onKeyUp={(e) =&gt; handleType(e)}/&gt; 123456789101112131415161718192021const handleType = (e) =&gt; { // 1000이 넘어갔을 때 콤마를 붙여줘야 하는데... 콤마가 붙으면 더이상 숫자가 아니다. // 따라서 해당 값을 콤마를 제거한 상태로 초기화시켜줘야 한다. const pureString = e.target.value.split(',').join(''); if (isNaN(Number(pureString))) { return; } // 따라서 1000 이상의 값이 입력됐을 때 이전에 입력된 값이 콤마가 붙은 string이면 아래의 조건문에 걸리지 않는다. // 이 때문에 pureString을 선언하여 사용한건 것이다. if (Number(pureString) &gt;= 1000) { // 이 조건문에 해당된다면, 다시 콤마를 붙여줘야 한다. (toLocaleString을 활용했다) setInputValue( Number(pureString).toLocaleString('en', { maximumFractionDigits: 3, }) ); return; } // 1000보다 작으면 그냥 pureString을 넣어준다. setInputValue(pureString);}; toLocaleString() 사용법 123let testNum = 1234;// 한국식 회계 콤마 표준, 그리고 소수점은 둘 째 자리까지 허용testNum.toLocaleString('ko-KR', { maximumFractionDigits: 2 }); 3. 환율 계산 calculator()라는 함수를 만들어 계산했다. 123456789101112131415// ResultBox.jsx// 기준통화가 base, 상대국 통화가 target이다.const calculator = (target, base) =&gt; { // api 데이터의 value값은 다 USD기준이기에 'USDOOO'으로 표기되어있다. // 따라서 아래와 같이 앞에 USD를 붙여준 뒤 해당 값을 가져왔다. let targetRate = apiData.quotes[`USD${target}`]; let baseRate = apiData.quotes[`USD${base}`]; // 미국 통화가 기준이기에 모든 환율값의 분모는 USD다. 따라서 그냥 나눗셈을 해주면 자동 약분처리되기 때문에 쉽게 계산할 수 있다. // 계산식은 =&gt; (상대국 환율 / 기준국 환율) * input에 적은 액수 let exchangeRate = Number((targetRate / baseRate) * writtenMoney); // 마지막으로 해당 환율값의 소숫점은 둘째 자리까지, 콤마 표기도 해줘야 하기 때문에 아래와 같이 리턴해준다. return exchangeRate.toLocaleString('en', { maximumFractionDigits: 2, });};","link":"/projects/preonboard/currencyConverter/"},{"title":"Wesbos - Variable CSS","text":"로직 스크롤 → 해당 라벨의 이동값 선택 → 해당 값이 css variable에 적용 → 뒤에 suffix값 붙여넣기 CSS의 변수화 👉 CSS에서의 Variable control은 이하와 같이 표현 12345:root { --속성 : 값};//:root는 최상위 엘리먼트를 의미한다. (HTML) setProperty() 👉 설정, 2개의 인자 (속성,값) 1document.documentElement.style.setProperty(속성, 값); documentElement 👉 html 안의 모든 요소를 말한다 최종 코드 123456789101112const inputs = document.querySelectorAll('.controls input');function handleUpdate() { const suffix = this.dataset.sizing || ''; document.documentElement.style.setProperty( `--${this.name}`, this.value + suffix );}inputs.forEach((input) =&gt; input.addEventListener('change', handleUpdate));inputs.forEach((input) =&gt; input.addEventListener('mousemove', handleUpdate)); 1font-family: 'helvetica neue', sans-serif;","link":"/javascript/wesbos/03.%20Variable%20CSS/"},{"title":"Wesbos - Drum Kit","text":"키보드를 누르면 해당 키값에 맞는 드럼 사운드가 재생되는 간단한 웹페이지다.우선, 각 키를 눌렀을 때 기능해야하는 것들 + 웹페이지 작동 원리와 로직은 이하와 같다! 로직 키보드를 눌렀을 때? 해당 키값 찾기 (keyCode) 해당 오디오 태그 값 찾아서 play 연타 가능하도록 Currenttime = 0으로 설정 css 적용 (.playing 삽입) 적용된 css 제거하며 역트랜지션 구현 가능하도록 구현 코딩 과정1. 해당 키값 찾기 (keyCode) 각 키보드에는 고유한 키값이 존재한다.http://keycode.info/ 이곳에 들어가 각 키값(keyCode)들을 알아보자. html파일에서 key블록을 구성하고 있는 div에 data-key = “nn”형식으로 키값을 부여한다. 123&lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;kbd&gt;&lt;/div&gt; 참고로 본인은 기존에 설정 되어있던 [a-s-d-f-g-h-j-k-l] 배열이 불편하다 생각이 들어 오투잼 배열로 키보드 배열을 변경했음. (div와 audio 태그 내의 data-key만 변경해주면 쉽게 변경 가능!) 완료했다면, JS파일로 돌아가 keys라는 변수를 querySelectorAll을 통해 지정해준다. 1const keys = document.querySelectorAll('.key'); 이제 키보드를 눌렀다는 event를 컴퓨터가 감지할 수 있도록 addEventListener를 통해 keydown 이벤트에 반응하는 함수를 만들어준다. 1window.addEventListener('keydown', keydown); forEach 💡 배열에 사용되는 함수! 편리하게도 배열의 각 요소에 대한 callback 함수를 적용할 수 있음 123456//예시const array1 = ['가', '나', '다'];array1.forEach((element) =&gt; console.log(element));// 예상 아웃풋: &quot;가&quot;// 예상 아웃풋: &quot;나&quot;// 예상 아웃풋: &quot;다&quot; 이제 위에서 설정한 keydown 이벤트를 들을 수 있는 keydown함수를 작성해준다. 그리고 console.log를 통해 누른 키에 해당하는 keyCode값을 콘솔 창에 찍어보자. 123function keydown(e) { console.log(e.keyCode);} 2. 키 값을 활용해 audio를 play audio에 입력된 data-key와 입력된 키의 keyCode가 상호 연결되어,입력된 키에 해당하는 audio만 재생이 돼야 한다. ⇒ 따라서, audio를 따로 변수처리 해서 해당 오디오 파일을 재생시켜줘야 함 12345678const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);// 이렇게 e.keyCode를 변수화 하여 audio에 대입시키면 audio는 특정 audio,// 즉 눌러진 키에 해당하는 사운드만 플레이 될 수 있도록 지정할 수 있는 것!audio.play();//이제 play함수를 적용시키면 눌려진 키 값에 해당하는 사운드만 재생되는 것을 확인 할 수 있다. 3. currentTime을 활용한 연타 기능 추가 But… 키값에 맞는 오디오가 잘 플레이 되기는 하지만, 키를 연속적으로 눌러도 한 사운드의 재생이 끝날 때 까지 다음 키의 재생이 이루어지지 않는 것을 확인할 수 있다. ⇒ 따라서 currentTime을 활용해 키가 연속적으로 눌렸을 때 이에 즉각적으로 play() 함수가 반응되도록 해보자. 123456function keydown(e) { console.log(e.keycode); //이제는 필요 없는 코드 const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`); audio.currentTime = 0; audio.play();} currentTime currentTime은 HTML 내의 태그를 제어하기 위한 메소드다. currentTime = n; 을 통해 특정 수를 부여하면 audio는 해당 숫자에 해당되는 초로 이동한다.이에 따라, 위에서와 같이 currentTime=0; 을 사용하게 되면어떤 키가 눌렸을 때 해당 audio의 현재 플레이 위치는 0이 되는 것이다.즉, “재생이 정지된 것과 같은 효과 ⇒ 그에 따른 연타 가능”의 기능이 적용될 수 있는 것! 4. CSS 적용! 이제 CSS 적용만 하면 된다 :)audio에서 적용했던 논리와 동일하게 내가 누른 키에 해당하는 에만 css가 적용되도록 하면 됨! 123const key = document.querySelector(`.key[data-key=&quot;${e.keyCode}&quot;]`);key.classList.add('playing'); //미리 작성해둔 css 클래스를 적용 하지만…. 위의 코드만으론 css가 “적용”되기만 할 뿐, 키보드를 떼었을 때 css가 제거되지는 않는다. 5. 역트랜지션 구현 위의 키보드 div들의 .playing CSS의 적용과 트랜지션이 끝났을 때 곧바로 CSS가 제거되도록 코드를 짜주면 된다. 123456keys.forEach((key) =&gt; key.addEventListener('transitionend', transitionRemove));function transitionRemove(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing'); //transition이 끝난 div들의 playing css는 모두 제거된다.} 이제 모든 필요 기능들에 필요한 코드를 다 짰다. 아래는 그에 따른 최종 완성 코드다 :) 최종 완성 코드12345678910111213141516171819function playsound(e) { const key = document.querySelector(`.key[data-key = &quot;${e.keyCode}&quot;]`); const audio = document.querySelector(`audio[data-key = &quot;${e.keyCode}&quot;]`); if (!audio) return; //반드시 필요한 것은 아니지만, audio의 data-key에 해당하지 않는 키값이 입력됐을 때 함수가 종료되도록 //위와 같은 코드를 추가했음! audio.currentTime = 0; audio.play(); key.classList.add('playing');}function removeTransition(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach((key) =&gt; key.addEventListener('transitionend', removeTransition));window.addEventListener('keydown', playsound);","link":"/javascript/wesbos/01.%20Drum%20Kit%20/"},{"title":"Wesbos - Array Cardio_1","text":"✅ 모든 언어에서 필수적으로 다뤄야 하는,그리고 굉장히 중요한 영역인 배열을 다루는 챕터였다. 기본 사항 이번 챕터에서 다룬 주요 배열 함수들은 순서대로filter(), map(), sort(), reduce()다. Javascript에서 배열 = [] 객체={}로 표현한다.객체는 {key : value}가 기본 형태 🙂 console.log 외에도 console.table(), console.dir() 등을 활용해볼 수도 있다. table()은 표 형태로 콘솔창에 출력되고,dir()은 해당 객체의 property들이 출력된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 주어진 배열const inventors = [ { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 }, { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 }, { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 }, { first: 'Max', last: 'Planck', year: 1858, passed: 1947 }, { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 }, { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 }, { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 }, { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 }, { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 },];const people = [ 'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig', 'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving', 'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano', 'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose', 'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank',]; filter() 🔥 array.filter()를 통해 기존 배열을 조건에 맞게 새로운 배열로 반환할 수 있다. 실행결과123//filter를 활용하여 inventors 배열 내에서 &quot;1500년도에 태어난 inventor만&quot;을 새 배열로 추출해보시오.const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year =&lt; 1599));console.table(fifteen); map() 🔥 array.map()를 통해 배열 내의 데이터를 **”콜백함수”**에 맞게 새로운 배열로 반환! filter와 map의 차이점? filter는 조건!map은 콜백(CallBack)함수! ⇒ 이처럼, filter는 콜백함수에 반응하지 앉고 map()만 콜백함수가 조건으로써 적용될 수 있다.쉽게 생각하면, filter()는 if가 사용되는 배열함수라고 생각하면 될 것 같다. 실행결과123456//map() 함수를 사용해서 invertor들의 성과 이름을 통해 Full Name이 담긴 새 배열을 만들어보시오.const fullNames = inventors.map( (inventor) =&gt; `${inventors.first} ${inventors.last}`);console.table(fullNames); sort() sort()의 기본형은 글자순으로 자동정렬 or 숫자(앞자리 기준) 기준으로 자동정렬이다. 하지만, 우리가 이번 챕터에서 사용하는 sort()함수는 Compare Function. 즉, 비교 함수로써의 sort()다. Compare Function으로써의 sort() 🔥 array.sort(a,b)를 통해 a와 b를 비교해 “오름차순 또는 내림차순” 정렬 방식을 정하여 반환 123array.sort((a, b) =&gt; (a.value &gt; b.value ? 1 : -1));// 즉, a값이 b보다 크면 아래로 내리고, 그 반대라면 작은 것을 위로 올리겠다는 뜻 !// 0 또한 지정해줄 수 있는데, 이는 a와 b가 같은 값일 때를 의미한다. 실행결과123456// sort()를 활용하여 inventors를 나이에 대한 내림차순으로 정렬해보시오.const orderByBirth = inventors.sort((a, b) =&gt; (a.year &gt; b.year ? 1 : -1));// True라면 1이 부여되어 비교대상보다 위로 올라간다. (모든항 비교해 점수매기기라고 생각해도 될듯)console.table(orderByBirth); reduce() 🔥 array.reduce(리듀서 함수, 현재값) ⇒ 리듀서 함수를 실행하여 하나의 결과값을 반환한다. 1234array.reduce((total, currentValue) =&gt; { return total + currentValue;}, 0);// total의 초기값은 0, 이후 currentValue에 부여한 수식이 루프되어 총합이 계산된다. 실행결과1234567// reduce()를 활용하여 inventors의 나이를 모두 합한 결과값을 반환하시오.const sumOld = inventors.reduce((sum, inventor) =&gt; { return sum + (inventor.passed - inventor.year);}, 0);//여기서 0은 initialValue를 의미하는데, 가장 처음 루프 때 sum의 값이라고 생각하면 된다.","link":"/javascript/wesbos/04.%20Array%20Cardio1%20/"},{"title":"Wesbos - Flex Box","text":"box-sizing 🔥 박스 크기의 기준을 어떤 것으로 설정할 것인가? content-box : 오로지 콘텐트 요소만 포함 (기본값) border-box : 콘텐트 + 보더 + 패딩 값을 모두 포함 inherit : 부모 요소로부터 상속 12345// 대부분의 개발자들은 border-box를 기본값으로 설정해두고 코딩을 함*{ box-sizing : border-box;}; justify-content와 align-items 🌸flex-basis와 flex-grow flex-basis = flex item의 기본 크기를 설정함 ! (direction이 row면 너비, column이면 높이) flex-grow = item이 basis값보다 커질 수 있는지 설정! (기본값은 0, 유연하게 늘어날 수 있도록 설정은 1) 123456// 비율 놀이라고 생각해도 편함 !.item:nth-child(1) { flex-grow: 1;}.item:nth-child(2) { flex-grow: 2;}.item:nth-child(3) { flex-grow: 1;}// 이럴 경우 1: 2: 1 비율로 컨테이너 안에서 크기가 형성됨 축약 속성 🔥 flex : grow, shrink, basis; Flex-container와 Flex-items? 🔥 Container는 아이템을 담는 박스라고 생각하면 되고,item은 개별 객체들이라고 보면 됨 ! // container에 display=flex를 주고, items에는 items에 쓸 수 있는 기능들이 따로 있음 flex-basis 🔥 flex를 적용할 경우, item들은 컨텐츠에 맞게 넓이가 설정되는데 basis값을 줄 경우 기본 넓이값이 설정된다. 만약 flex-basis를 100px로 줬는데 아이템 안에 컨텐츠가 100px보다 크다면 컨텐츠 값에 맞게 늘어난다. 즉, 컨텐츠 길이가 basis값보다 작으면 아이템은 basis에 맞춰서 크기가 설정됨 ! flex-grow (유연하게 늘리기) 🔥 flex-basis가 갖는 영역을 제외한 여백의 비율을 지정.기본값 = 0 flex-shrink (유연하게 줄이기) 🔥 flex-basis보다 크기가 줄어들 수 있는가 ?기본값 : 1 만약, 0으로 값을 설정하면 고정값으로 설정돼 basis의 크기가 고정값으로 지정된다.** 최종 완성 코드12345678const panels = document.querySelectorAll('.panel');function clicked() { this.classList.toggle('open'); this.classList.toggle('open-active');}panels.forEach((div) =&gt; div.addEventListener('click', clicked));","link":"/javascript/wesbos/05.%20Flex%20Box/"},{"title":"Wesbos - Type Ahead (동적 검색)","text":"💡 앞으로 개발을 하다보면 자주 사용하게 될 것 같은 동적 검색창이다.사실 Wes Bos 30일 챌린지를 진행하면서 근 6회차 중에 가장 어려운 챕터였던 것 같다…. 로직 json파일 불러오기 json파일을 새로운 배열 형태로 생성 (fetch) 검색어 찾기 기능 (“찾기”) 검색어에 해당하는 cities 나타내기(display) 1. json파일 불러오기 💡 json 주소 주소에 저장돼있는 json 형식의 city 파일 1234//이 json 파일 주소를 const를 통해 endpoint라는 값으로 지정!const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json'; ❓ 하지만, 여기까지는 아직 주소값만 지정해준 것이기 때문에,이 json파일을 배열로써 나타나게 해줘야 한다. 12// 우선 cities라는 빈 배열을 만들어주자const cities = []; ⭐ 그렇다면, 이제 어떻게 저 주소로부터 city 값들을 불러들여올 수 있을까? =&gt; fetch API를 사용하면 된다 ! fetch API💡 fetch는 서버에 네트워크 요청을 할 수 있도록 도와주는 AJAX기반의 API다. 💡 fetch(접근하고자 하는 url, 옵션)then.() == 호출에 성공했을 때 응답객체를 resolve 즉, then은 fetch에 대한 응답형태 및 방식이라고 보면 된다. 123456//우선, 나는 json 주소를 endpoint로 지정해뒀으니까 주소 대신 변수명을 넣어준다.fetch(endpoint) //Blob은 타입이 존재하는 바이너리 객체! .then((Blob) =&gt; Blob.json()) //이제 이 json 데이터를 위에서 생성한 cities 배열에 push 해주면 기본적인 세팅은 끝! .then((data) =&gt; cities.push(...data)); fetch(endpoint)를 통해 Promise가 resolve됐음 Blob형태의 json 값들이 배열로 반환됨 검색을 통해 해당하는 city 찾기! ❓ 일단 findMatches라는 함수를 생성할건데,filter 조건 내에서 검색창에 입력될 글자는 매번 다를 것이므로 이를 어떻게 변수화 할지가 관건이다.이것을 해결해줄 기능이 바로 “**RegEXP와 match()”**다. RegExp 🔥 정규표현식 = 문자검색, 문자 대체, 문자추출에 주로 사용 new RegExp(표현식, 플래그) match() 🔥 정규표현식에 맞는 문자열을 찾아서 배열 객체**(문자열 형태)**로 반환한다. 12345678function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { // 모든 문자와 여러줄을 영어 대소문자를 구분하지 않고 받아들임 const regex = new RegExp(wordToMatch, 'gi'); // &quot;||&quot;은 or을 뜻한다는 점 복기! return place.city.match(regex) || place.state.match(regex); });} 검색어에 해당하는 city or state 나타내기 💡 우선, 검색창과 검색결과가 보여질 html 요소를 정의해주고,addEventListener를 통해 변화에 따른 함수 실행을 설정하자 1234567// html 요소 정의const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');// addEventListener 사용searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches); displayMatches12345678910111213141516171819202122232425function displayMatches() { // 검색창에 입력된 글을 변수화! const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { // 각 값들에 대한 정의 const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';console.log(endpoint);const cities = [];fetch(endpoint) .then((Blob) =&gt; Blob.json()) .then((data) =&gt; cities.push(...data));function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { const regex = new RegExp(wordToMatch, 'gi'); return place.city.match(regex) || place.state.match(regex); });}function displayMatches() { const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);}const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches);","link":"/javascript/wesbos/06.%20Type%20Ahead/"},{"title":"[Wesbos] 배열 기초체력 다지기2","text":"이번 챕터에서 다룰 기능들 array.some() array.every() array.find() array.findIndex() 주어진 배열1234567891011121314const people = [ { name: 'Wes', year: 1988 }, { name: 'Kait', year: 1986 }, { name: 'Irv', year: 1970 }, { name: 'Lux', year: 2015 },];const comments = [ { text: 'Love this!', id: 523423 }, { text: 'Super good', id: 823423 }, { text: 'You are the best', id: 2039842 }, { text: 'Ramen is my fav food ever', id: 123523 }, { text: 'Nice Nice Nice!', id: 542328 },]; some() 💡 배열 안에서 “특정” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 1234// 최소 한명이라도 19살 이상인 사람이 있는가?const isAdult = people.some(person =&gt; ((new Date()).getFullYear() - person.year &gt;= 19);console.log(isAult); every() 💡 배열 안에서 “모든” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 123456// 모든 사람들이 19세 이상인가?const isEvery = people.every( (person) =&gt; new Date().getFullYear - people.year &gt;= 19);console.log({ isEvery }); find() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소값을 반환 123// ID가 823423인 사람이 쓴 comment는 무엇인가?const findID = comments.find((comment) =&gt; comment.id === 823423);console.log(findID); findIndex() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소의 index값을 반환 123456// ID가 823423인 사람이 쓴 comment를 삭제하시오.const index = comments.findIndex((comment) =&gt; comment.id === 823423);const newComments = [...comments.slice(0, index), ...comments.slice(index + 1)];console.table(newComments);","link":"/javascript/wesbos/07.%20Array%20Cardio2/"},{"title":"Wesbos - Fun with Canvas","text":"🙂 사실 그렇게 자주 사용할것 같지는 않지만, 배워두면 좋을 것 같은 ..?Javascript를 이용한 그리기 도구 기능 구현 챕터다 로직 canvas태그를 통해 그림판을 브라우저에 깔아준다 canvas의 개념적 정의를 ‘2d’로 설정한다 : canvas.getContext(‘2d’) canvas에 이벤트리스너를 부여한다. 캔버스 내에서 마우스 움직임에 따라 그림이 그려질 수 있도록 ctx설정을 한다 (그리기 속성과 위치값 설정) 그림판 깔기canvas 태그 💡 &lt;canvas&gt;&lt;/canvas&gt;와 같은 형태로 쓰이며, id값을 부여해 사용해주는 것이 바람직하다. canvas태그에 id값을 #draw로 부여해뒀다. 이를 활용! 12345const canvas = document.querySelector('#draw');//그림판 캔버스가 브라우저 전체 크기를 차지할 수 있도록 설정canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas태그 불러오기 및 기본설정 (렌더링 컨텍스트) 💡 canvas만 브라우저에 펼쳐져 있다고 그림을 그릴 수 있는게 아니다. **getContext()**를 통해 렌더링 컨텍스트까지 canvas에 노출시켜줘야그리기 함수나 렌더링 컨텍스트 등을 활용할 수 있다. 그리기 도구를 지정해준다고 생각하면 이해하기 편할 것이다. 1const ctx = canvas.getContext('2d'); 이벤트리스너 적용 및 함수 생성 💡 canvas가 이벤트를 감지할 수 있도록 addEventListener와 그에 따른 함수를 생성해줘야 한다. 12//마우스의 움직임을 감지canvas.addEventListener('mousemove', draw); 💡 이제 draw함수를 생성해보자 ! 12//일단 만들어만 놓자function draw() {} ctx를 통한 그리기 속성 세팅 💡 그림을 그려야하기 때문에, 먼저 그리기 도구들을 세팅해주자 ctx세팅을 위한 함수 및 기능들은 아래 표에 정리해두었다. 1234ctx.strokeStyle = '#BADA55';ctx.lineCap = 'round';ctx.lineJoin = 'round';ctx.lineWidth = 50; ctx를 통한 위치값 설정 및 그리기 기능 구현 💡 거의 다 왔다….. 이제 그림을 그릴 수 있도록 xy 좌표값과 그에 해당하는 기본 변수값들을 지정해줘야 한다. 123456789101112131415//마우스를 클릭한 상태로 움직였을 때만 그리기가 가능하도록 isDrawing을 설정해줬다.let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { //마우스를 뗀 상태라면 그려지지 않는다 if (!isDrawing) return; ctx.beginPath(); //새로운 경로가 생성된다. ctx.moveTo(lastX, lastY); //마우스가 눌린 시점의 x,y의 좌표가 입력될 것이다. ctx.lineTo(e.offsetX, e.offsetY); //마우스가 이동한 위치의 좌표가 입력될 것이다. ctx.stroke(); //도형(선 포함)이 그려진다. //마우스 움직임에 따라 lastX와 lastY값 지속적으로 변동 [lastX, lastY] = [e.offsetX, e.offsetY];} 123456789//마우스를 눌렀을 때 x와 y값이 입력되도록 설정!canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});//마우스가 눌려있지 않은 경우에 그리기를 실행하지 않기 위한 설정canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false)); offsetX &amp; offsetY 💡 offsetX : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “x좌표” 위치를 나타냄 offsetY : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “y좌표” 위치를 나타냄 최종 완성 코드123456789101112131415161718192021222324252627282930313233const canvas = document.querySelector('#draw');const ctx = canvas.getContext('2d');canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = '#BADA55';ctx.lineJoin = 'round';ctx.lineCap = 'round';ctx.lineWidth = 50;let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { if (!isDrawing) return; ctx.beginPath(); ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.moveTo(lastX, lastY); ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke(); [lastX, lastY] = [e.offsetX, e.offsetY];}canvas.addEventListener('mousemove', draw);canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false));","link":"/javascript/wesbos/08.%20Fun%20with%20Canvas/"},{"title":"Wesbos - Dev Tools (개발자 도구)","text":"Interpolated'hello %s', 'hoonjoo' 12console.log(&quot;hello my name is %s What's your name?&quot;, 'hoonjoo');// 결과값 : hello my name is hoonjoo What's your name? Styled12345// CSS를 컨트롤 할 수도 있다!console.log( '%c I can change my style by this', 'font-size : 50px; color : #BADA55'); warning 12// 콘솔 창에 경고 표시를 할 수 있음console.warn('stop'); error 12// 콘솔 창에 오류 표시를 할 수 있음console.error('stop'); Info1console.info(''); Testing1assert(1 === 1, 'That's Wrong!') Cleaning1console.clear(); Grouping Together123456789dogs.forEach(dog ⇒ {console.group(``${dog.name}``)console.log(`${dog.name} is ${dog.old} years old`)console.groupEnd(`${dog.name}`);}); count1console.count(); time12// 불러오는데 얼마나 걸리는지?console.time();","link":"/javascript/wesbos/09.%20Dev%20Tools/"},{"title":"Wesbos - Hold Shift Button to Check","text":"정말 자주 쓰일 것 같은 기능이다. 첫 번째 체크박스를 클릭하고 쉬프트를 누른 뒤아래에 있는 임의의 박스를 클릭하면 그 사이에 있는 체크박스들이 함께 체크된다. 네이버에서도 사용! 로직 체크박스를 변수화해 지정한다. (const) click 이벤트를 위한 addEventListener + 함수 생성 lastChecked와 inBetween을 선언하여 플래그값으로 활용 ⭐️ 체크박스 지정하기 💡 거의 가장 먼저 하는 것은 const를 통해 사용할 객체를 변수화 하는 것이다. 1const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]'); addEventListener + 함수 생성 💡 여기서 사용할 것은 click 이벤트다.이 챕터를 진행하기 전이었다면, keyCode를 활용해 keydown등의 이벤트를 사용했을텐데…‘e.shiftKey’를 사용할 수 있더라 0_0; 12345// 이벤트리스너checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));//함수 생성function checkIt(e) {} 플래그 활용 다른 것들은 어렵지 않은데…. 이 부분이 참 생소하고 어려웠다 ㅜㅜ lastChecked 💡 제일 최초로 체크된 박스를 저장하기 위한 플래그다. 12// Boolean값 없이 선언만 해준다let lastChecked; inBetween 💡 최초 체크박스와 쉬프트를 누른채 클릭한 체크박스 사이에 있는 박스들을 인식하기 위한 플래그! 12345678910111213141516171819function checkIt(e) { //사이에 있는 놈인가? false let inBetween = false; //만약 쉬프트키가 눌려져 있고, 현재 체크 박스가 체크됐다면? if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { // 방금 눌린 것 or 최초로 눌린 것 = inBetween 아님! if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } // inBetween이면 checked되게 하라 if (inBetween) { checkbox.checked = true; } }); } // 처음 눌린 놈! lastChecked = this;} 최종 완성 코드12345678910111213141516171819202122const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]');//lastChecked 변수를 부여let lastChecked;function checkIt(e) { //사이에 있는가? =&gt; 일단 false let inBetween = false; //여기서 e는 click 이벤트다, 그리고 this는 &lt;input type=&quot;checkbox&quot;&gt;임!! if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } if (inBetween) { checkbox.checked = true; } }); } lastChecked = this;}checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));","link":"/javascript/wesbos/10.%20Hold%20Shift%20Button%20to%20Check/"},{"title":"Wesbos - Custom Video Player","text":"사실 요즘은 자체적으로 이렇게 동영상 플레이어를 구현하는 것이 아니라,유튜브와 같은 플랫폼에 이미 업로드 되어있는 영상을 불러오는 형식을 더 자주 사용하기 때문에, 실용적인 챕터일까? 라는 생각을 하기도 했다. 하지만…JS를 통해 CSS적인 요소를 컨트롤 하는 부분과 valueChange를 하는 등의 연습은 큰 도움이 됐던 것 같다. 로직 다양한 객체들 const로 정의 이벤트 리스너 (재생버튼, 프로그레스바, 볼륨바, 속도바, 스킵버튼) 재생 기능과 CSS 제어 프로그레스바 구현 볼륨 컨트롤 구현 속도 설정 구현 스킵버튼 구현 Const!! 💡 이번 챕터에선 정의해줘야 할 객체들이 많다…. 1234567const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider'); 이벤트리스너 💡 구현해야 할 기능들이 많기 때문에… 이벤트 또한 역시나 많다… 123456789101112131415//재생&amp;일시정지 버튼toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);//비디오 뷰어 내에 있는 버튼과 프로그레스바video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);// 프로그레스바, 사운드, 속도 등등의 value값 제어를 위한 것ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));//스킵버튼skipButtons.forEach((button) =&gt; button.addEventListener('click', skip)); 재생과 버튼 업데이트 💡 재생 버튼을 누르면 재생이 되고, 버튼 아이콘도 변경되어야 한다. 필자는 if문을 쓰는게 더 쉽고 간편할 것 같아서…if문을 통해 재생 및 일시정지, 그리고 재생버튼 업데이트 기능을 구현해봤다. ❗ 재생버튼 뿐만 아니라, 유튜브와 같이 비디오 플레이어 화면을 클릭했을 때도 재생 또는 일시정지가 될 수 있도록 구현하기 위해 pause함수가 video와 toggle에도 작동할 수 있도록 이벤트리스너를 작성했다. 12345678910111213141516171819202122//puase함수function pause() { //비디오가 정지되어 있으면 플레이 if (video.paused) { video.play(); } //아니면 일시정지 else { video.pause(); }}function updateButton() { // 정지되어 있으면 재생 아이콘이, if (video.paused) { toggle.textContent = '►'; } // 재생중이면 일시정지 아이콘이 나타나도록 설정 else { toggle.textContent = '❚ ❚'; }} 그 외 기능들123456789101112131415161718// 볼륨과 속도바function valueChange() { //volume or playBackRate = this.value가 되는 것! video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;} 최종 완성 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider');function pause() { if (video.paused) { video.play(); } else { video.pause(); }}function updateButton() { if (video.paused) { toggle.textContent = '►'; } else { toggle.textContent = '❚ ❚'; }}function valueChange() { video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;}toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));skipButtons.forEach((button) =&gt; button.addEventListener('click', skip));let mousedown = false;progress.addEventListener('click', scrub);progress.addEventListener('mouseup', (e) =&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener('mousedown', () =&gt; (mousedown = true));progress.addEventListener('mousemove', () =&gt; (mousedown = false));","link":"/javascript/wesbos/11.%20Custom%20Video%20Player/"},{"title":"Wesbos - 코나미 코드","text":"코나미 코드…? 💡 게임이나 웹사이트 내에 개발자가 숨겨둔 “이스터에그” 같은 것이라고 생각하면 된다. 로직 키보드 입력을 감지할 이벤트리스너 + 함수 생성 배열 생성하기 특정한 문자열이 입력됐을 때 이스터에그 발생되도록 설정 이벤트리스너 💡 이 부분은 쉽다.**’keyup’**을 listen할 수 있도록 설정하고 그에 따른 함수를 생성해보자 1234567// 'keyup'을 감지해야 할 것은 window 전체!window.addEventListener('keyup', easterEgg);// 키가 잘 찍히는지 콘솔창을 통해 확인해보자function easterEgg(e) { console.log(e.key);} 잘 된다!! 배열 생성 💡 내가 입력한 키값들이 저장될 수 있도록 배열을 활용해보자. 12345678910const pressed = [];// 배열에 잘 저장되는지 테스트도 해보기!function easterEggg(e) { pressed.push(e.key); console.log(pressed);}//근데... 무한으로 배열에 키가 저장되면 비효율적이니까 MAXIMUM 길이를 정해주자. (splice 활용) 잘 된다! splice() ⭐ 배열의 기존 요소를 삭제, 교체, 추가 하며 배열의 내용을 변경할 수 있도록 하는 메서드! 123456//기본 문법array.splice(index, deleteCount, item);//deleteCount를 0으로 지정하면 insert!//item 지정하지 않으면 삭제만 수행함 시크릿코드 생성 💡 진부하지만… 일단 편의상 ‘hoonjoo’로…!! 1const secretCode = 'hoonjoo'; 이스터에그 실행 💡 배열에 ‘hoonjoo’가 포함된다면 이스터에그 실행되도록 할 것임! 1234567891011function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!'); //이건 그냥 자바스크립트에서 제공하는 플러그인인 것 같다. cornify_add(); }} 최종코드1234567891011121314const pressed = [];const secretCode = 'hoonjoo';function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!!'); cornify_add(); }}window.addEventListener('keyup', easterEggg);","link":"/javascript/wesbos/12.%20Konami/"},{"title":"Wesbos - 스크롤 → 슬라이드인","text":"진~~~짜 유용하게 잘 쓰일 것 같은 챕터다.스크롤을 내리면 비어있던 이미지들이 위치에 맞게 슬라이드 인 되는 기능이다. 🤔 그동안은 클릭이나 키다운에 의한 이벤트 함수를 생성했었는데,이번 챕터에서는 스크롤한 위치에 따른 기능실행이라는 점이 신선했던 것 같다. 로직 const eventListener + 함수생성 offset값을 활용한 위치값 불러오기 const!1const slideIn = document.querySelectorAll('.slide-in'); 이벤트리스너와 함수12345function slide(e) { console.log(e);}window.addEventListener('scroll', slide); 하지만, 이렇게 둘 경우 너무 자주 함수(slide)가 실행되어 비효율적일 수 있다. 1234567891011121314151617181920//미리 입력되어 있던 debounce 함수 모듈을 활용해보자function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}//slide함수에 적용될 수 있또록 감싸주자window.addEventListener('scroll', debounce(slide)); offset 값을 활용! 💡 scrollY : 세로로 스크롤이 몇 px만큼 움직였는지 알 수 있음 💡 innerHeight : 현재 뷰포트의 세로값(px)을 알 수 있음 어느 위치를 기준으로 이미지가 슬라이드 인 되어야 할까? 🤔 이미지의 세로 중간 쯤 뷰포트 바텀라인이 도착하면 슬라이드인 되도록 하는 것이 자연스러울 것 같다. 💡 그럼 ! 일단 현재 얼마나 스크롤 됐는지에 대한 값을 불러오는 변수를 설정해주자. 얼마나 스크롤 됐는지?❗ 뷰포트 바닥을 기준으로 계산을 할 것이다. (상단 기준이면 scrollY만 있어도 됨) 123// 스크롤한 만큼의 Y값(px) + 뷰포트의 Y길이(px)const slideAt = window.scrollY + window.innerHeight;console.log(slideAt); 이미지의 바닥 위치12// 떨어진 거리 + 이미지박스 높이 = 이미지 바닥의 위치const imageBottom = slideImage.offsetTop + slideImage.height; offsetTop? 💡 부모의 상단 보더로부터 자신의 상단 보더가 떨어진 만큼의 거리! 슬라이드인 조건들스크롤이 이미지의 절반까지 위치했는가?1const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; 화면에서 이미지가 이미 지나쳐갔는가?12// 이미지가 스크롤되어 지나쳐, 이미 화면에서 안보이는데 굳이 띄워둘 필요는 없음!const isPassed = window.scrollY &lt; imageBottom; 이제 이미지를 위의 두 조건이 아닐 경우에는 이미지가 슬라이드 아웃 되도록 해주면 된다. 최종 코드123456789101112131415161718192021222324252627282930313233343536function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}const slideIn = document.querySelectorAll('.slide-in');function slide(e) { slideIn.forEach((slideImage) =&gt; { const slideAt = window.scrollY + window.innerHeight; console.log(slideAt); console.dir(slideImage); // bottom of the image const imageBottom = slideImage.offsetTop + slideImage.height; const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; const isPassed = window.scrollY &lt; imageBottom; if (isHalfShown &amp;&amp; isPassed) { slideImage.classList.add('active'); } else { slideImage.classList.remove('active'); } });}window.addEventListener('scroll', debounce(slide));","link":"/javascript/wesbos/13.%20Scroll_SlideIn/"},{"title":"Wesbos - 배열 참조 vs 복사","text":"참조와 원본 간의 관계 num, string, boolean값들의 참조 변수는 앞에 선언된 것을 우선시한다. 12345678age = 100;age = age2;console.log(age, age2); // 100 100//하지만 여기서 age값을 바꿔주면age = 200;console.log(age, age2); // 200 100 이 결과값으로 도출된다. 하지만!!! 배열에선 다르다 💡 위에선 참조와 원본이 다르게 처리됐지만, 배열에선 참조를 변경 시 원본에 영향을 준다. 1234567const players = ['hoonjoo', 'chanjoo', 'jaeseong', 'hyobum'];const team = players;team[1] = 'saeeun';//team = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum'];//players = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum']; 그렇다면, 배열에서 원본에 영향을 주지 않고 참조를 변경하는 방법은 없을까? array.slice() 💡 앞에서 배웠던 것과 같이, slice()를 사용하면 배열의 복사본을 만든다. concat(array) 💡 [].concat(array)를 사용해서 빈 배열에 기존 배열을 합치는 식의 복사를 할 수도 있다. spread 💡 newArray = […orgArray]; 와 같은 방식을 사용할 수도 있다. Array.from() 💡 newArray = Array.from(orgArray); 복사와 원본 간의 관계object.assign() 💡 특정 객체를 “얕게” 복사함 object.assign({}, 복사할 객체) assign을 통해 복사를 할 경우,이는 얕은 복사이기 때문에 한 층에 대한 변경은 원본 배열 객체에는 영향을 주지 않는다! 하지만, 더 깊은 층에 대한 변경은 원본 배열에도 영향을 준다 예시123456789101112131415161718192021const hoonjoo = { name: 'hoonjoo', country: 'Korea', social: { twitter: '@hoon', instagram: '#hooonjooo', },};const second = object.assign({}, hoonjoo);// 이 경우 원본 배열에는 영향 주지 않음 (원본 : Korea, 복사본 : USA)second.country = 'USA';//하지만....// 이 경우 social의 층이 깊기 때문에 원본 배열에도 영향을 준다second.social.instagram = '$hooonjooo';//따라서 이 두 결과값은 동일하다hoonjoo.social;second.social; 그렇다면 딥 클론을 할 수 있는 방법은? 편법!!1const second = JSON.parse(JSON.stringify(hoonjoo));","link":"/javascript/wesbos/14.%20Array_Copy/"},{"title":"Wesbos - 로컬스토리지 &amp; 이벤트 위임","text":"로컬스토리지의 활용법과 이벤트 위임이라는 굉장히 유용한 기능을 배울 수 있는 챕터였다. (어려웠지만….. ㅋㅋ) 물론 mongoDB와 같은 DB를 사용하면 크게 사용할 일은 없겠지만, 간단한 웹서비스 등을 만들 때에는 유용할 것 같다. 로직 사용할 객체들 변수화 하기 (const) + 이벤트리스너와 함수 생성 &lt;input&gt;에입력한 값을 인식할 수 있도록 함수 설정 add item(submit)을 누르면 가 append! append된 요소들이 로컬스토리지에 저장 되도록 설정 체크박스의 체크 유무 또한 로컬 스토리지에 저장 되도록 설정 (위임도 필요) 삭제 기능 추가 const 선언 💡 Add item버튼, html에 추가될 아이템 ul, 아이템 배열을 생성하여 변수화해준다. 123const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const items = []; addEventListener1234567function addItem(e) { e.preventDefault(); //잘 작동하는지 확인! console.log('hi');}addItems.addEventListener('submit', addItem); event.preventDefault() 💡 페이지의 이동 또는 리로드가 실행되지 않도록 막아준다! ⇒ 이 챕터에선 submit을 눌러도 페이지가 새로고침되지 않고 submit만 될 수 있도록 하기 위해 사용 &lt;input&gt;에 입력한 텍스트 인식 💡 &lt;input&gt; 에 입력한 값이 잘 불러와질 수 있도록 addItem 함수를 수정보완 1234567891011121314function addItem(e) { e.preventDefault(); // 입력된 값을 text로 변수화 text = this.querySelector('[name=item]').value; // 객체 생성 item = { text: text, done: false, }; //찍어보기 console.log(item); // 미리 생성한 배열인 items에 item을 push} 미리 생성한 배열인 items에 item을 push!123456789function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item);} setItem() 💡 로컬스토리지 객체에 접근하여 항목 하나를 추가한다 ⭐️JSON.stringify()⭐️ 💡 JavaScript값이나 객체를 JSON형태의 문자열로 변환한다. (배열 자체가 문자열이 되어 반환된다고 생각하면 편할듯?) 12console.log(JSON.stringify({ x: 5, y: 6 }));// 예상 결과값 : &quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot; 버튼 누르면 → 아이템(&lt;li&gt;) append! 💡 우선 appendList라는 함수를 생성해주자. 1234567891011121314function appendList(plates = [], platesList) { platesList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${ plate.done ? 'checked' : '' } /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join(''); // map에 의해서 콤마(,)가 append될 때마다 붙기 때문에 이를 제거하기 위해 join을 사용!} localStoragegetItem() 💡 로컬스토리지 내에서 항목을 읽어냄 ⭐️JSON.parse()⭐️ 💡 문자열로 구성된 JSON을 JavaScript값이나 객체로 반환한다. 문자열 → JavaScript 객체 123456789101112131415161718// 로컬 스토리지에 저장된 메뉴가 있으면 불러오고, 없으면 빈 배열!const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); // input박스에 입력될 텍스트를 변수화 const text = this.querySelector('[name=item]').value; const item = { text: text, // 체크박스에 활용할 Boolean값 done: false, }; items.push(item); populateList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();} 체크 유무 저장 💡 위의 items 객체에서 설정한 done의 boolean값을 저장하여체크박스의 체크 유무를 새로고침해도 유지될 수 있도록 설정 12345678function toggleDone(e) { if (!e.target.matches('input')) return; // input 태그가 아니면 종료 (label도 찍힐 수 있기 때문) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; // 반대값 설정 트릭 ! localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);} 삭제기능 추가 💡 wrapper 하단에 Clear All 버튼을 만들어 준 뒤, localStorage.removeItem() 을 사용해서 삭제기능을 구현하면 된다. removeItem() 💡 로컬 스토리지에서 항목 하나를 제거한다. 1234567891011// 클리어 버튼 변수화const clear = document.querySelector('.clear');function removeAll() { localStorage.removeItem('items'); // removeItem은 로컬스토리지 삭제 기능만 하기 때문에, li가 제거될 수 있도록 새로고침을 해준다. location.reload();}// 클릭 이벤트 &amp; 함수 할당clear.addEventListener('click', removeAll); 최종 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const clear = document.querySelector('.clear');const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item); appendList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();}// 원본 훼손을 최대한 방지하기 위해 items 복사!function appendList(plates = [], plateList) { plateList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;items${i}&quot; ${ plate.done ? 'checked' : '' }/&gt; &lt;label for=&quot;items${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join('');}function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);}function removeAll() { localStorage.removeItem('items'); location.reload();}clear.addEventListener('click', removeAll);addItems.addEventListener('submit', addItem);itemsList.addEventListener('click', toggleDone);appendList(items, itemsList);","link":"/javascript/wesbos/15.%20LocalStorage/"},{"title":"Wesbos - Mouse Move Shadow","text":"mousemove 이벤트가 일어날 때마다해당 텍스트의 그림자가 마우스 위치로 이동하는 기능을 구현하면 된다. 로직 const와 함수 생성 및 할당 마우스 offset값 활용 해당 값을 style.textShadow에 적용! const와 함수 생성 및 할당 💡 마우스가 움직일 공간인 뷰포트와 h1태그를 변수화 한 후, 함수를 생성해준다. 123456789const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { // 확인해보기! console.log(e);}hero.addEventListener('mousemove', shadow); offsetX &amp; offsetY 값의 활용 💡 canvas 챕터에서 사용했었던 offset값을 다시 활용해보자. 1234function shadow(e) { let { offsetX: x, offsetY: y } = e; console.log(x, y);} 하지만… hero 안에 자식요소로 &lt;h1&gt; 태그가 존재하기 때문에text위에 마우스를 올리면 자식요소에 대한 offset값이 출력된다. 🤔 X축에 대해선 offsetLeft를, Y축에 대해선 offsetTop을 활용하면 된다. 123456789function shadow(e) { let { offsetX: x, offsetY: y } = e; // 즉, 뷰포트인 hero가 타게팅되고 있지 않다면~ if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; }} offset 값을 px로 반환하여 활용 💡 기본 단위를 선언 ⇒ 픽셀 값으로 반환하여 적용 12345678910111213141516function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } // 내가 마우스를 움직인 만큼의 거리가 뷰포트 내에서 몇 퍼센트인지 xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; // 위의 값을 css에 적용! text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;} 최종 완성 코드1234567891011121314151617181920const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this != e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;}hero.addEventListener('mousemove', shadow);","link":"/javascript/wesbos/16.%20Mouse%20Move%20Shadow/"},{"title":"Wesbos - 배열 조건부 정렬","text":"보통 가수 이름이나, 노래 제목 등을 정렬할 때관사 The, a, an 등은 참조하지 않은 채로 정렬을 한다고 한다. 이를 바탕으로 sort() 등을 활용해 정렬해보자. 로직 정렬에 조건 걸기 (/ ^(a | the | an)/) 정렬하기 sort() 정렬된 것 ul에 넣어주기 innerHTML 참조한 관사 (A, The, An)에만 CSS값 주기 정렬에 조건 걸기 💡 굉장히 새로운 내용이었다. 내가 제거하고 싶은 부분들을 제거해서 배열을 새로 만든 다음에, 이것을 기준으로 정렬한다는 것이 참신했다. 우선, bands 배열 내에 있는 오브젝트들의 관사를 제거해주는 함수를 만들어보자. 12345678// bandName 인자가 들어오면 -&gt; a, the, an을 제거하고 양 옆 공백을 삭제하여 반환해준다.function strip(bandName) { return bandName.replace(/^(a |the |an )/i, '').trim(); // 반드시 | 뒤에 공백이 없어야 한다. 공백까지 인식해버림..}console.log(strip('the hoonjoo Park'));// 잘 기능하는지 찍어보기 string.trim() 💡 문자열에서 양 옆에 있는 공백을 제거해준다. 정렬하기 💡 기초체력 다지기에서 공부했듯이, sort() 를 사용하면 된다. 12// 코드는 항상 최대한 간결하게 !!const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1)); 정렬한 것 화면에 띄우기123const bandUl = document.querySelector('#bands');bandUl.innerHTML = sortedBands.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 참조한 관사 (A, The, An)에만 CSS값 주기 💡 Type Ahead 챕터에서 사용했던 정규식 RegExp() 를 활용해봤다. 우선… 새로운 특정 관사가 &lt;span class=&quot;hl&quot;&gt;&lt;/span&gt; 로 replace될 수 있도록 해보자 12345678910111213// map을 통해 새로운 배열을 생성해야 하므로 anThe를 만들어서 써보자const anThe = sortedBands.map((node) =&gt; { // 첫 문자 &amp; 대소문자를 구분하는 regex 생성 const regex = new RegExp(/^(A |The |An )/g); // 노드 내에서 regex와 일치하는 (A The An)을 matchRegex에 할당 const matchRegex = node.match(regex); // replace를 통해 해당 regex값이 &lt;span&gt;태그가 붙은 형태로 바뀌어질 수 있도록! const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;}); 최종 완성 코드12345678910111213141516171819202122232425262728293031323334const bands = [ 'The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil', 'Norma Jean', 'The Bled', 'Say Anything', 'The Midway State', 'We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive', 'Anywhere But Here', 'An Old Dog',];const bandUl = document.querySelector('#bands');function strip(bandName) { return bandName.replace(/^(a |the |an)/i, '').trim();}const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1));const anThe = sortedBands.map((node) =&gt; { const regex = new RegExp(/^(A |The |An )/g); const matchRegex = node.match(regex); const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;});const appendBand = anThe.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join('');bandUl.innerHTML = appendBand;","link":"/javascript/wesbos/17.%20SortArray/"},{"title":"Wesbos - reduce와 map 응용","text":"[data-time]에 저장되어 있는 시간 값들의 총합을 구하여 비디오의 총 러닝타임을 구해보자 로직 const를 통해 사용할 요소 선언 map과 split을 통해 값 정제 reduce()를 통해 총합 구하기! 시간들을 수학적 계산을 통해 알맞게 전환 const 선언부터… 💡 이번 챕터에선 간단하게 &lt;li&gt; 태그들만 선언 해줘도 된다. 12345// nodelist로 표현되긴 하지만, 실제 배열은 아니기 때문에 배열에 집어넣어줘야 함!const timeNodes = Array.from(document.querySelectorAll('[data-time]'));console.log(timeNodes); map과 split을 통해 시간값 정제 💡 우선… 원활한 계산을 위해 [분 : 초]의 형식에서 “:”을 제거해주고 정수화시켜줘야 될 것 같다. dataset.time🤔 태그 내에 [data-OOO]이 저장되어 있다면, dataset.OOO 을 통해 그 값을 불러올 수 있다. 12345678910const seconds = timeNodes // 노드들은 이제 data-time에 적힌 값이 됐음 .map((node) =&gt; node.dataset.time) // 이것을 timeCode라고 하고, :을 기준으로 나눠서 왼쪽은 mins, 오른쪽은 secs로 할당 .map((timeCode) =&gt; { // 정수화!! const [mins, secs] = timeCode.split(':').map(parseFloat); // mins는 분 형식이니까 초 값으로 만들려면 곱하기 60! return mins * 60 + secs; }); reduce를 사용하여 총합 구하기123.reduce((acc, current) =&gt; acc + current);console.log(seconds); 계산 → “시 : 분 : 초”로 나타내기 💡 시 → 분 → 초 순서대로 계산을 해보자한 시간은 3600초… 1234567891011// secondsLeft를 활용해서 계속 남은 초를 계산let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);// 3600초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);// 60초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft); 최종 완성 코드123456789101112131415161718192021const timeNodes = Array.from(document.querySelectorAll('[data-time]'));const totalTime = document.querySelector('p');const seconds = timeNodes .map((node) =&gt; node.dataset.time) .map((timeCode) =&gt; { const [mins, secs] = timeCode.split(':').map(parseFloat); return mins * 60 + secs; }) .reduce((acc, current) =&gt; acc + current);let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft);totalTime.innerHTML = `&lt;span&gt;${hours}시간 ${minutes}분 ${secondsLeft}초&lt;/span&gt;`;","link":"/javascript/wesbos/18.%20Reduce_Map/"},{"title":"Wesbos - Canvas를 활용한 웹캠제어","text":"이런 것도 가능하다니…웹캠을 제어하는 것도 JS와 라이브러리를 통해 구현할 수 있다는게 신기하고 재밌었다. 로직 필요한 HTML태그 정리와 선언 webcam 불러오기 캔버스설정과 캔버스에 영상 띄우기 사진 찍기 기능! 필요한 HTML 태그 💡 &lt;canvas&gt;, &lt;video&gt;, &lt;audio&gt; 태그들이 필수적으로 필요하다. &lt;canvas&gt; 와 &lt;audio&gt;는 왜???⇒ 캔버스는 웹캠 화면에서 다양한 색상 또는 픽셀 등을 다루기 위해서 필요한 것! ⇒ 오디오는 “찰칵소리“의 구현을 위해 필요 123456// 선언const video = document.querySelector('.player');const canvas = document.querySelector('.photo');const ctx = canvas.getContext('2d');const strip = document.querySelector('.strip'); // 찍은 사진이 display될 공간const snap = document.querySelector('.snap'); // &quot;찰칵!&quot; 웹캠 불러오기navigator.mediaDevices.getUserMedia() 💡 getUserMedia()는 사용자에게 미디어 입력장치 사용 권한을 요청! ⇒{video : true, audio : false} 와 같이 설정해주면 됨 ⭐️ 이는 프로미스를 반환한다 ⭐️ 123456789function getvideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((MediaStream) =&gt; { console.log(MediaStream); });}getvideo(); 그럼 이제 촬영되고 있는 화면을 어떻게 브라우저에 띄울 수 있을까? 💡 video 태그에 srcObject값을 부여해주면 된다! 1234567891011121314function getVideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((localMediaStream) =&gt; { video.srcObject = localMediaStream; // 위에 보이다시피 localMediaStream은 blob형태라서 scrObject를 사용해서 DOMSTRING형태로 주소를 부여해줘야한다. video.play(); }) .catch((error) =&gt; { console.error('카메라 로드 실패', error); });}video.addEventListener('canplay', paintToCanvas); // 미디어 사용이 준비됐을 때 해당 함수 실행! 캔버스 설정 💡 주의해야 할 점은, 시각효과를 정확하게 적용하기 위해선 캔버스 크기(넓이, 높이)와 비디오 크기가 같아야 한다는 것이다. 1234567891011function paintToCanvas() { const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt; { // 왼쪽 위 모두 0에서 시작, 넓이와 높이는 위의 값과 동일 ctx.drawImage(video, 0, 0, width, height); }, 16); // 16밀리세컨즈} 참고로 필자는 웹캠과 캔버스의 좌우반전이 좀 거슬려서 캔버스와 비디오에 각각transform:rotateY(180deg); 값을 부여했다. 사진 찍기 기능! 💡 toDataURL, setAttribute, insertBefore에 대한 이해가 필요하다. canvas.toDataURL() 💡 캔버스에 그려진 이미지를 base64형태 (이미지가 스트링으로 구성)로 변환해준다. link.setAttribute() 💡 해당 링크의 (메서드, 형태) 등을 설정할 수 있다. insertBefore() 💡 다음에 추가될 노드가 자식노드와 같이 아래로 쌓여진다. 123456789101112function takePhoto() { // 사진 찍는 소리를 구현해주고 snap.currentTime = 0; snap.play(); const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'photo'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;hoonjoo&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);} 최종 완성 코드12345678910111213141516171819202122232425262728293031323334353637383940414243const video = document.querySelector('.player');const canvas = document.querySelector('.photo');const ctx = canvas.getContext('2d');const strip = document.querySelector('.strip');const snap = document.querySelector('.snap');function getVideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((localMediaStream) =&gt; { video.srcObject = localMediaStream; video.play(); }) .catch((error) =&gt; { console.error('카메라 로드 실패', error); });}function paintToCanvas() { const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt; { ctx.drawImage(video, 0, 0, width, height); }, 16);}function takePhoto() { snap.currentTime = 0; snap.play(); const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'photo'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;hoonjoo&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);}getVideo();video.addEventListener('canplay', paintToCanvas);","link":"/javascript/wesbos/19.%20CanvasAndWebCam/"},{"title":"Wesbos - 음성인식","text":"음성인식 라이브러리를 통해 내 말을 자동으로 받아쓰여지도록 구현해볼 수 있다 ! 로직 라이브러리 불러오기 및 기본설정 (window.SpeechRecognition) addEventListener ⇒ 이벤트 수신과 메서드 태그 형태로 append 라이브러리 불러오기 및 기본설정! 💡 SpeechRecognition이라는 웹 라이브러리를 사용한다. (크롬, 엣지) 파이어폭스에선 window.webkitSpeechRecognition 이 사용된다. 사용법const OOOO = new SpeechRecognition(); 12345678910// 브라우저 호환성을 위해 두 개의 라이브러리를 선언window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;const recognition = new SpeechRecognition();// interimResults = false로 줄 경우, 문장이 아닌 단어만을 인식한다.recognition.interimResults = true;// 'en-US'도 가능!recognition.lang = 'ko-KR'; 이벤트리스너 💡 result = 결과값이 도출될 경우 123456789recognition.addEventListener('result', e =&gt; { const transcript = Array.from(e.results) .map(result =&gt; result[0]) // 제일 첫번째에 results, transcript 담겨있음 .map(result =&gt; result.transcript) .join(''); };})recognition.addEventListener('end', recognition.start); 우리에게 필요한건 results의 transcript! p태그로 append!1234567891011121314151617let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); // .words의 자식요소로 넣기recognition.addEventListener('result', (e) =&gt; { const transcript = Array.from(e.results) .map((result) =&gt; result[0]) .map((result) =&gt; result.transcript) .join(''); p.textContent = transcript; // 만약 말이 끝났으면, 다시 p태그를 생성 -&gt; 음성 인식 -&gt; 인식된 결과 붙여넣기 if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }}); 덮어쓰기 → 줄글 형태로 쭉 쓰기 최종 완성 코드1234567891011121314151617181920212223242526window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;const recognition = new SpeechRecognition();recognition.interimResults = true;recognition.lang = 'ko-KR';let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p);recognition.addEventListener('result', (e) =&gt; { const transcript = Array.from(e.results) .map((result) =&gt; result[0]) .map((result) =&gt; result.transcript) .join(''); p.textContent = transcript; if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }});recognition.addEventListener('end', recognition.start);recognition.start();","link":"/javascript/wesbos/20.%20Voice/"},{"title":"Wesbos - 나침반과 속도계","text":"처음으로 Xcode를 사용해봤다.navigator.geolocation 을 활용한 지리적 정보를 통해 방향과 속도를 측정해볼 수 있었다. 로직 Xcode &amp; 시뮬레이터 실행 시뮬레이터를 통해 html파일 실행 사용할 HTML요소 선언 (const) 지리적 정보 API 불러오기 geolocation.watchPosition() 방향 정보와 속도 정보 받아와서 append Xcode와 시뮬레이터 세팅 💡 Xcode 설치 ⇒ 시뮬레이터 실행! 시뮬레이터 실행과 기종 선택 시뮬레이터를 통해 html파일 실행 💡 내장된 package.json파일을 terminal을 통해 실행시켜서npm install → npm start를 입력해준다. 첫 번째 External URL을 시뮬레이터에 입력하여 접속 index-START.html 파일 실행사파리에서 시뮬레이터 디버깅 하는 법 (f12) 사파리 환경설정에 들어가 ‘고급설정’에서 메뉴 막대에서 “개발자용 메뉴보기” 설정 const 선언 💡 나침반에 들어간 arrow와 속도값만 선언해주면 된다. 12const arrow = document.querySelector('.arrow');const speedValue = document.querySelector('.speed-value'); 지리적 정보(geolocation) API 💡 navigator.geolocation.watchPosition() 을 사용한다. geolocation 디바이스의 위치정보를 가져올 수 있도록 하는 인터페이스 watchPosition() 디바이스의 위치가 변경될 때마다 호출하는 콜백을 등록한다. 123navigator.geolocation.watchPosition((data) =&gt; { console.log(data);}); 🔥주의사항!!! 💡 반드시 features에 들어가 위치설정을 해줘야한다. 그렇지 않으면 heading이나 speed값이 null값으로 나타나기 때문 방향 정보와 속도 정보 활용 💡 위에서 찍어본 data 내에서 필요한 정보를 활용하면 된다 ! heading , speed 1234567891011navigator.geolocation.watchPosition( (data) =&gt; { console.log(data); speedValue.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`; }, (err) =&gt; { console.error(err); alert('위치정보 접근을 허용해주세요!'); }); 최종 완성 코드1234567891011121314const arrow = document.querySelector('.arrow');const speedValue = document.querySelector('.speed-value');navigator.geolocation.watchPosition( (data) =&gt; { console.log(data); speedValue.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`; }, (err) =&gt; { console.error(err); alert('위치정보 접근을 허용해주세요!'); });","link":"/javascript/wesbos/21.%20Direction/"},{"title":"Wesbos - 따라다니는 하이라이트","text":"추후에 드롭다운 메뉴 등에 활용할 수 있을 것 같은 기능이다.원래 나였으면 CSS값을 add하고 remove하는 방식을 썼을 것 같은데, 이번 챕터에선 하이라이터가 마우스가 올라간 객체의 위치값을 활용해서 하이라이팅한다. 로직 HTML, CSS값 선언 및 할당 (const) 스크롤 했을 때를 가정하여 위치값 설정 (window.scrollY) 이벤트리스너와 함수 생성 (mouseenter) 마우스가 올라간 객체의 위치값 활용 getBoundingClientRect() const 선언부터… 💡 태그에 하이라이팅을 할 것이므로 ⇒ a태그를 선언 + 하이라이팅 요소(span)를 생성해주기 주의‼️ 원래는 CSS값을 add하고 remove하는 방식이지만,여기선 하이라이트 요소를 만들어놓고 → 요놈을 움직이고 크기를 조절하며 하이라이팅 함 1234567const triggers = document.querySelectorAll('a');// 하이라이트는 &lt;span&gt;을 사용할 것const highlight = document.createElement('span');// 미리 설정해둔 CSS값을 &quot;하이라이트 span에&quot; 적용highlight.classList.add('highlight');// 일단 그냥 띄워두기document.body.append(highlight); 이벤트리스너와 함수 생성 💡 mouseenter을 활용 mouseenter vs mouseover mouseover : 자식요소에까지 이벤트가 할당됨 12345function highlightLink() { console.log(this);}triggers.forEach((a) =&gt; a.addEventListener('mouseenter', highlightLink)); 위치값을 활용한 하이라이트 💡 여기서부턴 처음 사용해보는 메서드를 활용해야한다. Element.getBoundingClientRect() 뷰포트를 기준으로 한 상대적 엘리먼트의 위치와 사이즈를 포함하는 DOMRect를 리턴해준다. highlight의 너비와 위치가 동적으로 변할 수 있도록 설정12345678function highlightLink() { const linkCoords = this.getBoundingClientRect(); console.log(linkCoords); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; highlight.style.left = `${linkCoords.left}px`; highlight.style.top = `${linkCoords.top}px`;} 스크롤값을 반영 하지만… 스크롤을 내리면 아래와 같이 스크롤을 내리기 전 위치값으로 이동되기 때문에 highlight의 위치값에 스크롤 이동에 따른 변화값을 추가해줘야된다. 12345678910function highlightLink() { const linkCoords = this.getBoundingClientRect(); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; // top, left 값에 각각 스크롤한 만큼의 값을 더해줌! const scrollY = linkCoords.top + window.scrollY; const scrollX = linkCoords.left + window.scrollX; highlight.style.left = `${scrollX}px`; highlight.style.top = `${scrollY}px`;} 최종 완성 코드123456789101112131415161718192021222324const triggers = document.querySelectorAll('a');const highlight = document.createElement('span');highlight.classList.add('highlight');document.body.append(highlight);function highlightLink() { const linkCoords = this.getBoundingClientRect(); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; const scrollY = linkCoords.top + window.scrollY; const scrollX = linkCoords.left + window.scrollX; highlight.style.left = `${scrollX}px`; highlight.style.top = `${scrollY}px`; highlight.style.opacity = 1;}//마우스가 나가있을 때 사라지게 할 수 있도록 opacity값을 변경하는 함수도 추가했다.function deHighlight() { highlight.style.opacity = 0;}triggers.forEach((a) =&gt; a.addEventListener('mouseenter', highlightLink));triggers.forEach((a) =&gt; a.addEventListener('mouseleave', deHighlight));","link":"/javascript/wesbos/22.%20Highlight/"},{"title":"Wesbos - 텍스트 음성변환","text":"Web Speech API인 SpeechSynthesisUtterance() 를 활용한 텍스트 음성 합성기를 활용해보는 챕터였다. 배우면 배울수록 JavaScript가 다재다능한 언어임을 깨닫는다. 로직 선언과 SpeechSynthesisUtterance() 불러오기 음성종류(voice) option에 불러오기 텍스트 읽기와 정지 기능 구현하기 Rate와 Pitch값 조절기능 구현 const &amp; Speech APISpeechSynthesisUtterance() 💡 Web Speech API로, 스피치(말하기)서비스와 읽기관련 다양한 기능들을 제공한다. 이름 설명 .lang 언어를 불러오고 세팅함 .pitch 피치를 조절할 수 있음 .rate 말하기 속도를 조절 가능 .text 말하기 할 텍스트를 설정 및 입력 .getVoices 목소리 종류를 설정\u001f .volume 볼륨 설정 버튼, 옵션인풋, 드롭다운 등을 선언해준다.123456const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name=&quot;voice&quot;]');const options = document.querySelectorAll('[type=&quot;range&quot;], [name=&quot;text&quot;]');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop'); Voices 드롭다운에 불러오기 💡 speechSynthesis.OOO을 활용해야 한다. voiceschanged 페이지 실행 시(로드) 실행되며, list를 불러오기 위해 주로 사용된다. 1234567891011121314function populateVoices() { voices = this.getVoices(); console.log(voices); voicesDropdown.innerHTML = voices // 영어와 한국어만 사용하기 위해 이하와 같이 filter를 걸었다. .filter((voice) =&gt; voice.lang.includes('en') || voice.lang.includes('ko')) .map( (voice) =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;` ) .join('');}speechSynthesis.addEventListener('voiceschanged', populateVoices); 보이스 세팅 💡 읽기(speak)를 기능하게 하도록 하기 위해선 보이스(voice)를 설정해줘야 한다. 123456function setVoices() { console.log(this); console.log(this.value);}voicesDropdown.addEventListener('change', setVoices); 자… 이제 위의 값들을 msg.voice에 넣어주면 된다.123function setVoices() { msg.voice = voices.find((voice) =&gt; voice.name == this.value);} 읽기와 정지 버튼 활성화 💡 speechSynthesis.speak || .cancel 메서드를 활용해주면 된다 ! 우선! textarea에 적혀있는 텍스트가 msg.text에 할당되어야 한다.1msg.text = document.querySelector('[name=&quot;text&quot;]').value; texarea에 입력된 텍스트 읽기12345678function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}speakButton.addEventListener('click', toggle); 하지만…. 여기서 끝낼 경우 계속 HTML에 미리 입력해둔 “Hello! I love JavaScript 👍”만 읽는다… ⇒ 옵션을 세팅해줘야 함! msg.text와 Rate, 그리고 Pitch값 할당textarea나 Rate, Pitch값이 변경되면 그 값을 msg에 할당하도록 해보자123456789const typedText = document.querySelector('[name=&quot;text&quot;]').value;msg.text = typedText;function setOption() { console.log(this.name, this.value); msg[this.name] = this.value;}options.forEach((option) =&gt; option.addEventListener('change', setOption)); 최종 완성 코드참고로 필자는 옵션이 변경될 때마다 텍스트를 읽는게 불편해서toggle() 이 말하기를 눌렀을 때만 실행되도록 코딩했다. 123456789101112131415161718192021222324252627282930313233343536373839404142const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name=&quot;voice&quot;]');const options = document.querySelectorAll('[type=&quot;range&quot;], [name=&quot;text&quot;]');const textarea = document.querySelector('textarea');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');const typedText = document.querySelector('[name=&quot;text&quot;]').value;msg.text = typedText;function populateVoices() { voices = this.getVoices(); voicesDropdown.innerHTML = voices .filter((voice) =&gt; voice.lang.includes('en') || voice.lang.includes('ko')) .map( (voice) =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;` ) .join('');}function setVoices() { msg.voice = voices.find((voice) =&gt; voice.name == this.value);}function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}function setOption() { console.log(this.name, this.value); msg[this.name] = this.value;}speechSynthesis.addEventListener('voiceschanged', populateVoices);voicesDropdown.addEventListener('change', setVoices);options.forEach((option) =&gt; option.addEventListener('change', setOption));speakButton.addEventListener('click', toggle);stopButton.addEventListener('click', toggle(false));","link":"/javascript/wesbos/23.%20ConvertVoice/"},{"title":"Wesbos - Sticky Nav","text":"반응형 웹사이트를 만드는 데에 굉장히 유용하게 쓰일 것 같은 챕터였다.많은 비즈니스 웹사이트들이 이러한 기능들을 활용하고 있는 것 같다. 로직 const와 스크롤 이벤트에 반응하는 함수 만들기 nav바의 offsetTop값 활용하기 부자연스러운 부분 해결하며 완성도 높이기 const 선언과 Scroll 이벤트 💡 nav에 대한 선언을 하고, Scroll이벤트를 수신할 엘리먼트와 그에 따른 함수를 생성해주자. 1234567const nav = document.querySelector('#main');function fixNav() { console.log(nav); // 찍어보기}window.addEventListener('scroll', fixNav); offsetTop과 scrollY의 활용 스크롤 슬라이드인 챕터에서 사용했던 논리와 유사하다고 생각하면 된다. 12345678function fixNav() { console.log(nav.offsetTop); if (window.scrollY &gt;= nav.offsetTop) { document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); }} ‼️ 하지만…. fixed-nav 클래스가 remove되지 않는 현상이 발생한다. ❓ 뭐가 문제일까…. 고민을 해보다 console.log(nav.offsetTop)로 찍어보니if문 실행 이후 -&gt; 보이는 바와 같이 offsetTop의 값이 0으로 변해버려 else문이 실행이 되지 않았던 것이 문제였다. 함수 밖에서 let을 통해 nav.offsetTop의 값을 선언해주면 되는 문제였다.12345678910let navTop = nav.offsetTop; // fixNav에 의해 nav가 fixed 되어도 offsetTop값은 초기의 값으로 고정된다.function fixNav() { console.log(navTop); if (window.scrollY &gt;= navTop) { document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); }} 부자연스러운 transition ❓ fixNav() 함수에 의해 position이 fixed될 때 트랜지션이 부자연스럽게 뚝뚝 끊기는 현상이 발생한다 body의 height가 정확히 nav의 height만큼 늘었다 줄었다 하는 것을 발견했다. 이는 nav의 포지션이 fixed 되면서nav의 height값 만큼 body의 상단을 잡아먹었기 때문이다. 그럼 nav의 height값 만큼 padding-top을 줘서fixNav() 가 실행될 때 body 내에 존재하는 엘리먼트들을 아래로 밀어내주면 되지 않을까 123456789function fixNav() { if (window.scrollY &gt;= navTop) { document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }} 최종 완성 코드123456789101112131415const nav = document.querySelector('#main');let navTop = nav.offsetTop;function fixNav() { console.log(navTop); if (window.scrollY &gt;= navTop) { document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }}window.addEventListener('scroll', fixNav);","link":"/javascript/wesbos/24.%20Sticky%20Nav/"},{"title":"Wesbos - 이벤트 버블링 &amp; 캡쳐 &amp; 위임","text":"브라우저가 JavaScript 명령을 어떤 방식으로 수행하는지 좀 더 자세히 배울 수 있는 챕터였다. 이벤트 버블링 💡 이벤트가 **”Bottom-Up 형식”**으로 전달되어 가는 특성을 의미한다 ! 예시1234567&lt;body class=&quot;body&quot;&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt;&lt;!-- 클릭 --&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1234567const divs = document.querySelectorAll('div');function check() { console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check)); 결과 (이벤트 버블링) 세번째 요소 뿐만이 아니라, 상위 엘리먼트들인 two와 one에도 click이벤트에 따른 함수가 실행되는 것을 확인할 수 있다. “Trigger clicks all the way up” 이벤트 캡쳐 💡 이벤트 버블과 반대로 Top-Down 형식으로 해당 엘리먼트를 찾아 내려가고, 이벤트를 실행한다. 예시 : addEventListener('OOO', function, {capture : boolean}) 1234567891011const divs = document.querySelectorAll('div');function check() { console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check, { capture: true, })); 이벤트 위임 방지 💡 event.stopPropagation()을 사용하면, 정확히 내가 이벤트를 발생시킨 엘리먼트에서만 이벤트가 발생한다. event.stopPropagation()의 활용예시12345678const divs = document.querySelectorAll('div');function check(e) { e.stopPropagation(); console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check)); 이벤트 위임의 활용 💡 Todo List를 만들때 자주 나타나는 현상인데,Todo리스트에 대한 event가 잘 작동하다가 새로운 리스트가 추가됐을 때 새로운 리스트에는 이벤트가 동작하지 않는 경우가 많다. event는 기존에 생성되어 있던 엘리먼트들에게만 적용되기 때문.‼️이를 해결하기 위해선, 위임을 활용하면 된다 상위 요소에 이벤트리스너를 적용해주면, 위임에 의해 새로운 엘리먼트가 추가되어도event가 추가된 요소에도 잘 할당된다.","link":"/javascript/wesbos/25.%20Bubling/"},{"title":"Wesbos - 동적 드롭다운 메뉴","text":"Sticky Nav와 같이 웹 사이트를 제작할 때 자주 사용할 수 있을 것 같은 기능이다.마우스 hover → 서브메뉴들의 크기에 따라 동적으로 드롭다운 된다. 로직 const를 통한 선언 함수 만들기 + 이벤트리스너 (mouseenter, mouseleave) 마우스 이벤트에 반응 할 CSS 작성 classlist.add 와 remove getBoundingClientRect()를 활용한 엘리먼트 위치 및 크기 값 활용 const 선언-불편한 바보 드롭다운이 되지 않기 위해선 a가 아닌, li태그에 이벤트를 걸어줘야 한다. -dropdownBackground가 따라다녀야 함 -nav태그의 위치값이 추후에 필요하므로 nav태그 또한 선언 필요 123const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top'); 함수 &amp; eventListener 💡 마우스 hover와 같은 기능이자 해당 이벤트가 엘리먼트에만 적용되는 mouseenter, mouseleave 12345678910function handleEnter() { console.log('Entered!'); // 잘 작동하는지 찍어보기}function handleLeave() { console.log('Leaved!');}triggers.forEach((li) =&gt; li.addEventListener('mouseenter', handleEnter));triggers.forEach((li) =&gt; li.addEventListener('mouseleave', handleLeave)); CSS 작성하기1234567891011.trigger-enter .dropdown { display: block;} /* trigger-enter 그리고 .dropdown 모두 */.trigger-enter-active .dropdown { opacity: 1;}.dropdownBackground.open { opacity: 1;} classList.add &amp; remove12345678910function handleEnter() { this.classList.add('trigger-enter'); this.classList.add('trigger-enter-active'); background.classList.add('open');}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');} ‼️ 하지만… 이렇게 코딩할 경우, transition 효과가 적용되지 않는다. 💡 display : block에는 transition이 먹히지 않기 때문에, block이 된 후 opacity에 변화를 줘야 ⇒ transition이 적절하게 적용된다. 1234567891011function handleEnter(){ this.classList.add('trigger-enter') // &amp;&amp; 앞이 조건문, 뒤에는 True일 경우의 결과 setTimeout(()=&gt; this.classList.add('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150)')) background.classList.add('open')};function handleLeave(){ this.classList.remove('trigger-enter', 'trigger-enter-active') background.classList.remove('open')}; getBoundingClientRect()의 활용 💡 getBoundingClientRect() = 엘리먼트의 넓이, 뷰포트를 기준으로 한 위치값(x,y) 등을 알 수 있다. 1234567891011121314151617181920212223242526272829function handleEnter() { this.classList.add('trigger-enter'); setTimeout( () =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 100 ); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); background.style.setProperty('width', `${dropdownCoords.width}px`); background.style.setProperty('height', `${dropdownCoords.height}px`); // nav의 위치가 변경되면 위치가 뒤틀릴 수 있기 때문에 애초에 nav의 top과 left값을 빼준다. background.style.setProperty( 'transform', `translate(${dropdownCoords.left - navCoords.left}px, ${ dropdownCoords.top - navCoords.top }px)` );}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top');function handleEnter() { this.classList.add('trigger-enter'); setTimeout( () =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 100 ); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); background.style.setProperty('width', `${dropdownCoords.width}px`); background.style.setProperty('height', `${dropdownCoords.height}px`); background.style.setProperty( 'transform', `translate(${dropdownCoords.left - navCoords.left}px, ${ dropdownCoords.top - navCoords.top }px)` );}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');}triggers.forEach((li) =&gt; li.addEventListener('mouseenter', handleEnter));triggers.forEach((li) =&gt; li.addEventListener('mouseleave', handleLeave));","link":"/javascript/wesbos/26.%20Dropdown/"},{"title":"Wesbos - 드래그 슬라이드","text":"내가 디스트리 프로젝트에서 꽤나 애먹었던 기능이다.여러 웹사이트에서 볼 수 있는 드래그가 가능한 이미지 슬라이더를 구현해보는 챕터다. 로직 const와 addEventListener 선언 mousedown이 true일 때만 mousemove function 실행되도록 설정 마우스가 클릭 후 시작점 &amp; 드래그된 이동값 출력하기 마우스가 드래그 된 만큼 item들 움직이기 (부가적 기능) CSS적용해서 시각적 효과 더 입히기 const와 addEventListener 선언 💡 mousedown, mouseup, mousemove, mouseleave를 사용하면 된다. 12345678910111213141516const slider = document.querySelector('.items');// 다 한 번씩 찍어보기~slider.addEventListener('mousedown', () =&gt; { console.log('Down!');});slider.addEventListener('mouseup', () =&gt; { console.log('up!');});slider.addEventListener('mousemove', () =&gt; { console.log(&quot;It's moving!&quot;);});slider.addEventListener('mouseleave', () =&gt; { console.log('Leaved!');}); mousedown이 true일 때만 mousemove 함수 실행! 💡 드래그의 기본 동작 방식은 “클릭 → 마우스움직이기” 이므로 mousedown이 발생하지 않았을 때에는 mousemove에 대한 함수가 실행돼선 안된다. 12345678910111213141516let isDown = false;slider.addEventListener('mousedown', () =&gt; { isDown = true; // 클릭됐을 때 true 적용 console.log('Down!');});slider.addEventListener('mouseup', () =&gt; { isDown = false; // 당연히 마우스업 됐을 때에는 isDown이 false처리! console.log('up!');});slider.addEventListener('mousemove', () =&gt; { if (!isDown) return; // 클릭이 안됐을 때에는 isDown이 false이므로 return된다. console.log(&quot;It's moving!&quot;);}); mousedown 후 마우스 위치와 이동된 값 출력하기 💡 pageX,Y = 브라우저 내에서의 XY좌표를 반환하지만, 스크롤 화면을 포함해 계산한다.offsetX,Y = 이벤트 대상 객체가 기준이 되어 상대적 마우스 XY좌표를 반환 123456slider.addEventListener('mousedown', (e) =&gt; { isDown = true; console.log(e.pageX); console.log(slider.offsetLeft); // slider박스 옆에 엘리먼트가 추가되거나 마진이 생겼을 때를 대비 console.log(slider.scrollLeft); // 얼마나 움직였는지!}); 이러한 첫 클릭 시의 마우스 위치와 마우스를 움직인 만큼의 값을 변수화 하여 저장! 1234567891011// 미리 변수화!let startX;let scrollLeft;slider.addEventListener('mousedown', (e) =&gt; { isDown = true; startX = e.pageX - slider.offsetLeft; scrollLeft = slider.scrollLeft; console.log(startX); console.log(scrollLeft);}); 마우스가 드래그 된 만큼 스크롤 💡 scrollLeft = 오른쪽 또는 왼쪽으로 스크롤된 만큼의 값을 반환하거나, 이동하도록 명령할 수 있음 12345678slider.addEventListener('mousemove', (e) =&gt; { if (!isDown) return; e.preventDefault(); const moved = e.pageX - slider.offsetLeft; // 마우스가 움직인 상대값 const walk = (moved - startX) * 2; // 실제로 마우스를 움직인 절대적 값 slider.scrollLeft = scrollLeft - walk; // scrollLeft에서 walk를 빼주는 이유 : 그냥 walk만 주게 될 경우, 현재 스크롤된 만큼의 위치값은 저장되지 않음}); (부가적) CSS로 시각적 효과 넣어주기12slider.classList.add('active');slider.classList.remove('active'); 최종 완성 코드1234567891011121314151617181920212223242526272829const slider = document.querySelector('.items');let isDown = false;let startX;let scrollLeft;slider.addEventListener('mousedown', (e) =&gt; { isDown = true; startX = e.pageX - slider.offsetLeft; scrollLeft = slider.scrollLeft; slider.classList.add('active');});slider.addEventListener('mouseup', () =&gt; { isDown = false; slider.classList.remove('active');});slider.addEventListener('mousemove', (e) =&gt; { if (!isDown) return; e.preventDefault(); const moved = e.pageX - slider.offsetLeft; const walk = (moved - startX) * 2; slider.scrollLeft = scrollLeft - walk;});slider.addEventListener('mouseleave', () =&gt; { isDown = false; slider.classList.remove('active');});","link":"/javascript/wesbos/27.%20Drag_Slide/"},{"title":"Wesbos - 동영상 속도제어 Bar","text":"초반 챕터에서 다뤘던 동영상 제어 중, 동영상 속도를 시각적으로 이쁘게 조절할 수 있는 Bar를 만들어 제어하는 기능을 구현해봤다. 로직 const와 addEventListener (video, speed, speed-bar, mousemove 등등) mousemove에 따른 마우스 상대위치값 출력 speed-bar 값에 적용하여 CSS 변경 재생속도(playbackRate) 값 부여 CSS 디테일 다듬기 (grab → grabbing 등) const와 addEventListener 💡 mousedown, mouseup, mousemove 와 isDown 변수를 통해 드래그 이벤트 인식하도록 설정 1234567891011121314151617181920212223const video = document.querySelector('.flex');const stick = document.querySelector('.speed');const speedBar = document.querySelector('.speed-bar');// 이전 챕터에서 사용했던 방식과 동일하다.let isDown = false;function isClicked() { isDown = true; console.log('clicked!');}function cancelDown() { isDown = false;}function handleMove(e) { if (!isDown) return; console.log(&quot;it's Moving~&quot;);}stick.addEventListener('mousedown', isClicked);stick.addEventListener('mouseup', cancelDown);stick.addEventListener('mousemove', handleMove); mousemove에 따른 마우스 상대적 마우스 이동값 구하기 💡 e.pageY와 offsetTop, 그리고 offsetHeight를 활용해줘야 한다. 12345678function handleMove(e) { if (!isDown) return; y = e.pageY - stick.offsetTop; // 뒤의 offsetTop은 혹시 모를 stick 위치 변화에 대비 percentageY = y / stick.offsetHeight; // 페이지 내에서의 마우스y 값을 stick의 총 높이로 나누면 stick내에서의 상대적 위치값 도출 가능 height = Math.round(percentageY * 100) + '%'; // 이제 이 height값을 speedBar의 height CSS값에 부여해주면 된다.} speed-bar에 height 값 적용하여 CSS 변경 💡 height값을 1% ~ 100%로 변환하여 CSS값에 넣어주면 끝 12height = Math.round(percentageY * 100) + '%';speedBar.style.setProperty('height', height); 하지만, height뿐만 아니라 innerHTML 또한 변경해줘야 한다. 123playbackRate = percentageY * (max - min) + min;textContent = playbackRate.toFixed(1) + 'x';speedBar.innerHTML = textContent; num.toFixed(n) 💡 숫자를 소숫점 n자리수 만큼 반올림해준다 재생속도(playbackRate) 값 부여 💡 위의 내용까지 잘 이해했다면, 굉장히 쉽다. 123video.playbackRate = playbackRate;// 이거 한 줄이면 됨! 최종 완성 코드1234567891011121314151617181920212223242526272829303132const video = document.querySelector('.flex');const stick = document.querySelector('.speed');const speedBar = document.querySelector('.speed-bar');let isDown = false;function isClicked() { isDown = true; speedBar.style.setProperty('cursor', 'grabbing');}function cancelDown() { isDown = false; speedBar.style.setProperty('cursor', 'grab');}function handleMove(e) { if (!isDown) return; const max = 4; const min = 0.4; y = e.pageY - stick.offsetTop; percentageY = y / stick.offsetHeight; height = Math.round(percentageY * 100) + '%'; speedBar.style.setProperty('height', height); playbackRate = percentageY * (max - min) + min; textContent = playbackRate.toFixed(1) + 'x'; speedBar.innerHTML = textContent; video.playbackRate = playbackRate;}stick.addEventListener('mousedown', isClicked);stick.addEventListener('mouseup', cancelDown);stick.addEventListener('mousemove', handleMove);","link":"/javascript/wesbos/28.%20VideoController/"},{"title":"Wesbos - 타이머","text":"이전에 노마드코더의 클론코딩 강의에서 시도했다가 실패했던 것과 비슷한 챕터다…타이머 기능이라고 하면 굉장히 쉬워보이지만…. 막상 해보면 굉장히 복잡하다. 로직 const와 addEventListener 초(seconds)입력하면 → 분 : 초 형식으로 화면에 띄우기 input 박스 입력된 값을 함수에 전달! 띄워진 시간 countdown 타이머 종료 시간(endTime) 계산 → 띄우기 const와 addEventListener123456789const time = document.querySelector('.display__time-left');const endTime = document.querySelector('.display__end-time');const buttons = document.querySelectorAll('[data-time]');function startTimer() { // console.log(this.dataset.time);}buttons.forEach((button) =&gt; button.addEventListener('click', startTimer)); Seconds입력 → Minutes : Seconds 형식으로 반환 💡 분(Minutes) : 초 / 60초 (Seconds) : 초 % 60 12345function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; time.innerHTML = `${minutes}:${secondsLeft}`;} But, 이대로 실행할 경우 아래와 같은 문제가 발생한다 123456789// 조건을 걸어서 10 이하일 경우 앞에 0이 붙어서 출력되도록 해야한다.function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; // 초가 10보다 작을 경우, 0 붙임 const display = `${minutes}:${secondsLeft &lt; 10 ? '0' : ''}${secondsLeft}`; document.title = display; // 이건 그냥 타이틀에도 시간 표시되면 좋을 것 같아서 추가 time.innerHTML = display;} 지금 다시 코드를 봐보니까.. padend나 padstart를 사용했어도 됐을 것 같다. input박스에 입력한 값을 각 함수들에 전달하기 💡 submit 이벤트에 반응할 엘리먼트 및 함수를 만들고, 해당 함수에서 timer에 분값*60을 전송 → timer(seconds) 에서 displayTimer() 함수 실행하면 된다. 1234567891011function timer(seconds) { displayTimer(seconds);}function submitSeconds(e) { e.preventDefault(); const inputMins = this.minutes.value; timer(inputMins * 60);}document.customForm.addEventListener('submit', submitSeconds); 띄워진 시간을 카운트다운! 💡 가장 핵심적인 부분이다. setInterval을 활용해 1초마다 seconds가 —1 되도록 하고→ seconds가 00을 지나 마이너스 되면→ minutes가 —1 되도록 구현하면 된다. 123456789101112131415161718function timer(seconds) { const now = Date.now(); //현재 시간(날짜) 정보 const then = now + seconds * 1000; // then = 현재 시간 및 날짜정보 + 입력 seconds*1000 console.log(now, then); displayTimer(seconds); countdown = setInterval(() =&gt; { // ((현재 시간 + 추가된 시간) - 현재 시간) / 1000 // then은 고정값이고 Date.now는 계속 증가 =&gt; 즉, 값이 점점 마이너스 됨 const countSeconds = Math.round((then - Date.now()) / 1000); if (countSeconds &lt; 0) { clearInterval(countdown); return; } displayTimer(countSeconds); }, 1000);} 부가설명 ⇒ 즉, 고정된 시간 값 (then)에서 계속 증가하는 값을 빼주면 결국 countSeconds는 1초씩 줄어들게 된다. 종료시간 표시하기 💡 위의 내용들을 잘 수행했다면 어렵지 않다. 12345678function displayEndTime(timestamp) { const end = new Date(timestamp); const hours = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `종료 시간 ${ hours &lt; 10 ? '0' : '' }${hours} : ${minutes}`;} 최종 완성 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566let countdown;let working = false;const time = document.querySelector('.display__time-left');const endTime = document.querySelector('.display__end-time');const buttons = document.querySelectorAll('[data-time]');const quit = document.querySelector('.quit');function timer(seconds) { working = true; if (working == false) { return; } clearInterval(countdown); quit.style.setProperty('opacity', '100'); const now = Date.now(); const then = now + seconds * 1000; displayTimer(seconds); displayEndTime(then); countdown = setInterval(() =&gt; { const countSeconds = Math.round((then - Date.now()) / 1000); if (countSeconds &lt; 0) { clearInterval(countdown); return; } displayTimer(countSeconds); }, 1000);}function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; const display = `${minutes}:${secondsLeft &lt; 10 ? '0' : ''}${secondsLeft}`; document.title = display; time.innerHTML = display;}function displayEndTime(timestamp) { const end = new Date(timestamp); const hours = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `종료 시간 ${hours &lt; 10 ? '0' : ''}${hours} : ${ minutes &lt; 10 ? '0' : '' }${minutes}`;}function startTimer() { const seconds = parseInt(this.dataset.time); timer(seconds);}function quitTimer() { clearInterval(countdown); working = false;}buttons.forEach((button) =&gt; button.addEventListener('click', startTimer));quit.addEventListener('click', quitTimer);document.customForm.addEventListener('submit', submitSeconds);function submitSeconds(e) { e.preventDefault(); const inputMins = this.minutes.value; timer(inputMins * 60); this.reset();}","link":"/javascript/wesbos/29.%20Timer/"},{"title":"Wesbos - 두더지 잡기","text":"음… 실용성은 없을 것 같지만 그래도 그동안 배웠던 JS 지식들을 잘 활용할 수 있는 챕터였다.클릭해서 올라오는 두더지를 잡고, 잡은 수 만큼 스코어를 올리면 된다. 로직 const &amp; addEventListener “랜덤으로 반복되지 않게” 두더지가 올라오도록 하기 ( + 들어가는 것 까지) 두더지가 클릭된 횟수를 기억하기 해당 횟수를 스코어보드에 기록하기 const123const holes = document.querySelectorAll('.hole');const scoreBoard = document.querySelector('.score');const moles = document.querySelectorAll('.mole'); randomHole 함수를 만들어 보자 💡 임의의 두더지 구멍(hole)이 반환될 수 있도록 Math.random() 을 활용해보자 12345function randomHole() { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; console.log(hole);} 다 좋은데, 아래와 같이 동일한 hole이 출력된다.이 게임에선 난이도 조절을 위해 같은 hole에서 두더지가 나오지 않도록 할 것이기 때문에 아래와 같은 중복 반환 현상이 일어나선 안된다…! 123456789101112let lastHole;function randomHole() { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; if (hole == lastHole) { console.log('이미 나온 놈..!!'); return randomHole(); } lastHole = hole; // 여기서 hole은 lasthole로 지정된다. console.log(hole);} 두 값 사이의 난수 생성하기? 💡 예를 들어, 1과 5 사이에 있는 숫자들 중에 난수를 반환하고자 한다면, 아래와 같은 함수 및 공식을 활용하면 된다. 123function getRandomArbitrary(min, max) { return Math.random() * (max - min) + min;} 두더지가 튀어나오도록 해보자1234function popUp() { const hole = randomHole(holes); hole.classList.add('up');} 하지만! 들어가는 속도가 너무 일정하면 게임이 너무 쉽다… 그래서 들어가는 속도도 랜덤으로 해보고자 한다. 1234567891011121314function randomTime(min, max) { return Math.round(Math.random() * (max - min) + min);}function popUp() { // 0.2초 ~ 1초 사이의 랜덤한 숫자(초)를 반환한다. const time = randomTime(200, 1000); const hole = randomHole(holes); hole.classList.add('up'); // 0.2초 ~ 1초 사이에서 임의의 속도로 두더지는 다시 들어간다. setTimeout(() =&gt; { hole.classList.remove('up'); }, time);} 점수 계산123456789function scored(e) { if (e.isTrusted == false) { alert(&quot;Don't Cheating!!&quot;); return; } score++; this.parentNode.classList.remove('up'); scoreBoard.textContent = score;} isTrusted 💡 클릭 이벤트가 진짜 사용자에 의한 “물리적 클릭“에 의해서 이루어졌는지 확인할 수 있음 게임 시작버튼 활성화123456789101112131415function popUp() { const time = randomTime(200, 1000); const hole = randomHole(holes); hole.classList.add('up'); setTimeout(() =&gt; { hole.classList.remove('up'); if (!finished) popUp(); // 10초가 지나기 전까진 계속 false이므로 popUp돼야 함! }, time);}function start() { popUp(); finished = false; setTimeout(() =&gt; (finished = true), 10000); // 게임은 10초동안 진행된다.} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const holes = document.querySelectorAll('.hole');const scoreBoard = document.querySelector('.score');const moles = document.querySelectorAll('.mole');let lastHole;let finished = false;let score = 0;function randomTime(min, max) { return Math.round(Math.random() * (max - min) + min);}function randomHole(holes) { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; if (hole == lastHole) { console.log('이미 나온 놈!!'); return randomHole(holes); } lastHole = hole; return hole;}function popUp() { const time = randomTime(500, 1000); const hole = randomHole(holes); hole.classList.add('up'); setTimeout(() =&gt; { hole.classList.remove('up'); if (!finished) popUp(); }, time);}function scored(e) { if (e.isTrusted == false) { alert(&quot;Don't Cheating!!&quot;); return; } score++; this.parentNode.classList.remove('up'); scoreBoard.textContent = score;}function start() { scoreBoard.textContent = 0; popUp(); finished = false; setTimeout(() =&gt; (finished = true), 10000);}moles.forEach((mole) =&gt; mole.addEventListener('click', scored));","link":"/javascript/wesbos/30.%20Mole/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"완전탐색","slug":"완전탐색","link":"/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"},{"name":"빅오","slug":"빅오","link":"/tags/%EB%B9%85%EC%98%A4/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"배열과 오브젝트","slug":"배열과-오브젝트","link":"/tags/%EB%B0%B0%EC%97%B4%EA%B3%BC-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"문제해결","slug":"문제해결","link":"/tags/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/"},{"name":"예제","slug":"예제","link":"/tags/%EC%98%88%EC%A0%9C/"},{"name":"재귀","slug":"재귀","link":"/tags/%EC%9E%AC%EA%B7%80/"},{"name":"탐색","slug":"탐색","link":"/tags/%ED%83%90%EC%83%89/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"Wesbos Challenge","slug":"Wesbos-Challenge","link":"/tags/Wesbos-Challenge/"}],"categories":[{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"프론트엔드","slug":"프론트엔드","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"},{"name":"Typescript","slug":"프론트엔드/Typescript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Typescript/"},{"name":"React","slug":"프론트엔드/React","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/React/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Redux","slug":"프론트엔드/Redux","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Redux/"},{"name":"Udemy","slug":"알고리즘/Udemy","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Udemy/"},{"name":"백준","slug":"알고리즘/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"프로그래머스","slug":"알고리즘/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"Javascript","slug":"프론트엔드/Javascript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Javascript/"},{"name":"프로젝트","slug":"프로젝트","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"Network","slug":"CS/Network","link":"/categories/CS/Network/"},{"name":"프리온보딩","slug":"프로젝트/프리온보딩","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9/"}]}