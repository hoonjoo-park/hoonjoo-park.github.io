{"pages":[{"title":"박훈주 (Frontend Developer)","text":"꾸준히 성장하고 배우며 사회에 유의미한 가치를 창출하는데 일조하는 개발자가 되고싶습니다.“끈기가 내 가능성과 한계의 외연을 결정한다“라는 가치관을 갖고 살아가고 있습니다. 학력서울시립대학교 경영학부 졸업 기술 스택 Javascript React Typescript Node.js MongoDB 경력 바이브컴퍼니 인공지능LAB 인턴 근무 (1년 7개월) 원티드 프리온보딩 코스 수료 자격증 및 이력 토익 (910) 오픽 (AL) 컴퓨터활용능력 1급 노마드코더 리액트 챌린지 우수졸업생","link":"/about/index.html"}],"posts":[{"title":"[Github] 협업을 위한 기초","text":"1. README 파일 관리 이전까지는 Github에 코드를 올릴 때 README의 중요성을 잘 알지 못했었다.”그냥 제목이랑 무슨 웹서비스인지 개괄적인 설명만 하면 되지 않을까?” 절~~대 아니다. 이는 오히려 나의 코드와 서비스에 대한 가능성을 저해하는 것과 마찬가지다. 내가 좋은 서비스와 코드를 배포했다면, 당연히 다른 사람들이 내 레포지토리를 확인하고 사용법 등을 읽어볼 것이라고 가정해야 한다. 즉, README 파일을 제대로 작성하지 않는 것은 사용 설명서 없이 전자제품을 판매하는 것과 같은 것이라 봐도 무방하다. 📝 README에 들어가야 하는 필수 요소 프로젝트 이름 배포 주소 설치 &amp; 실행 방법 디렉토리 구조 (Project Structure) 프로젝트 설명 핵심 기능 구현 예시 (gif, jpeg 등등) 핵심 코드 설명 프로젝트에 대한 회고 2. 팀원들과 원활한 협업을 위한 사전 약속 그동안 코딩을 할 때, 혼자 주로 해왔었기에 커밋, css, 디렉토리 구조 등등 다~~ 내 마음대로 했었다.물론 완전 체계없이 한 것은 아니었지만, 협업을 위해선 팀원들과의 사전 약속이 필요하다. 디렉토리 구조 아래와 같이 이번 프로젝트에서 우리는 CRA를 통해 React프로젝트 뼈대를 만들었고, 디렉토리 구조를 사전에 약속했다. 이렇게 사전에 디렉토리 구조를 약속하고 코드를 짜니 훨씬 소통도 잘 되고 협업하는 것도 수월했다. CSS 사용 방법 나는 styled-components를, 다른 팀원은 tailwind, 또 다른 팀원은 SASS를 선호한다고 해서 각자 서로 다른 CSS 스타일링을 하면 안된다. 따라서 팀원들 간의 합의를 통해 공통된 CSS 작성법을 약속해야 한다. Commit 메시지의 통일 팀원들이 각기 아래와 같이 통일감 없이 마음대로 커밋 메시지를 작성하면 팀원들을 차치하고서라도 다른 사람들이 봤을 때 프로젝트 진행 과정 등을 한 눈에 알아보기가 어렵다. 따라서 프로젝트 시작 전 팀원들 간에 commit 메시지 작성법을 정하는 것이 좋다. 커밋 메시지 예시 기능 추가 : 무한 스크롤 기능 추가하여 구현하였습니다! 무한 스크롤, CSS 스타일링, API KEY 수정 🔥 루트 디렉토리 test.js파일 삭제 그리고 **“습니다”, “반말”, “작업중“**과 같은 표현들은 커밋 메시지를 작성할 때 최대한 지양하는 것이 좋다. git commit 메시지 작성 예시 3. 제발 .gitignore 작성해주세요…. .gitignore를 작성하지 않고 push를 하면 사용자 입장에서 전~혀 필요 없는, 또는 올라와서는 안될 파일들이 github 레포지토리에 올라가게 된다. 우리가 어떤 미술 전시를 보러 갔는데 미술 작품만 걸려있는게 아닌, 해당 작가가 사용했던 물감, 붓, 펜, 포장지, 받침대 등등 잡다한 것들도 전부 다 전시되어있다면 어떨까? 같은 이치다. 물론 보안상의 이유도 물론 있지만, 우리의 코드를 받아서 쓰는 사용자들은 nodemodules나 build, .vscode와 같은 폴더 및 파일들이 전혀 필요 없다. 오히려 짐만 될 뿐이다. 따라서 보안상의 이유(env 파일 등)와 효율성을 위해 .gitignore파일을 생성하여 작성하자.","link":"/github/1.github_basic/"},{"title":"[Github] Remote와 Local","text":"Remote와 Local? 쉽게 설명하자면, remote는 git서버에 존재하는 저장소,local은 내 컴퓨터에 물리적으로 존재하는 저장소를 의미한다. Remote 생성 원격 repository를 생성하는 방법이다. 나의 github repositories에 들어가 우측 상단의 New버튼을 클릭한다. Repository 이름을 원하는대로 작성하고 공개 여부를 설정하여 생성해주면 끝이다. Local 세팅 Local은 말 그대로 내 컴퓨터에 있는 파일이다.하지만 이 Local 파일들이 git과 연동되도록 하려면 일련의 과정들이 필요하다. 원격저장소 (remote)와 현재 로컬 폴더를 연동 ⇒ 로컬과 연결하고자 하는 원격 저장소를 “저장” 또는 “지정” 되도록 하는 것 1$ git remote add origin [repo URL] upstream과 remote 분리 (upstream은 따로 있고 나의 레포에는 fork된 레포가 있을 경우) 1234### 1번은 위와 동일, 하지만 이는 나의 fork된 레포를 의미한다.$ git remote add origin [repo URL]### 2번은 내가 fork해온 오리지날 upstream 레포를 의미한다.$ git remote add upstream [repo URL] repo URL은 아래와 같이 확인 후 복붙해주면 된다. 로컬과 리모트의 연결상태 확인 123$ git remote -v$ git remote show 연동된 원격 저장소의 정보를 업데이트 12## 이걸 해줘야 remote의 브랜치 목록들을 최신화 하여 확인할 수 있다.$ git remote update 저장소명을 모르겠는 경우? 1$ git remote Local 저장소로 Remote 클론하는 방법1$ git clone [remote repo URL] ## 클로닝 🚨 git clone에는 아래와 같은 명령어들의 프로세스가 포함되어 있는 것이다. 123$ git init ## 현재 위치의 디렉토리를 빈 Git 저장소로 지정$ git remote add origin [remote repo URL] ## 지정된 Git 저장소에 원격 repository를 추가$ git fetch origin master ## remote 내의 master브랜치 데이터들 -&gt; 로컬로 데이터를 &quot;가져오기만&quot; 함 1$ git remote -v ##지정된 remote 목록을 확인할 수 있다.","link":"/github/2.remoteLocal/"},{"title":"[Github] 브랜치","text":"Git Branch란? 브랜치는 말 그대로 나뭇가지다.main이라는 브랜치의 기둥을 기준으로 뻗쳐있는 줄기들이라고 생각하면 된다. 처음 repository를 생성하면 이와 같이 main 브랜치가 만들어진다. 이러한 main 브랜치가 나무의 기둥이라고 생각하고, 그 기둥을 기준으로 여러 branch(나뭇가지)들이 뻗어있다고 생각해보자. 이와 같은 각 branch들은 독립적인 작업공간이라고 볼 수 있다. 만약 모두가 함께 main브랜치에서 작업을 하게 되면 서로의 작업에 의해 나의 코드에 영향을 주거나 예기치 못한 오류들이 발생할 수 있다. 따라서 각자 맡은 기능들을 개발하기 위한 독립적인 공간(branch)이 필요한데, 이게 branch의 존재 이유다. 일반적인 브랜치 구조 물론 일반화를 할 수는 없지만, 자주 사용되는 브랜치 작업 방법이다.이번 프로젝트에서도 이와 같이 브랜치를 만들어 작업했다. main브랜치를 기준으로 develop 브랜치를 생성한다. 기능별 브랜치를 생성한다. 하나의 기능 구현이 완료되면 develop브랜치에 push한다. 하나의 완성된 version이 구현되면 develop에서 main 브랜치로 최종본을 push한다. 이렇게 작업을 하다 보면 아래와 같이 여러 브랜치들이 생기는데, 기능 구현이 완료되어 develop브랜치로 이상없이 push됐다면 해당 브랜치를 삭제해주면 된다. git branch 명령어브랜치 만들기 1$ git branch [branch 이름] 원하는 브랜치로 이동하기 1234$ git checkout [branch 이름]## 브랜치를 만듦과 동시에 이동하기$ git checkout -b [branch 이름] 브랜치 확인하기 1$ git branch 브랜치 이름 변경 12### 이름 변경$ git branch --move [기존 이름] [바꿀 이름] 브랜치 삭제하기 1$ git branch -d [branch 이름]","link":"/github/3.branch/"},{"title":"[Github] push, pull","text":"push, pull, merge의 과정 개발이 완료 됐다면? → push + remote에도 브랜치 추가 → pull request → merge 항상 로컬 저장소의 파일을 원격 저장소에 최신화 하고자 할 때는 “add → commit → push“의 순서를 따르면 된다. commit 12## -a = add, -m = message (add -&gt; commit -&gt; push 순서)$ git commit -a -m &quot;메시지 넣으면 됨&quot; commit 되돌리기 1234# 만약 커밋을 이미 해버렸는데, 해당 커밋 내용에 추가적으로 변경되어야 할 사항이 필요할 경우$ git reset [commit 코드]# 그냥 커밋 자체를 취소하고 로컬에서 변경사항도 되돌리고싶을 경우$ git reset --hard [commit 코드] push방법 12## ex) git push origin function/a$ git push [저장소명] [브랜치명] 매번 저장소명과 브랜치명 작성하는게 귀찮을 경우! 1234567## 로컬의 브랜치를 remote repo에 업로드 (origin) =&gt; 이후에는 저장소와 브랜치명 작성 안해줘도 됨$ git push -u origin [브랜치명]## 만약 현재 브랜치에 바로 push를 하고싶다면?$ git push origin HEAD## 또는?$ git push origin HEAD/ Local 최신화 이제 remote 레포가 최신화 됐으므로, 나의 local 또한 최신화 해줘야 한다. develop 브랜치로 이동한다. (나의 경우는 main 아래에 develop을 두는 편이기에) 1$ git checkout develop 이전에 작업했던 브랜치를 develop과 merge 해준다. 1$ git merge [방금 작업했던 branch 이름] fetch vs pull? fetch : remote 데이터를 로컬로 “가져오기만” 함 (로컬 헤드가 변경되지 않음) pull : remote 데이터를 가져오고 + 병합까지 실행 (fetch + merge ⇒ 파일이 불러와지고, head도 옮겨짐)","link":"/github/4.pushPull/"},{"title":"[Github] Merge","text":"Merge란…? 우리가 자주 듣는 말이 있다. “OO님 PR 날렸으니 확인 후에 merge 부탁드릴게요~!!” 그렇다면 merge는 뭘까? 우선 git merge에 대한 설명을 하기에 앞서, 로컬 → origin → upstream → PR까지의 과정(머지 직전)에 대해 다시 차근차근 짚어보고자 한다. 로컬 우리는 위의 그림과 같이 “나의 컴퓨터”에서 작업하기 위한 local 브랜치가 필요하다. 그리고 이러한 local 브랜치는 대부분 원격 upstream 레포에서 clone해온 브랜치다. origin repository origin repository는 upstream repo에서 fork해온 레포지토리다. 따라서 origin과 upstream은 서로 연결되어 있으며, origin에서 어떠한 변동사항이 생기면 원본 repository(upstream)에 PR을 날려보라고 제시를 한다(비유). upstream repository 모든 repo의 기준점이 되는 upstream repo에는 이에 따라 여러 PR들이 날아온다. A라는 개발자, B라는 개발자, C라는 개발자…. 이들이 “_이것좀 Pull 해주세요!_”하고 PR(Pull Request)를 날린 것들을 하나하나 확인해보고 괜찮다 싶은 것들을 선택해서 나의 원본 repo에 merge(합치다)해줄 수 있는 것이다. PR (Pull Request) &amp; Merge 이렇게 PR → Merge가 완료됐다면 나의 upstream repo는 새로 추가된 코드와 합쳐진다. Merge 방법merge (fast forward) merge의 방법 중 가장 기본적인 것이 fast-forward 방식의 merge다. 우선, 아래와 같은 방식으로 main브랜치에서 A브랜치를 따서 작업 중이었다고 가정해보자. 그리고 A 브랜치에서의 모든 작업이 끝나서 main과 A를 합쳐주고 싶은데, 이 때 사용하는 것이 merge다. 하지만, fast-forward merge는 내가 main과 A브랜치를 merge했다는 사실이 commit에 기록되지 않는다는 특징을 갖는다. 이후 fast-forward merge가 되면 아래와 같이 main브랜치가 A브랜치의 자리로 병합되며 이동된다! 근데… 만약 merge에 대한 commit을 남기고 싶다면? $ git merge —no-ff 를 사용하면 된다! 위의 명령어를 입력하면 자동으로 commit 메시지를 작성하라는 vim이 뜨는데, 해당 vim에서 커밋 메시지를 작성해주면 된다 🙂 Merge Conflict 위와 같은 과정만 반복된다면 git을 배우는게 그리 어렵지만은 않을 것이다….하지만, 우리를 항상 힘들게 하는 merge conflict라는 것이 존재한다 😩 merge conflict는 왜 일어날까 ? 머지하려는 두 branch에 동일한 부분에서의 수정이 발생했을 때 conflict이 일어난다.즉, git이 우리에게 ”**두 브랜치에서 같은 부분이 수정이 됐는데 각각 수정 내용이 달라… 둘 중에 뭘 선택해야돼?**”라고 물어보는 것과 같다고 생각하면 된다. conflict 해결 방법 수동 해결 방법 (가장 일반적) 파일을 직접 열어서 merge할 부분을 선택, 그리고 버릴 것은 삭제!⇒ 둘 중에 하나를 선택해도 되고, 둘 다 가져와도 된다.⇒ conflict 해결 이외의 수정을 해서는 절대 절대 안됨!!! git add . (진짜 conflict가 난 부분만 수정했는지 반드시 체크해야 한다) git merge —-continue tool 활용법 (VS Code) 터미널에 $ git config —global -e 입력 후 깃 세팅창 열기 아래와 같이 내용 추가[merge]tool = vscode[mergetool “vscode”]cmd = code –wait $MERGED $ git mergetool 입력 → 머지! P4Merge 사용하기 (많은 개발자들이 애용) 설치 (구글링) mergetool을 p4merge로 수정! (mergetool “vscode”는 굳이 삭제하지 않아도 됨!) [merge] tool = p4merge [mergetool “p4merge”] path = “/Applications/p4merge.app/Contents/MacOS/p4merge” p4merge 활용 예시","link":"/github/5.merge/"},{"title":"[Github] Rebase","text":"Rebase란 무엇인가? 브랜치들은 하나의 기준점에서 파생된 작업 공간이다.하지만 만약 내가 현재 작업중인 브랜치의 파생 기준점인 main브랜치에 새로운 커밋이 생겨 업데이트 됐다면? 이런 경우 A브랜치의 파생 기준점은 아래의 그림에서 main브랜치였다. 즉 내가 A브랜치를 파생시킬 때 까지만 하더라도 main브랜치가 최신화된 기준 브랜치였던 것이다. 하지만 해당 main 브랜치에 새로운 new라는 커밋이 생겨 최신화되었기에… A브랜치와 main브랜치의 fast-forward merge가 불가능해졌다. 이유는 간단하다. 아래의 main브랜치와 A브랜치가 병합되면 new라는 새로운 커밋은 유실된다…. 따라서 모든 변경사항을 담아 merge하기 위해선 대책이 필요하다. 이 때문에 rebase가 필요한 것이다. 아래를 보면 쉽게 이해가 갈 수도 있는데, 말 그대로 base(기준점)를 변경(re)한다는 것이다. 이렇게 rebase를 하면 A브랜치의 파생 기준점은 main→new가 된다. 이에 따라 main과 A브랜치를 merge 하면 아래와 같이 모든 변경사항이 담긴 merge가 이루어질 수 있게 된다. ‼️ 주의사항 ‼️ rebase는 위의 예시에서 A브랜치를 새롭게 커밋하여 완전히 새로운 커밋으로 만드는 것이다. 따라서 겉으로 보기엔 A브랜치(커밋)가 똑같이 복사된 것처럼 보이지만, history의 해시코드가 변경된다. 이러한 이유 때문에… 혼자 해당 브랜치 위에서 작업을 하고 있는 경우라면 상관이 없지만, 다른 개발자와 함께 같은 브랜치에서 작업을 하고 있을 경우에는 ‼️ 절대 rebase를 사용해선 안된다‼️ . (merge conflict이 발생할 수 있음) ⇒ 따라서 local작업 환경에서의 commit에 한해서만 활용하는 것이 좋다. (또는 혼자서 특정 브랜치 개발을 하고있을 때!) rebase 방법 옮기고자 하는 브랜치로 이동한다. $ git checkout feature-b $ git rebase master 를 통해 최신 브랜치인 master로 rebase한다 다시 master 브랜치로 checkout 하고 → merge한다 ($ git merge feature-b) 머지된 이전 브랜치들을 삭제한다. cherry pick 🍒 특정한 커밋만 콕 찝어서 최상단 브랜치에 merge하고싶을 때 사용하는 굉장히 유용한 기능이다. $ git hist 또는 $ git log를 통해 원하는 커밋의 해시코드를 복사한다. $ git cherry-pick [해시코드] 이러면 [해시코드] 커밋이 master 또는 main과 같은 최상단 브랜치에 merge된다.","link":"/github/6.rebase/"},{"title":"2. Next.js 기본 활용","text":"설치 및 실행 설치는 원하는 디렉토리에서 아래의 코드를 입력해주면 된다. 12345## 기본 설치 방법$ npx create-next-app@latest## TypeScript 사용 시$ npx create-next-app@latest --typescript 프로젝트가 생성 되었으면 해당 프로젝트를 열고 아래와 같이 실행한다 1234$ npm run dev## or$ yarn dev 기본 구조 잡기 기본 구조를 잡는 것은 지극히 개인 취향이기 때문에 기호에 맞게 설정을 해주면 된다. 필자는 components 폴더를 생성했고, pages 안에 api파일, css 모듈 파일, index.tsx 파일 내의 Header를 제외한 main, footer 코드들을 모두 삭제했다. 12345678910111213141516171819// pages/index.tsximport type { NextPage } from 'next';import Head from 'next/head';const Home: NextPage = () =&gt; { return ( &lt;div&gt; &lt;Head&gt; &lt;title&gt;Meme Generator&lt;/title&gt; &lt;meta name='description' content='Generated by create next app' /&gt; &lt;link rel='icon' href='/favicon.ico' /&gt; &lt;/Head&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;/div&gt; );};export default Home; _app.tsx 모든 페이지들과 컴포넌트들을 하나로 모아주는 역할을 하는 Root 컴포넌트라고 생각하면 된다. ‼️ 주의해야 할 점은, 반드시 파일 명을 _app.tsx로 지정해둬야 한다는 것이다. 파일명을 바꿀 경우 Next.js에서 이를 root Component로 인식하지 못한다. 12345678import '../styles/globals.css';import type { AppProps } from 'next/app';function MyApp({ Component, pageProps }: AppProps) { return &lt;Component {...pageProps} /&gt;;}export default MyApp; _app.tsx는 어떤 경우에 활용하면 유용할까? 전역 CSS의 적용 페이지 이동 시, 유지해야할 state 관리 componentDidCatch 생명주기 method를 통해 공통 에러 처리 할 때 pages Next.js를 처음 사용해보고 굉장히 혁신적이라고 느꼈던 부분을 담당하고 있는 디렉토리다. 한 줄로 요약하자면, pages는 Router의 담당을 하고 있다. 아래의 표를 확인해보자. Route 디렉토리 구조 ‘/’ pages/index.tsx ‘/about’ pages/about.tsx ‘/about/first’ pages/about/first.tsx ‘/profile/:id’ pages/profile/[id].tsx 즉, CRA에서 처럼 라우트 경로를 직접 코드로 짜는 것이 아니라, 라우트 경로에 맞는 이름의 디렉토리와 파일만 생성해주면 되는 것이다. www.test.com/about으로 가고싶으면 about.tsx를 pages내에 생성해주면 된다는 뜻이다. styles CSS파일이 담길 수 있는 폴더다. 하지만 필자는 주로 Styled-Components를 사용하기 때문에, 해당 styles 폴더에는 CSS reset용 globals만 넣어둘 것이다. 따라서 기본적으로 설치되어 있는 Home.module.css 파일은 삭제해주면 된다! 참고로, CSS Reset 에서 Reset CSS 코드를 받을 수 있으니 globals.css에 해당 내용을 붙여넣어보도록 하자! 그리고 _app.tsx파일에 해당 reset css파일을 import 해주면 잘 적용 될 것이다. 123// _app.tsximport '../styles/globals.css'; 이처럼 Reset이 잘 적용된 것을 확인할 수 있다. components 컴포넌트는 CRA때와 같이 동일하게 활용해주면 된다. 하지만 초기 세팅에는 components 폴더가 생성되어 있지 않기 때문에, 최상단 루트에 components 디렉토리를 생성해주기만 하면된다. 굉장히 간략하고 기초적인 포스팅이었다.다음 포스팅에서는 구체적인 Next.js의 기능들과 라우팅 방법 등을 직접 Meme-Generator라는 토이프로젝트를 진행하며 정리해볼 예정이다.","link":"/nextJS/2.nextjsBasic/"},{"title":"1. Next.js의 기본","text":"🤔 NextJS에 대한 개괄적 이해 Next.js는 SSR(Server-Side-Rendering)이 가능한 리액트 기반의 프레임워크다.굉장히 빠른 속도와 편의성을 겸비하여, 많은 기업들이 이 Next.js를 채택하여 사용 중이다. ⇒ NextJS의 주된 특징 및 장점은 이하와 같다. 서버사이드 렌더링이 가능하다. 검색엔진최적화(SEO)에 유리하다. 코드 분할 (Code Splitting) 근데 셋 다 처음 들어본 말들이다… 도대체 무슨 뜻일까? 우선 CSR, SSR, SEO 등에 대해 다루기 전에, 기본적으로 SPA가 무엇인지부터 짚고 넘어가도록 하자. 🎃 SPA란? Single Page Application, 하나의 페이지로 구성된 어플리케이션이다. 우선, SPA에 대해 조금 더 쉽게 이해하기 위해선, 단계적으로 정적 웹사이트와 동적 웹사이트에 대한 이해가 필요하다. 아래의 설명을 간단하게 보며 이해해보자. Static Website 말 그대로 정적인 웹사이트다.화면에 보이는 페이지의 모든 내용들이 html에 담겨있고 그 html을 브라우저가 요청하여 온전한 html이 페이지에 입력되는 것이 특징이다. 이러한 정적 웹사이트에 적합한 사이트는 회사 소개 페이지, 포트폴리오, 블로그 등이 있을 수 있다. Dynamic Website 동적 웹사이트정적 웹사이트와 반대의 개념으로, 동적으로 html이 만들어져 이를 응답 받아 웹에 띄워주는 방식을 사용하는 웹사이트다. 즉, 데이터가 자주 변동되며 페이지의 내용이 자주 인터랙티브하게 바뀌어야 할 때 주로 사용되는 웹사이트라고 생각하면 된다. SPA HTML 태그 자체를 자바스크립트가 동적으로 생성한다. 하나의 파일로 전체 사이트, 즉 여러 페이지를 구현하는 방식의 어플리케이션이라고 생각하면 된다. 한 html페이지에서 자바스크립트를 통해 여러 페이지 및 서비스들을 갈아 끼우는 방식이라고 볼 수 있는 것이다. ⭐️ 서버사이드 렌더링(SSR)? SSR이란, CSR(Client-Side-Rendering)과 대비되는 개념이다. 기본적으로 CSR은 페이지를 렌더링 할 때, JS 파일들을 로드하여 뷰를 띄워준다. 이에 따라 유저는 JS로드가 끝나기 전까지 빈 화면을 보게 되거나 무거운 웹페이지의 경우 오랜 시간을 대기해야 할 수도 있다. 하지만 SSR은 조금 다르다. 쉽게 설명하면 서버에서 사용자에게 보여질 뷰를 미리 그려서 사용자에게 띄워주는 방식을 의미한다. 조금 더 자세히 설명하자면, 초기 렌더링 시에 서버에서 우선적으로 띄워줄 HTML을 클라이언트에게 전달하여 대기시간 없이 뷰를 바로 확인할 수 있도록 하는 것이다. 그리고 이후에 브라우저가 JS파일을 로드하여 React를 실행시킨다. 그리고 이후부터 다른 페이지로의 이동이나 컴포넌트의 변환에 있어서는 브라우저가 CSR 방식으로 작업을 수행한다. 즉, Next.js는 SSR + CSR의 장점들을 합쳐 놓은 프레임워크라고 볼 수 있는 것이다. 🔍 검색엔진 최적화(SEO) 검색엔진 최적화는 말 그대로 “포털 사이트나 검색 엔진 등에서 쉽게 검색에 노출되도록 함”을 의미한다. 기본적으로 검색 엔진들은 자바스크립트를 해석할 수 없다. 따라서 빠르게 HTML 파일 내에서 h1, h2 태그 또는 컨텐츠 내용들을 크롤링 하여 검색결과를 반환해주는 것이다. 하지만 위에서 설명했듯이, CSR은 자바스크립트 파일이 모두 로드 및 실행되기 전까지 HTML이 텅 비어있는 상태를 유지한다. 따라서 검색엔진에 쉽게 노출되기 힘들다는 단점을 안고 있다. 반대로, SSR은 서버에서 기본적인 프론트 HTML 틀을 그려서 유저에게 보내주기 때문에 초기 렌더링 시에도 바로 기본적인 HTML이 채워져 있다. 따라서 검색 엔진에 보다 쉽게 노출될 수 있는 것이다. ✂️ 코드 분할 코드 분할이란 기존의 방식처럼 번들링을 한 번에 처리하는 것이 아닌, 유동적으로 나누어 처리하여 불필요한 코드들이 로드되는 것을 방지하는 기술이다. 번들링이란 사전 뜻 그대로 “묶는 행위“이다. 즉, 자바스크립트 코드들을 하나로 묶는 것을 의미한다고 볼 수 있다. 번들링의 주된 이유는 HTTP 요청을 최소화 하기 위함인데, 여러 개의 JS파일들을 일일히 HTTP요청 보내는 것 보다 하나로 묶어서 보내주는 것이 훨씬 효율적이기 때문이다. 하지만 이런 번들링도 조금 더 효율적일 필요가 있다. 브라우저가 필요로 하는 코드만 전달 받으면 됐지, 필요 없는 코드들 까지 몽땅 전달 받으면 처리 효율성이 떨어질 수 있기 때문이다. 간단한 예시로, 레스토랑에서 나는 스테이크를 먹고싶어서 스테이크를 주문했는데 웨이터가 레스토랑의 모든 메뉴들을 테이블 위에 올려놓고 “골라서 드세요!” 하는 것과 같다고 볼 수 있는 것이다. 이해가 쉽지 않다면, 아래의 그림을 보면 코드 분할이 뭔지 쉽게 감을 잡을 수 있을 것이다. 이렇듯 우리는 Next.js를 통해 좀 더 빠르고 효율적인 성능을 제공받을 수 있는 것이다. 🧵 그럼 CSR + SPA로도 SEO를 챙기려면 어떻게 해야 할까? SPA에는 하나의 정적인 메타 태그들만 담길 수 있기 때문에, SPA와 CSR에서 SEO를 하기 위해선 특정한 추가 작업들이 요구된다. React-HelmetReact-Helmet은 컴포넌트 내에서 메타태그들을 동적으로 변경할 수 있도록 도와주는 라이브러리다. 아래와 같이 설치를 해주고, 123$ npm install --save react-helmet$ yarn add react-helmet 이처럼 컴포넌트 내에서 title과 같은 메타태그를 직접 동적으로 관리할 수 있다. 1234567export const helmetTest = () =&gt; { return ( &lt;Helmet&gt; &lt;title&gt;리액트 헬멧!&lt;/title&gt; &lt;/Helmet&gt; );}; 여기서 끝난다면 굳이 SSR을 사용하지 않아도 될 것 같다…. 하지만 react-helmet만을 사용하게 되면, build를 했을 때 결국 하나의 html파일이 생성되며 SSR로써의 기능이나 SEO의 의미를 상실하게 된다. React-Snap 따라서 Helmet으로 만든 페이지별 html파일들이 빌드될 수 있도록 해야하는데…이를 가능하게 해주는 것이 React-Snap이다. 설치 1$ yarn add --dev react-snap package.json파일 수정 123&quot;scripts&quot;: { &quot;postbuild&quot;: &quot;react-snap&quot;} index.js 수정 12345678import { hydrate, render } from 'react-dom';const rootElement = document.getElementById('root');if (rootElement.hasChildNodes()) { hydrate(&lt;App /&gt;, rootElement);} else { render(&lt;App /&gt;, rootElement);} 물론 이러한 방법들이 이상적인 SEO 방식은 아니지만, 그래도 CSR+SPA의 프로젝트에서 SEO를 할 수 있는 괜찮은 방법 중 하나라고 생각한다. 📝 정리 Next.js는 SSR을 통해 SEO라는 강력한 장점을 우리에게 부여한다. ⇒ HTML을 서버에서 미리 그려서 전달해주기 때문! 코드 분할을 통해 조금 더 효율적이고 향상된 성능을 우리에게 제공한다. ⇒ 내가 원하는 코드만 전달 받아 활용할 수 있기 때문! 포스팅에 참고한 자료Next.JS 공식문서 네이버 D2 : 어서 와, SSR은 처음이지? ivorycode: Next.js를 사용하는 이유","link":"/nextJS/1.whatIsNextjs/"},{"title":"3. Next.js와 styled-components","text":"🤔 뭐가 문제지…? 그냥 생각 없이 “잘 적용되겠지?” 하고 CRA에서와 같이 평소대로 styled-components를 사용했다.근데, 내가 적용한 CSS가 적용되지 않는 문제가 발생했다… 분명 이렇게 떠야 하는데… 이렇게 아래와 같이 CSS가 적용되지 않은 상태의 raw 버튼이 렌더링 되는 것이었다. 분명 뭔가 SSR 방식에 의한 문제일 것이라는 생각이 들었다… Next.js는 SSR 방식을 따르기 때문에 서버에서 HTML을 미리 그린 뒤, 뷰에 띄워준다. 따라서 pre-rendering 과정에서 styled-components가 적용되지 않는 문제라고 생각했다. 즉, styled-components가 적용되기도 전에 컴포넌트가 렌더링 되는 것이 문제라고 본 것이다. 💊 해결 방법 babel-plugin-styled-components 설치1$ npm install --save-dev babel-plugin-styled-components babel 파일 생성해주기 최상단 루트(root 디렉토리)에 .babelrc 파일을 생성해준다. 그리고 아래의 코드를 입력해주면 된다! 12345678910111213{ &quot;presets&quot;: [&quot;next/babel&quot;], &quot;plugins&quot;: [ [ &quot;styled-components&quot;, { &quot;ssr&quot;: true, &quot;displayName&quot;: true, &quot;preprocess&quot;: false } ] ]} _document.tsx 파일 생성 pages 아래에 _document.ts 파일을 생성해준다. 123456789101112131415161718192021222324252627282930import Document, { DocumentContext } from 'next/document';import { ServerStyleSheet } from 'styled-components';export default class MyDocument extends Document { static async getInitialProps(ctx: DocumentContext) { const sheet = new ServerStyleSheet(); const originalRenderPage = ctx.renderPage; try { ctx.renderPage = () =&gt; originalRenderPage({ enhanceApp: (App) =&gt; (props) =&gt; sheet.collectStyles(&lt;App {...props} /&gt;), }); const initialProps = await Document.getInitialProps(ctx); return { ...initialProps, styles: ( &lt;&gt; {initialProps.styles} {sheet.getStyleElement()} &lt;/&gt; ), }; } finally { sheet.seal(); } }} 여기까지 해주면 렌더링 시에도 styled-components가 잘 적용되어 뷰에 나타나게 된다 🙂","link":"/nextJS/3.nextjsAndSC/"},{"title":"4. Next.js에서의 절대경로 설정 방법","text":"🛣️ 절대경로 설정 방법 비교적 짧은 포스팅이 될 것 같다.생각보다 해결 방법이 단순했기 때문이다. tsconfig.json파일을 연다 기존 코드를 아래와 같이 수정한다. 1234567891011121314151617181920{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noEmit&quot;: true, &quot;esModuleInterop&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;incremental&quot;: true, }, &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;]} 123456789101112131415161718192021222324252627// 수정본{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;], &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true, &quot;strict&quot;: true, &quot;forceConsistentCasingInFileNames&quot;: true, &quot;noEmit&quot;: true, &quot;esModuleInterop&quot;: true, &quot;module&quot;: &quot;esnext&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;incremental&quot;: true, // 이 baseUrl과 paths를 추가해주면 된다. &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;@&quot;: [&quot;src/*&quot;] } }, &quot;include&quot;: [&quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;], &quot;exclude&quot;: [&quot;node_modules&quot;]} 수정 결과 아래와 같이 절대경로가 잘 적용되는 것을 확인할 수 있다!","link":"/nextJS/4.absoluePath/"},{"title":"5. SEO와 시멘틱 웹","text":"🥽 SEO와 Sementic Web의 연관성 SEO는 검색엔진 최적화다.즉, 웹사이트에서 나의 글, 자료, 데이터 등이 잘 노출될 수 있도록 최적화 하는 것을 의미한다. 그리고 Sementic Web이란, ‘의미론적인 웹’이라는 뜻을 갖는다.이는 사람과 브라우저, 검색엔진 모두가 쉽게 읽고 해석하기 좋은 HTML문서를 통칭하기도 한다. 그래서 SEO와 Sementic Web에는 어떤 연관성이 존재한다는 것일까? 우선, 우리들의 웹사이트가 기본적으로 어떻게 검색에 노출되는지에 대한 이해가 필요하다. 포털사이트들은 검색엔진을 통해 전세계 웹사이트들의 정보를 수집한다. 메타데이터 : 컴퓨터가 해석하는 언어 자연어 : 인간이 해석하는 언어 검색엔진이 웹사이트 정보들을 긁어 모으는 것을 ‘크롤링’이라고 하는데, 이때 크롤링이 되는 대상이 HTML문서다. 우리가 기존에 코딩을 할 때에는 div를 쓰던, section을 쓰던 똑같은 박스 엘리먼트로 보일 뿐이지만, 컴퓨터는 다르다. 컴퓨터는 우리와 다르게 메타데이터를 통해 웹사이트의 정보를 이해하기 때문이다. 1234// 이 두 코드의 결과물이 우리의 눈에 보여지는 것은 동일하겠지만, 컴퓨터는 다르게 해석한다.&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;header&gt;&lt;/header&gt; 따라서 우리는 인간의 관점에서만 읽기좋은 HTML 문서가 아닌, 컴퓨터(검색엔진)가 이해하기 좋은 HTML 문서의 작성 또한 중시해야 한다. 이를 시멘틱 웹이라고 한다. 즉, 우리는 시멘틱 웹을 구현하며 우리의 웹사이트에 의미와 관련성을 부여하며, 검색엔진에 잘 노출될 수 있도록 해야 한다. 정리! “의미” &amp; “관련성”을 담는다 개발자와 브라우저, 검색엔진 모두가 읽고 해석하기 좋은 문서 div와 span은 non-semantic 요소! 🐳 Sementic Web 가이드 태그 의미 &lt;header&gt; 헤더다! &lt;nav&gt; 네비게이션을 의미한다 &lt;aside&gt; 양 옆 사이드에 위치하는 박스를 의미한다. &lt;article&gt; 주요 내용이 들어가는 박스를 의미한다. &lt;section&gt; article들이 모여있는 박스를 의미한다. &lt;footer&gt; 푸터다! &lt;ol&gt; 순서가 있는 목록 &lt;ul&gt; 순서가 없는 목록 &lt;dl&gt; 정의 목록 &lt;form&gt;에는 Label을 사용해주자! 주로 그냥 귀찮아서 h3태그를 쓰거나, span, div 등을 사용했었다. 하지만 인풋에 대한 이름(라벨)은 반드시 label을 사용해주도록 하자 태그의 의미를 최대한 활용하자 &lt;p&gt; : 문단 &lt;em&gt; : 강조 &lt;strong&gt; : 강한 강조 &lt;section&gt;에는 h1~h2 태그가 포함되도록 하자 &lt;section&gt; 안에는 &lt;header&gt;와 &lt;footer&gt;가 들어가서는 안된다. 정리 및 요약 내 웹사이트가 검색에 노출이 잘 되도록 하기 위해선 시맨틱 웹 표준을 따르자. 시맨틱 웹은 개발자와 컴퓨터, 브라우저 모두가 읽기 쉽고 이해하기 쉬운 코드를 작성하는 것이다. 명확한 기준을 갖고 코드를 작성하자! 포스팅에 참조한 자료Semantic Web | PoiemaWeb","link":"/nextJS/5.seoAndSementic/"},{"title":"리액트 기초","text":"리액트를 사용해야 하는 이유 리렌더링을 할 때 DOM 전체를 다시 갈아끼워 넣는 것이 아니라, 가상 DOM과 기존 DOM의 비교를 통해 변경된 사항만 갈아끼워 넣어 주기 때문에 굉장히 효율적인 View 구성과 리렌더링을 구현할 수 있다. ⇒ 따라서, 단순히 정적인 페이지만을 위한 웹사이트라면 굳이 React를 사용하지 않아도 된다. 하지만 굉장히 동적으로 데이터가 변화하고, View가 변화하는 경우 React를 통해 효율적인 리렌더링과 DOM의 조작을 기대할 수 있다. 렌더링 사용자의 화면에 View를 띄우는(보여주는) 것. 초기 렌더링 과정 ⇒ 렌더링 → HTML마크업 (문자열 코드 생성) → 이를 DOM에 주입 조화 과정 ⇒ 리렌더링이 일어났을 때 기존의 뷰와 변경된 뷰를 최소 연산으로 비교한 후 DOM트리를 업데이트 한다. DOM &amp; Virtual DOM DOM ⇒ Document Object Model, 트리형태의 객체로 문서 구조를 표현한다.ex) html → head, body → title, meta, h1, div 등등 Virtual DOM ⇒ 실제 DOM의 추상화된 사본 → React는 이 Virtual DOM을 사용해 변경사항만을 갈아 끼워 넣는다. JSX 자바스크립트의 확장된 문법으로, XML과의 형식을 띄지만 하나의 자바스크립트 객체다.바벨을 통해 createElement와 같이 자바스크립트 형태의 코드로 반환된다. 문법의 특징 한 컴포넌트에는 반드시 하나의 부모 엘리먼트만 존재해야 한다. 즉, 부모는 형제 엘리먼트가 있을 수 없다. 따라서 부득이한 경우 &lt;Fragment&gt; &lt;/Fragment&gt; 로 감싸서 이 Fragment를 의미없는 부모로써 사용하면 된다. 삼항연산자 (조건부 연산자)를 통한 조건부 렌더링 가능 태그는 반드시 닫혀야 한다. 따라서 &lt;input /&gt;과 같이 self-closing 방법을 사용해야 한다. 컴포넌트 재사용성이 높은 일종의 UI 조각으로, Export → App.js에서 import → 렌더링 Props props를 통해서 컴포넌트에서는 “여기에는 이런 인자가 들어갈거야!”⇒ App.js에서는 “응 그 인자의 값들은 이거야!” 하고 설정해주는 것 간단한 활용 예제 ⇒ Todo List에서 하단 “+”버튼을 누르면 해당 버튼의 색상이 rotate &amp; 색상변경 된다. 1234567891011const button = styled.`${props =&gt; // props 중에 open이라는 놈 있지? 그 놈이 true이면 ~~ props.open &amp;&amp; css ` background-color : #F73859; transform : translate(-50%, 40%) rotate(45deg);`}`// 위의 중괄호 안의 뜻은 ==&gt; button에 props가 있는데,// 그 props 중에 open이라는 녀석의 값이 true면 아래와 같은 css값을 줄거야! 12345678910function test() { // 우선 isOpened의 초기값은 false이고, setOpen()을 통해서 이걸 컨트롤 const [isOpened, setOpen] = useState(false); // onClick -&gt; onToggle 실행 ==&gt; setOpen(isOpened 기존값의 반대를 줄거야) const onToggle = () =&gt; setOpen(!isOpened); return ( // open이라는 props의 값은 isOpened의 값 &lt;button onClick={onToggle} open={isOpened} /&gt; );}","link":"/react/1.Basic/"},{"title":"useState 올바르게 사용하기","text":"💡 state란? 필자는 이전까지, 그냥 state는 자주 변동되는 값을 담는 그릇이라고만 생각해왔었다. 하지만, React를 계속 사용하다 보니 state에 대한 피상적 이해만으로는 React를 깊게 이해하고 개발을 하는데 무리가 있다는 판단이 들어 state를 다시 정리해보고자 한다. state의 정의 state는 값이 계속 변경되는 동적 데이터로, 컴포넌트 간의 상호작용을 담당하기도 한다. 또한, state의 값이 변경되면 컴포넌트는 리렌더링 된다. state가 되기 위한 조건우선, 모든 학습에 앞서 state가 무엇인지에 대한 명확한 이해가 필요하다..!! 그렇다면 state란 무엇일까? 아래의 질문들에 직접 답변을 해보자 (해당 질문에 state가 포함 되는지). state 데이터가 계속 변동되는가? 부모로부터 전달 받은 props인가? 특정 state로부터 어떠한 계산을 통해 도출되는 데이터인가? 결론부터 얘기하자면 정답은 OXX다. state는 정적 데이터가 아닌, 동적 데이터다. 따라서 변하지 않고 고정된 데이터를 state로 활용하는 것은 옳지 않다. 정적 데이터는 const에 상수로써 담아 활용하는 것이 옳다고 할 수 있다. 부모로부터 전달 받은 props는 props일 뿐이다. state는 하나의 컴포넌트 안에서 관리되는 데이터로, state를 사용할 때는 관리 및 사용하는 컴포넌트(부모)와 이를 활용하는 컴포넌트(props로 받아 활용하는 자식 컴포넌트)로 철저히 분리하여 사용해야 한다. 우리는 중복배제 원칙을 항상 생각하며 state의 최소집합을 고려해야 한다. 아래의 예시를 보자. 12const [todos, setTodos] = useState([]);const [todoCount, setTodoCount] = useState(0); 이는 효율적이지 못한 state 활용 방식이다. 굳이 todoCount라는 state를 생성하지 않아도 우리는 todos.length 등을 활용해 해당 값을 언제든지 구할 수 있다. 그냥 아래와 같이 꼭 필요한 state만 활용해보는게 어떨까? 불필요한 리렌더링을 방지하자! 12const [todos, setTodos] = useState([]);const todoCount = todos.length; 🤷🏻‍♂️ state와 props의 차이점 props는 property의 줄임말로, state와 언뜻 보기에는 비슷하지만 분명한 차이점을 보유한다.물론 state와 동일하게 props가 변경되면 컴포넌트는 리렌더링 된다. props는 컴포넌트 간에 전달되는 데이터다. 즉, 함수 안의 매개변수, 인자와 같은 역할을 하는 것이다. 반면, state는 함수 안에서만 활용되는 ‘함수레벨 스코프’의 변수이자 Javascript 객체와 같다고 볼 수 있다. props는 변경될 수 없다. state는 setState를 통해 컴포넌트 내에서 언제든지 변경될 수 있다. 하지만 props는 ‘읽기 전용’으로, 참조만 할 뿐 직접적으로 이를 변경할 수는 없다. 위에서 설명한 관리자 vs 사용자가 명백히 구분되어 있다는 것이 이를 의미한다. ✨ useState를 올바르게 사용하는 방법 state를 통해 계산될 수 있는 값은 굳이 useState()에 담지 않아도 된다. 위에서 설명했듯, 기존의 state를 통해 계산될 수 있는 값이라면, 그냥 상수 또는 변수로써만 사용해도 충분하다. setState()가 useEffect 내에서 비동기적으로 사용될 경우, state로 사용하지 않는다. 굉장히 중요한 진리와도 같은 제언이다. 아래의 예시를 봐보자. 1234567891011121314151617const [product, setProduct] = useState(null);const [price, setPrice] = useState(null);useEffect(() =&gt; { const fetcher = async () =&gt; { const result = getProduct(); setProduct(result); }; fetcher();}, []);useEffect(() =&gt; { if (product) { setPrice(getPrice(product)); return; }}, [product]); 이 경우, useEffect가 두 번 쓰였다. 컴포넌트가 렌더링 됐을 때 product를 utils의 유틸함수에서 받아오고, product가 존재하면 setPrice를 통해 price가 업데이트 된다. 근데… 그냥 이렇게 사용하면 되지 않을까? 12345678910const [product, setProduct] = useState(null);const price = product &amp;&amp; getPrice(product);useEffect(() =&gt; { const fetcher = async () =&gt; { const result = getProduct(); setProduct(result); }; fetcher();}, []); 즉 이는 위에서 설명한 1번 조건과도 연결이 되는 것이다. product라는 state의 유무에 따라 price값이 정해져야 하는 것인데, 이는 충분히 product라는 state 하나만으로도 구현할 수 있기에 굳이 price라는 state를 하나 더 만들 필요가 없는 것이다. 포스팅에 참고한 자료react-guide/props-vs-state.md at master · uberVU/react-guide Lucy | ReactJS: Props vs. State useState 과도하게 사용하지 않기","link":"/react/2.useState/"},{"title":"useEffect 올바르게 사용하기","text":"💡 useEffect란 무엇인가? useEffect란, 함수형 컴포넌트에서의 side-effects 활용을 위한 Hooks다.근데 도대체 이게 무슨 말일까…?? 😅 우선 이전까지 내가 피상적으로만 이해했던 **useEffect**의 개념은, 컴포넌트가 render됐을 때, 또는 특정 state에 변화가 생겼을 때 원하는 함수 및 로직을 실행하고싶을 때 활용하는 것이었다. 하지만 이렇게만 이해하고 useEffect를 사용하니, dependencies 관련 문제에도 직면하고, 옳지 못한 방향으로 useEffect를 남발하는 지경에 이르기 까지 했다. 따라서 이번 기회에 useEffect에 대해 제대로 정리하여 좀 더 효율적으로 React를 활용해보고자 한다. 🤔 side-effectsside-effects란, 특정 함수가 컴포넌트의 output 자체에 목적을 두는 것이 아닌 특정 기능을 수행하기 위해 기능하는 것을 의미한다. 즉, setTimeout(), fetch request, DOM을 직접적으로 조작하는 것 등, 명확한 return값 반환을 목적으로 하지 않는 함수 또는 계산을 뜻한다고 할 수 있다. 아래의 예시를 확인해보자 12345const Profile = ({ name }) =&gt; { const message = `안녕하세요 ${name}님!`; document.title = `${name}님의 프로필`; return &lt;h3&gt;{message}&lt;/h3&gt;;}; 이 코드는 올바르게 짜여진 코드라고 할 수 있을까? 그렇지 않다. 위에서 설명했듯이 document.title의 값을 바꿔주는 기능은 side-effect인데, 함수형 컴포넌트 내에서 저렇게 코드를 써버리면 컴포넌트가 렌더링 될 때마다 document.title이 재정의 될 것이다. 우리가 바라는 것은 name의 값이 변경되었을 때만 document.title을 변경하는 것이기 때문에 이를 **useEffect**를 통해 핸들링 해줘야 하는 것이다. 12345678// 이게 바르게 된 코드 및 useEffect, side-effect의 활용법이라고 할 수 있다.const Profile = ({ name }) =&gt; { const message = `안녕하세요 ${name}님!`; useEffect(() =&gt; { document.title = `${name}님의 프로필`; }, [name]); return &lt;h3&gt;{message}&lt;/h3&gt;;}; 🥑 useEffect의 기본 형태 **useEffect**는 아래와 같이 기본적으로 두 개의 인자로 이루어진다. **callback** ⇒ 콜백 함수는 기본적으로 side-effect를 위한 로직을 담은 함수다. 이전 포스트에서도 설명했듯이, useEffect 내에 setState()함수가 담기는 것은 권장되지 않는다. **dependencies** ⇒ useEffect 내의 callback 발동을 위한 하나의 조건이라고 생각하면 된다. 만약 의존성 배열(dependencies)가 비어있다면, 이는 “컴포넌트가 렌더링 됐을 때 한 번만 실행한다” 라는 것을 의미한다. 하지만 이외에 의존성 배열 내에 state 또는 props가 담겨있으면, 해당 값들이 변경됐을 때 callback을 실행하겠다는 것을 의미한다. 🍼 의존성 배열 (dependencies array) 위서에서 설명했듯, 의존성 배열에 무엇이 담겨 있느냐에 따라 useEffect 내의 callback 실행 여부가 결정된다. 그렇다면 의존성 배열에는 어떤 형태들이 존재할까? 의존성 배열 자체가 선언되지 않은 경우 ⇒ 컴포넌트가 렌더링 될 때마다 callback이 실행되도록 한다. (리렌더링 포함) 빈 배열만 선언된 경우 ⇒ 컴포넌트가 최초 렌더링 됐을 때, 딱 한 번만 callback이 실행된다. props 또는 state가 선언된 경우 ⇒ 해당 props 또는 state가 변경되었을 경우에만 callback이 실행된다. 🧬 컴포넌트 생명주기 (Component Lifecycle) useEffect를 위한 컴포넌트 생명 주기는 크게 두 가지로 정리될 수 있다.Component Did Mount, Component Did Update다. componentDidMount와 ComponentDidUpdate 등은 모던 리액트만을 학습한 사람들에게는 낯선 단어일 수 있다. 이는 이전에 자주 사용되던 class형 컴포넌트에서 활용되던 개념이기 때문이다. 쉽게 설명하자면 componentDidMount는 말 그대로 컴포넌트가 렌더링 됐을 때를 의미하며, componentDidUpdate는 컴포넌트가 업데이트 됐을 때를 의미한다. componentDidMount 위에서 설명했듯, 이는 useEffect에서 빈 배열만 의존성 배열에 선언됐을 경우를 의미한다. componentDidUpdate 이는 useEffect에서 의존성 배열에 특정 props 또는 state가 선언됐을 경우를 의미한다. 🧹 Cleanup Function Cleanup Function이란, 컴포넌트가 unmount되기 전 또는 업데이트 되기 직전에 특정한 작업 및 기능을 수행할 수 있도록 도와준다.또한, 메모리 누수를 방지해주며 원치 않는 결과가 도출되지 않도록 사전에 차단해주는 역할을 한다. 기본 형태123456useEffect(() =&gt; { // side-effect logic return () =&gt; { cleanup; };}, [input]); 우리가 위와 같이 useEffect 내에 return으로 함수를 정의하면, useEffect는 이 함수를 cleanup 함수로 인식한다. cleanup function의 작동 순서 image from Dmitri Pavlutin’s post. 컴포넌트가 최초 렌더링 됐을 때는 cleanup function이 동작하지 않는다. 그 이후의 렌더링 시에, 이전 side-effect값을 참조하여 이를 기반으로 최신화된 side-effect를 실행시킨다. 컴포넌트가 언마운트 될 때 cleanup function이 마지막으로 실행되며 이는 최신화된 cleanup function이다. cleanup function이 왜 필요한가?아래의 코드 예시를 보면, 해당 useEffect에는 cleanup function이 선언되어있지 않다. 이 경우에는 이전에 활용되었던 모든 message props들이 2초마다 찍히게 된다. 12345678import { useEffect } from 'react';function RepeatMessage({ message }) { useEffect(() =&gt; { setInterval(() =&gt; { console.log(message); }, 2000); }, [message]); return &lt;div&gt;I'm logging to console &quot;{message}&quot;&lt;/div&gt;; restless-wildflower-c0cfw 우리가 바라는 것은 최신화된 message props만을 console.log()로 찍어내는 것이다. 이 때문에 우리는 cleanup function을 사용하는 것이다. 123456789101112import { useEffect } from 'react';function RepeatMessage({ message }) { useEffect(() =&gt; { const id = setInterval(() =&gt; { console.log(message); }, 2000); return () =&gt; { clearInterval(id); }; }, [message]); return &lt;div&gt;I'm logging to console &quot;{message}&quot;&lt;/div&gt;;} 이렇게 하면 우리는 이전에 사용됐던 message props를 제거하고, 최신화된 props만 찍어낼 수 있다. 코드샌드박스 예시 포스팅에 참고한 자료A Simple Explanation of React.useEffect()","link":"/react/3.useEffect/"},{"title":"useRef 올바르게 사용하기","text":"💡 useRef란? 우리는 바닐라 자바스크립트에서 querySelector, getElementById 등을 이용해 DOM을 직접적으로 선택하여 활용하곤 했었다. 하지만 리액트에서는 직접 DOM에 접근하여 조작하는 것을 권장하지 않기에 우리는 Ref를 활용해야 한다. 즉, 우리는 useRef라는 내장 hooks를 통해 DOM에 접근할 수 있고, 이를 리액트 컴포넌트 내에서 활용할 수 있는 것이다! 하지만 useRef는 단순히 DOM에 접근하기 위해서만 사용되는 것은 아니다. 데이터를 담는 저장소로써의 역할도 하는데, 데이터 저장소로써의 역할에 대해 먼저 이해한 뒤 DOM 접근 용도에 대해서 알아보도록 하자. 우선 간단하게 useRef의 개괄적인 코드 형태부터 알아보자. 1234567import { useRef } from 'react';export const Count = () =&gt; { const countRef = useRef(); console.log(countRef.current); return &lt;div&gt;Count!&lt;/div&gt;;}; 이게 가장 기본적인 useRef의 코드 구조다. 하지만 useRef를 처음 접해보는 사람들은 중간에 쓰인 current가 도대체 뭔지 의문부터 들었을 것이라 생각된다. ref.current? current는 쉽게 말해 데이터를 담는 상자(오브젝트)라고 볼 수 있다.즉, 위에서 말했듯이 ref가 꼭 DOM에만 접근하기 위한 것은 아니라는 뜻이다. ref.current는 참조값에 접근하여 업데이트된 새로운 값을 current에 담는다. 위의 코드 예시를 예로 들자면, div라는 참조값에 뭔가 변화가 생기면 (물론 div가 변할 일이 뭐가 있겠냐만은…) 우리의 ref.current는 이를 감지하고 새로운 값을 담아내어 업데이트 하는 것이다. 조금 더 쉽고 직관적인 방식으로 예를 들어보면, 12345678910import { useRef } from 'react';export const Count = () =&gt; { // 우리는 이와 같이 count 횟수에 대한 값을 useRef.current에 담아 사용할 수 있는 것이다. const countRef = useRef(0); const handleClick = () =&gt; { countRef.current += 1; }; return &lt;button onClick={handleClick}&gt;클릭해주세요&lt;/button&gt;;}; 근데… 그럼 이게 state와 다른 점이 뭘까? 아래에서 더 자세히 알아보도록 하자. 🔮 useRef의 특징 (중요) 아래의 두 룰은 반드시 숙지해야 하는 useRef의 핵심 개념이다. 참조값이 변해도 리렌더링을 야기하지 않는다. 컴포넌트가 리렌더링 되더라도 참조값은 유실되지 않는다. 글만 봐서는 감이 잡히지 않을 수도 있는데, 위에서 활용했던 Count 컴포넌트의 예시를 활용해 더 자세히 설명해보도록 하겠다. 12345678910111213import { useRef } from 'react';// useRef() 안에 들어가 있는 값은 초기값이다. (default value)export const Count = () =&gt; { const countRef = useRef(0); const handleClick = () =&gt; { countRef.current += 1; console.log(`저는 ${countRef.current}번 클릭되었습니다!`); }; console.log('저는 렌더링 될 때마다 출력됩니다!'); return &lt;button onClick={handleClick}&gt;클릭해주세요&lt;/button&gt;;}; 위의 코드에서 만약 count 횟수를 담는데 state를 사용하고, setState()를 통해 count값을 업데이트 해줬다면 어땠을까? state의 변화는 컴포넌트의 리렌더링을 야기하기 때문에 count 횟수가 변동될 때마다 컴포넌트가 리렌더링 되었을 것이다. 하지만 위의 useRef의 예시에서는 count 횟수가 증가해도 컴포넌트가 리렌더링 되지 않는 것을 확인할 수 있다. 🎲 DOM에 접근하기 이제 DOM에 접근하기 위한 용도로써의 useRef에 대해 알아보도록 하자. useRef를 통해 특정 DOM에 접근하여 참조하는 것은 아래의 코드 방식을 따른다. 1234567891011import { useRef, useEffect } from 'react';function ToDom() { const domRef = useRef(); useEffect(() =&gt; { const divElement = elementRef.current; // // &lt;div&gt;나를 참조해주세요&lt;/div&gt;가 출력될 것이다. console.log(divElement); }, []); return &lt;div ref={domRef}&gt;나를 참조해주세요&lt;/div&gt;;} 위의 코드를 글로써 다시 정리하자면… 우선, const something = useRef();와 같이 참조값을 정의하고 그 참조값을 DOM에 담아준다. &lt;div ref={something}&gt; &lt;/div&gt; 그리고 컴포넌트가 마운트 되면 우리의 something이라는 ref는 div DOM을 가리키게 된다. 타입스크립트에서의 방법 (추가) TODO 앱을 만들다가 input의 자동 포커싱 기능을 구현하려 했는데, 타입스크립트에서의 useRef방식에는 몇 가지 룰이 존재했다… 따라서 이를 추가적으로 기록해보고자 한다. 내가 간과했던 것은 초기 렌더링 시에는 참조값이 null이기에, useEffect 내에서 current가 비어있는지 여부를 우선적으로 체크해줘야 했는데 이를 빼먹었다. 아래의 코드를 봐보자! 12345678910111213import { useRef, useEffect } from 'react';function ToDom() { // HTMLInputElement 타입을 지정해주고, 초기값을 null로 설정해준다. const inputRef = useRef&lt;HTMLInputElement&gt;(null); useEffect(() =&gt; { // 이렇게 inputRef.current가 비어있는지 아닌지를 체크해야 오류가 나지 않는다. (초기 렌더링 시에는 current가 null로 비어있음) if (domRef.current) { inputRef.current.focus(); } }, []); return &lt;input type='text' ref={domRef} /&gt;;} 마무리 여기까지가 useRef의 기본 중의 기본이다.참고로 첨언하자면, 참조값을 변화시키고 싶을 때는 함수형 컴포넌트 내에서 바로 변화를 주는 것이 아니라, useEffect나 핸들링 함수 내에서 변화를 주는 것이 좋은 방식이라고 한다! 아직은 너무 기본적인 것들 뿐이고 부족한 것이 많지만… 기본적인 hooks들에 대한 공부를 우선적으로 마치고, 더 깊은 개념들과 활용법들에 대해 공부해볼 계획이다. 포스팅에 참조한 자료The Complete Guide to useRef() and Refs in React","link":"/react/4.useRef/"},{"title":"useMemo 바르게 알고 사용하기","text":"📝 useMemo란? useMemo는 리액트 컴포넌트 내에서 메모이제이션(Memoization) 기술을 사용하여 성능을 높여줄 수 있도록 지원하는 Hook이다. 첫 문장부터 막막하다… 메모이제이션이 도대체 뭘까? Memoization 메모이제이션은 동일한 계산이 반복되는 경우, 초기의 계산 결과를 메모리에 저장한 뒤 필요에 따라 활용할 수 있도록 활용하는 기법이다. 즉, 우리는 메모이제이션을 통해 중복 계산을 방지하고 메모리라는 공간을 활용해 계산에 소요되는 시간을 줄일 수 있는 것이다. 따라서 우리는 이러한 메모이제이션 기법을 useMemo() Hook을 통해 활용할 수 있고, 리액트 컴포넌트의 성능을 최적화 또는 향상시킬 수 있다. 그럼 이제 useMemo에 대해 자세히 알아보도록 하자. 기본 형태 useMemo() Hook의 기본 구조는 아래와 같다. 1const memoizedData = useMemo(function[, dependencies]); “의존하고 있는 값이 변경될 때만 function이 실행된다” 컴포넌트 최초 렌더링 시에 useMemo는 선언된 function을 실행하고 그 결과값을 memoize한다. 그리고 컴포넌트가 리렌더링 됐더라도 뒤에 선언된 의존성 배열(dependencies)에 변화가 없다면 useMemo는 function을 실행시키지 않는다. 하지만 만약 dependencies에 변화가 생겼다면 useMemo는 함수를 실행시켜 새로운 값을 memoize한다. 이게 useMemo의 핵심이다. 즉, dependencies에 들어가는 것은 주로 props 또는 state가 될 것이므로, 우리는 state나 props를 통해 계산되는 특정 값들을 memoize하여 활용할 수 있는 것이다. 예를 들면 state 배열의 길이라던지, 마지막에 저장된 state의 id값이라던지… 이런 것들을 렌더링마다 매번 계산하지 않아도 된다. 그럼 이제 아래에서 useMemo의 활용 방법 및 예시를 훑어보도록 하자. 😼 useMemo의 활용 친구의 수를 세는 컴포넌트가 아래와 같이 있다고 가정을 해보자. 12345678910111213141516171819202122232425export default function Friend() { const [friends, setFriends] = useState([0, 1, 2, 3, 4]); const [dummy, setDummy] = useState(0); // 1. 컴포넌트 렌더링마다 이 컴포넌트는 친구의 수를 센다. const friendLength = friendCount(friends); // 3. 친구 추가 버튼을 누르면 임의의 친구 0이 추가된다. const handleAddFriend = () =&gt; { setFriends([...friends, 0]); }; // 4. 리렌더링 버튼을 클릭하면 dummy state가 변경되며 리렌더링을 야기한다. const handleRerender = () =&gt; setDummy((el) =&gt; el + 1); return ( &lt;div&gt; 당신의 친구는 총&lt;span&gt; {friendLength}&lt;/span&gt;명입니다. &lt;button onClick={handleAddFriend}&gt;친구 추가&lt;/button&gt; &lt;button onClick={handleRerender}&gt;리렌더링&lt;/button&gt; &lt;/div&gt; );}function friendCount(friend) { // 2. 친구의 수를 세고 아래와 같은 문구를 출력하며 친구 수를 리턴한다. console.log('친구 수 세기 완료!'); return friend.length;} 위의 경우에서 우리는 두 개의 state를 갖고있다. 하나는 친구목록과 하나는 그냥 의미 없는 dummy state다. 그리고 컴포넌트가 렌더링 되면 friends라는 state를 활용하여 친구의 수를 계산하게 된다. 하지만 코드를 실행시켜보면 리렌더링을 클릭했을 때, 친구의 수에는 변화가 전혀 없음에도 친구 수를 다시 계산하고 “친구 수 세기 완료!” 문구가 출력되는 것을 볼 수 있다. 얼마나 비효율적인 일인가? 친구 수를 다시 셀 필요가 없는데도 우리는 친구 수를 렌더링이 될 때마다 계산을 하고 있는 것이다. 이 때문에 우리는 useMemo를 활용해야 하는 것이다. 하지만 위와 같이 firendLength를 계산받는 코드를 useMemo를 통해 수정하면, 리렌더링 버튼을 눌러도 친구 목록에 변화가 없는 한, 계산이 불필요하게 실행되지 않는 것이다. (물론 위의 예시는 여러번 해도 상관 없는 가벼운 계산이지만 ^^..) 아래의 링크를 통해 코드를 직접 실행해볼 수 있으니 궁금하다면 직접 코드를 확인해보길 바란다! FriendCount ⚠️주의사항 (useMemo vs useCallback) useMemo는 useCallback과 매우 유사하다.이에 따라 두 Hook의 차이점을 분명히 짚고 넘어가야 한다. 반환값 Hook 무엇을 반환하는가? useMemo() “값” useCallback() “함수” 즉, useMemo는 값을 저장하고, useCallback은 함수 자체를 저장하는 것이다. 인자를 받을 수 있는가? useMemo는 값을 저장하기 위한 Hook이기 때문에 함수 안에 인자를 활용할 수 없다. 하지만 useCallback은 함수를 반환하기에 아래와 같이 인자를 활용할 수 있다. 123useCallback(foo(bar), []);// 하지만 useMemo에서 인자가 사용되어도 React는 이를 무시한다. 근데 그렇다고 하더라도.. useCallback과 useMemo는 너무 비슷해 보인다. 실제로 useCallback은 거의 모든 상황에서 useMemo를 대체할 수 있다. 실제로 리액트 공식 문서에서는 아래와 같이 useMemo와 useCallback의 공통점을 인정한다. 그리고 공식문서에 따르면, useMemo가 조만간 삭제될 수도 있다고 한다…","link":"/react/5.useMemo/"},{"title":"[React] 이미지 미리보기 기능 구현 방법","text":"React에서 이미지 미리보기 기능 구현하기 리액트에서 이미지 파일을 업로드 하기 전 단계에서, 해당 이미지의 미리보기를 확인할 수 있는 기능 구현에 대해 다뤄보고자 한다. 어떤 태그들이 사용되는가? 우선 이미지 파일을 업로드 하기 위해선 input 태그와 label 태그가 필요하다. 12&lt;label htmlFor=&quot;optionImage&quot;&gt;+ 이미지 첨부&lt;/label&gt;&lt;input type=&quot;file&quot; id=&quot;optionImage&quot; name=&quot;optionImage&quot; accept=&quot;image/*&quot; onChange={e =&gt; getImageUrl(e)}/&gt; 하지만 이 상태로 두는 것이 아니라, input 태그 자체는 보이지 않도록 가려줘야 한다. 우리에게는 +이미지 첨부의 버튼 모양만 필요하기 때문에, 이 +이미지 첨부를 label을 통해 버튼과 같이 만들어주면 된다. input에는 display:none;을 주고, label에는 border, cursor: pointer; 등을 주면 버튼같이 생긴 label만 사용자에게 보여지게 되는 것이다. 내가 원하는 파일만 입력되도록 하기 input 태그 내에 accept=””를 활용하면 파일을 업로드 할 때, 내가 원하는 파일 및 확장자만 업로드 할 수 있도록 강제할 수 있다. 12345// 아래와 같이 모든 확장자의 이미지 파일만 받아올 수도 있고&lt;input type=&quot;file&quot; accept=&quot;image/*&quot;/&gt;// 특정 확장자만 업로드할 수 있도록 설정할 수도 있다.&lt;input type=&quot;file&quot; accept=&quot;image/png&quot;/&gt; 이미지 미리보기 기능 구현 이제 이미지를 파일 선택창에서 선택하고, 해당 이미지의 미리보기만 화면에 표시해주면 된다. 여기서 원하는 파일을 선택한 후에, 해당 파일의 url 값을 받아올 수 있다. URL.createObjectURL() 이 js 내장 기능을 활용하면 손쉽게 내가 방금 업로드한 파일의 URL 주소를 얻을 수 있다. 12345678910111213141516// input태그에 아래와 같이 onChange 이벤트에 대한 함수를 걸어준다.&lt;input type='file' accept='image/png' onChange={(e) =&gt; { getImageUrl(e); }}/&gt;;// 그리고 e.target.files[0]를 통해 해당 파일에 직접적으로 접근하고const getImageUrl = (e) =&gt; { let file = e.target.files[0]; // 해당 파일을 URL.createObjectURL()에 담아주면 우리는 url값을 얻을 수 있다. let url = URL.createObjectURL(file); setImgUrl(url);}; 이제 여기서 얻은 url 값을 img 태그 내의 src에 넣어주면 된다! 1&lt;img src={imgUrl} alt='optionImage' /&gt;","link":"/react/imagePreview/"},{"title":"React 슬라이딩 캐러셀 만드는 법 (Slider, Carousel)","text":"이전에 진행했던 ‘디스트리’ 프로젝트에서 끊기지 않는 무한 슬라이딩 캐러셀을 만들어보려다 실패한 경험이 있다. 당시에는 react는 물론이고 javascript도 잘 다루지 못했던 때라 이번 기회를 빌어 무한 슬라이딩 캐러셀 제작법을 정리해보려 한다. 메인 컨셉 가장 중요한 구현 컨셉은, 양쪽에 fake 배너를 만들어줘서 눈속임을 줘야 한다는 것이다.물론 실제로 모든 배너들이 3D로 연결되어 무한 슬라이딩을 구현하면 좋겠지만 쉽지 않은 것이 현실이다. 따라서 아래와 같이 가짜 배너를 양 끝에 배치시켜야 한다. 이해가 아직은 쉽지 않을 수 있는데 두 번째 그림을 보면 쉽게 이해될 수도 있다. 쉽게 설명하면 transition의 특성을 이용한 것이다.우리는 각 슬라이드들이 넘어가는 것을 어떻게 인지할까?첫 째,그림이 바뀌는 것을 인지하는 것, 그리고 둘 째, 같은 그림이더라도 넘어가는 과정의 transition을 통해 배너가 슬라이딩 되는 것을 인지한다. 하지만 아래와 같이 가짜 배너 1번이 화면 중앙에 위치해 있을 때 transition을 제거해주고 원래 진짜 1번의 위치로 이동시키면 트랜지션 효과도 없을 뿐더러 같은 그림에서 같은 그림으로 변경되기에 우리는 배너의 변화를 눈으로 알아챌 수 없다. 따라서 아래 그림에서와 같이, 진짜 4번 → 가짜 1번으로의 이동이 끝난 시점(transitionend)에 transition을 제거한 뒤 -&gt; 진짜 1번의 위치로 이동하게 되면, 사람의 눈으로 봤을 때 그대로 1번에 고정되어있는 것과 같은 착각을 일으킨다. 따라서 이 방법을 사용하면 슬라이드가 끊기지 않고 계속 연결되며 슬라이딩 되는 것과 같은 효과를 줄 수 있는 것이다. 각 배너들이 담길 Carousel을 만든다12345678// 기본 구성은 이하와 같다. main이라는 큰 틀 안에 carousel을 만들어주고, 그 안에 각자 이미지 배너들을 넣어주면 된다.&lt;div className='main'&gt; &lt;ul className='carousel'&gt; &lt;li className='banner'&gt; &lt;img src='#' alt='' /&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 위치 조정 위에서 미리 짜둔 구조에 맞춰 이미지를 넣고 overflow:hidden 을 해주면 이와 같은 모양새가 나온다.하지만 이는 정렬이 되지 않은 날 것의 상태이기 때문에 transform:translateX() 를 통해 위치를 조정해줘야 한다. 이런 초기값에서 우리가 바라는 디폴트 값은 이와 같은 형태로 정렬된 상태여야 한다. 이를 위해선 transform:translateX()를 통해 얼만큼 움직여야 원하는 배너가 중앙에 위치할 수 있는지 계산해줘야 한다. 거리 계산 방법 (지극히 주관적) 우선, 좌측 끝에서 중앙에 위치시키고 싶은 배너의 좌측 끝부분 까지의 거리를 구한다. 그리고 해당 배너가 중앙에 위치하게 된다면 남게 될 좌측 공백의 거리를 계산한다. 이제 두 값을 빼면 transform을 통해 초기에 움직여야 하는 거리가 계산된다. 종합적인 그림 예시로 다시 요약을 하자면… 왼쪽끝 ~ 중앙에 위치하길 바라는 배너의 좌측 끝 (BannerWidth + margin)에서 해당 배너가 중앙에 위치했을 때 남는 좌측 공백값을 빼주면 얼만큼 이동해야 배너가 중앙에 위치하는지 계산할 수 있다. 그럼 이제 슬라이딩을 어떻게 구현하면 될까? 우선 슬라이드를 움직일 버튼 두 개를 만들고, 각 버튼의 onClick 이벤트에 함수를 걸어준다. 1234567// mdArrow는 방향표시 svg react icons이므로 크게 신경 쓸 필요 없다.&lt;button className=&quot;leftArrow&quot; onClick={moveLeft}&gt; &lt;MdArrowBackIosNew /&gt;&lt;/button&gt;&lt;button className=&quot;rightArrow&quot; onClick={moveRight}&gt; &lt;MdArrowForwardIos /&gt;&lt;/button&gt; moveLeft와 moveRight함수의 코드 로직 우선, 현재 가운데에 위치해 있는 배너가 몇 번째 배너인지 체크하기 위한 currentIndex state가 필요하다. 그리고 필자는 추가적으로 얼만큼 움직여야 하는지를 css에 전달해 줄 distance, 그리고 transition값을 css에 전달해 줄 timing이라는 state도 추가해 활용했다. 12345678910111213141516171819const moveLeft = () =&gt; { // 일반적인 transtion 슬라이딩일 경우에는 그냥 index값을 감소시켜주고, 트랜지션 값도 0.3초를 준다. // 그리고 계속 배너의 넓이 + margin값 만큼 좌측으로 이동시켜준다.(기존 거리 - 더 이동해야 하는 거리) if (currentIndex &gt; 2) { setCurrentIndex(currentIndex - 1); setTiming(0.3); setDistance(distance - 64.5); return; }};const moveRight = () =&gt; { if (currentIndex &lt; 12) { setCurrentIndex(currentIndex + 1); setTiming(0.3); setDistance(distance + 64.5); return; }}; 12345678910// SCSS에서 state를 이하와 같이 전달받아 활용했다.// useRef를 쓸까도 고민했지만, 일단 state로 관리하는게 더 편할 것 같아서 이와 같이 구현했다.const Slider = styled.div` position: relative; display: flex; width: 100%; height: 100%; transform: ${(props) =&gt; `translateX(-${props.distance}vw)`}; transition: ${(props) =&gt; `transform ${props.timing}s ease`};`; 슬라이드가 끝에 닿았을 때의 코드 로직 (중요) 이제 transition 값을 none으로 지정해준 뒤, 가짜 배너에서 진짜 배너로 이동시켜주는 눈속임을 행해야 할 때다. 123456789101112131415161718// 슬라이더 안에 props로써 distance, timing 들을 넣어준다.// 그리고 onTransitionEnd 이벤트를 리스닝 하도록 한다.&lt;div ref={slideCarousel} distance={distance} timing={timing} onTransitionEnd={handleFlip}&gt; &lt;Banner&gt;4&lt;/Banner&gt; // 가짜 &lt;Banner&gt;5&lt;/Banner&gt; // 가짜 &lt;Banner&gt;1&lt;/Banner&gt; &lt;Banner&gt;2&lt;/Banner&gt; &lt;Banner&gt;3&lt;/Banner&gt; &lt;Banner&gt;4&lt;/Banner&gt; &lt;Banner&gt;5&lt;/Banner&gt; &lt;Banner&gt;1&lt;/Banner&gt; // 가짜 &lt;Banner&gt;2&lt;/Banner&gt; // 가짜&lt;/div&gt; 이제 onTransitionEnd에 의해 실행되는 함수 handleFlip 코드를 작성해주면 된다. 예를 들어 가짜 9번으로 이동이 끝났을 때 (좌측이동) 진짜 9번으로 트랜지션 없이 이동하면 된다. 진짜 1번 → 가짜9번으로의 이동이 완전히 끝났을 때 트랜지션을 제거하고 눈속임을 줘야하기 때문에 onTransitionEnd에 함수를 걸어준 것이다. 12345678910111213141516const handleFlip = () =&gt; { if (currentIndex &lt;= 2) { // 진짜 9번의 인덱스인 11번으로 인덱스값 세팅 setCurrentIndex(11); // 트랜지션 0으로 지정 setTiming(0); // 진짜 9번이 화면 가운데에 위치했을 경우의 거리값 setDistance(626.5); } // 이쪽은 우측 이동했을 경우의 코드 if (currentIndex &gt;= 12) { setCurrentIndex(3); setTiming(0); setDistance(110.5); }};","link":"/react/Sliding_Carousel/"},{"title":"React에서의 무한스크롤 (IntersectionObserver)","text":"이번 프로젝트에서는 React에서의 여러 무한스크롤 구현 방식 중, IntersectionObserver 방식을 선택했다. IntersectionObserver는 교차 관찰자로, 기본 web API다. 관찰자(스크롤박스)를 설정하고, 그 스크롤 내에서 특정 관찰대상(target)이 화면에 보여지면 이를 캐치할 수 있도록 해준다. 🥷🏻 기본 사용 방법 new IntersectionObserver(callback, options)를 선언하여 **관찰자(스크롤박스)**를 지정해준다. 그리고, useRef를 통해 “_어떤 엘리먼트가 스크롤박스에서 보여지면 스크롤이 바닥에 닿았다고 인식되도록 할 것인가?_”의 기준이 될 관찰대상을 지정해준다. 관찰자 및 옵션 지정 12345678910111213useEffect(() =&gt; { // 옵션 설정 const options = { root: null, rootMargin: '0px', threshold: 1, }; // 관찰자 선언 const observer = new IntersectionObserver(fetcher, options); // 만약 관찰대상 ref.current가 null이 아니면 ? -&gt; 관찰 시작! if (targetRef.current) observer.observe(targetRef.current); return () =&gt; observer.disconnect();}, [fetcher]); option 설정 root: 관찰자를 설정해주는 필드다. default는 null(Viewport)다. (null일 때는, 뷰포트에 관찰대상이 보이면 알려줌) rootMargin: 관찰대상의 감지 영역에 margin값까지 포함시키고싶을 때 사용하면 된다. 문자열이 들어가야 한다. threshold: 관찰대상이 화면에 얼마나 보여질 때 콜백 함수를 호출할 지 결정한다. 범위는 0~1이다. (만약 1을 지정하면 관찰대상이 전부 보여졌을 때만 이를 인식한다) 관찰 대상 지정 useRef를 통해 빈 &lt;div&gt;태그를 관찰대상으로 지정했다. 해당 &lt;div&gt;가 화면에 보여지면 스크롤이 바닥에 닿았다고 인식하도록 한 것이다. 콜백함수 작성 이제 위의 option 조건이 만족되었을 때 발동될 콜백함수를 지정해주면 된다. 123456789101112131415const fetcher = useCallback( async (entry) =&gt; { // 이 조건문은 아래에서 설명하도록 하겠다. if (list.length &lt; 1) return; const target = entry[0]; if (target.isIntersecting) { setRange((prev) =&gt; prev + 15); const products = await axios.get(`api/productList`, { params: { length: range, text: inputValue }, }); setResults(products.data.requests); } }, [inputValue, list]); entry는 뭘까? ⇒ 관찰중인 대상들을 모두 담은 배열이다. 이번 프로젝트에서는 관찰대상이 targetRef 하나이므로, entry[0]만을 사용했다. 콜백함수에서 조건문을 사용한 이유 위의 코드에서 조건문을 통해 list.length가 1보다 작을 때 콜백함수가 return 종료되도록 했다. 뭐가 문제였을까? 검색결과가 없을 때 targetRef가 화면에 보여진다..! 위의 사진에서 보이는 바와 같이, 검색 결과가 없을 때 targetRef가 위로 끌어올려지기 때문에 콜백함수가 실행된다. 따라서 검색결과가 없을 때, 즉 list.length &lt; 1 일 때는 콜백함수가 실행되지 않도록 예외처리를 해준 것이다. 이로써 불필요한 API호출을 지양할 수 있었다.","link":"/react/infiniteScroll/"},{"title":"[React] 프로젝트 구조 설계","text":"✨ 프로젝트 구조의 중요성 사실 개인 프로젝트 개발을 할 때에는 CRA 또는 CNA를 활용하여 내 입맛에 맞게 편하게 개발을 하면 된다.하지만, 만약 협업을 하는 경우나, 대형 프로젝트에 참여하는 경우 얘기가 달라진다. 만약 협업을 하는 상황에서 개발자 개개인이 자신이 원하는대로 경로를 설정하고, 폴더 및 컴포넌트를 생성한다면 어떻게 될까? 프로젝트 초기에는 그 문제가 수면 위로 떠오르지 않겠지만, 점차 프로젝트가 진행되며 사이즈가 커질 수록 에러 발생률이 높아지고 프로젝트 개발 진행속도도 굉장히 느려지게 되며, 종국에는 프로젝트가 중단되며 재정비를 해야하는 상황에 이르를 수도 있다. 따라서 우리는 프로젝트를 진행하기 전, 명확한 가이드라인과 약속을 해야 한다. 이러한 가이드라인 하에 여러명의 팀원들로 이루어진 팀이지만, 한 명의 개발자가 일관된 기준 하에 코딩을 하듯이 프로젝트가 진행될 수 있도록 청사진을 미리 그려놔야 한다. 🤝 기본 약속 우선, 본문 작성에 앞서 필자가 추천 또는 주장하는 내용이 보편적이며 최고의 방식이 아닐 수 있음을 밝히고싶다. 이는 그저 주관적으로 선호하는 방식이자 개인적인 선택일 뿐이기 때문에 반드시 이를 따라야 할 필요는 없다! 즉, 위에서도 설명했듯이 본문의 골자는 ‘협업 친화적이고효율적인 프로젝트 구조를 어떻게 설계할 수 있는가? 이다. 따라서 우리는 우선적으로 프로젝트 설계에 있어 기본적인 약속(컨벤션)을 사전에 정의해둬야 한다. = “정답은 없다!” 작성법 예시 스네이크 케이스 snake_case 파스칼 케이스 PascalCase 카멜 케이스 camelCase 보통 필자는 위의 기본사항들에 대한 약속을 팀원들에게 제안하는 편이다. 물론 다른 방식의 더 효율적이고 좋은 컨벤션이 존재할 수도 있지만… (나는 이게 편하다…!!) 중요한 것은 “일관된 기준”이기에, 팀원들 간에 어떤 방식의 컨벤션을 정하던 그 기준을 명확히 이해하고 따르는 것에 중점을 둬야 할 것이다. 🗂 필수 디렉토리 프로젝트를 구성할 때 반드시 필요한 디렉토리 구조다.이는 기본적으로 “파일 유형에 따른 분리 원칙”을 따른다. components 없어서는 안될 폴더다. ‘단일책임 원칙‘을 따르며 재사용성을 항시 고려해야 하는 컴포넌트들을 한 곳에 모아줄 components 폴더를 src 내에 생성해두어야 한다. 이 때 헷갈리지 말아야 할 것은 pages 또는 routes와 component의 차이다. 컴포넌트는 위에서도 설명했듯, 하나의 기능 또는 책임을 위해 존재하는 하나의 레고블록 같은 것이다. 따라서 이러한 컴포넌트들을 조립하여 하나의 페이지를 구성해야 하기 때문에 page와 component의 차이점을 분명히 짚고 넘어가야 한다. constants “백그라운드 컬러 #FFFFFF에서 #F9F7F7로 변경해주세요“만약 이 말을 프로젝트가 굉장히 진척된 상황에서 듣게 된다면 어떨까? 백그라운드 컬러 또는 특정 높이나 넓이 값, enum 등 모든 것들을 상수화 하지 않고 일일이 수기로 입력해뒀다면 위와 같은 수정사항을 받았을 때 우리는 하나하나 모든 것들을 수기로 고쳐야 할 것이다. 이러한 상황을 방지하고, 미세한 오차 또는 실수를 줄이기 위해 우리는 자주 사용되는 값들을 constants에 담아 활용해야 한다. 이에는 대표적으로 색상, 사이즈 등이 있을 수 있다. constants는 말 그대로 “상수”다. 따라서 고정된 값을 여러 군데에서 반복적으로 범용해야 할 경우, 반드시 constants에 입력해둔 뒤 import하여 사용하도록 하자. hooks 커스텀 훅을 모아두는 폴더다. 프로젝트 사이즈가 굉장히 작을 경우에는 필요 없을 수도 있지만, 어느 정도의 규모라면 반드시 필요할 것이다. useState, useEffect 뿐만 아니라 여러 컴포넌트에서 활용될 수 있는 커스텀 훅이 있다면 hooks 폴더에 입력해둔 뒤 import하여 사용하는 것이 좋다. pages 컴포넌트들로 이루어진 하나의 온전한 페이지다. 때에 따라 routes로 명하는 경우도 있지만, 필자는 주로 pages라는 이름을 사용한다. 이러한 pages들을 모아 App.jsx 파일에 import 해주면 된다. styles CSS 파일들이 들어간다 필자는 보통 styled-components를 주로 사용하기 때문에 styles에 많은 파일들을 넣지 않는다. 하지만 Globalstyles와 같은 전역 rest CSS 파일을 넣어둘 때 활용한다. 하지만 styled-components를 사용한다고 해서 구조를 완전히 무시해도 되는 것은 아니다. CSS 코드가 컴포넌트 내 상단에 위치하게 된다면 굉장히 가독성이 떨어질 수 있기에 jsx 최하단에 배치하거나, 아니면 이 또한 파일로 분리하여 import하여 사용할 수 있도록 구성해야 한다. utils 유틸 함수들이 들어가는 폴더다. getApiData(), getDate()와 같이 여러 컴포넌트에서 자주 활용될 수 있는 함수들을 utils 폴더에 담아둔 뒤 전역적으로 활용할 수 있도록 해야한다. 만약 날짜를 변환하는 함수를 8~9개의 함수에 각각 일일이 입력하여 사용한다면 이는 굉장히 비효율적이고 에러 발생 확률 및 유지보수성도 굉장히 떨어질 것이다. 따라서 반드시 두개 이상의 컴포넌트에서 활용될 수 있는 함수라면, utils 폴더에 담아 활용하도록 하자. 🪅 아토믹 디자인 “atomic”, 즉 원자처럼 쪼갤 수 있을 때 까지 완전히 분해하여 디자인하는 패턴을 의미한다. 이는 기본적으로 위에서 필자가 강조한 “파일 유형에 따른 분리 원칙”에서 더 나아가 컴포넌트가 원자처럼 “완전히 독립적이고 단일한 기능“을 담당할 수 있도록 명확히 분리하는 것을 의미한다. 위의 설명에선, 단순히 components, pages, utils 등등, 유형에 따라 큰 단위로만 분류하는 것에 그쳤었다. 하지만 아토믹 디자인을 따르게 된다면 components 안에서도 그 유형 및 기능별로 조금 더 디렉토리가 세분화되어 구분되어지는 것이다. 만약, 한 페이지 내에서 하나의 nav바가 존재한다고 가정했을 때 아래와 같이 Nav라는 컴포넌트를 아래와 같이 분해할 수 있을 것이다. Nav 컴포넌트의 분해 과정 처음에 필자가 위에서 설명한 큰 틀에서의 분리만 진행했다면, 그냥 위의 nav는 하나의 컴포넌트로 구성됐을 수도 있다. 하지만 atomic 패턴을 적용한다면, nav안에서도 독립적인 기능을 하며 재사용성을 고려해야 할 작은 단위의 컴포넌트가 존재할 수 있다. 따라서 위와 같이 컴포넌트 내에서도 또 다른 분류가 필요하다. Nav 컴포넌트에 Logo, Menu, SearchBar 컴포넌트를 각각 모아서 조립해준다고 가정하여 구조를 잡는다. Nav 안에서 로고는 다른 곳에서 활용될 확률이 높기에 이 또한 하나의 독립된 컴포넌트로 분리한다. 메뉴바에는 여러 menu list들이 존재할 수 있다. 따라서 독립적 기능을 할 수 있도록 이 또한 분리한다. Search바 또한 마찬가지로 하나의 독립된 컴포넌트로 분리한다. 이처럼 컴포넌트를 하나의 큰 덩어리로 보는 것이 아니라, 컴포넌트 내에서도 세부적인 분리를 하는 것을 아토믹 디자인/패턴 이라고 할 수 있다. 따라서 이와 같이 components 폴더 내에서도 하나의 큰 덩어리가 될 수 있는 컴포넌트에 대한 폴더를 다시 만들고, 그 컴포넌트 내에 세부적 컴포넌트들을 각각 구성시켜야 한다. 참조 링크 https://ko.reactjs.org/docs/faq-structure.html https://www.stevy.dev/react-design-guide https://ui.toast.com/weekly-pick/ko_20200213 https://smoh.tistory.com/385","link":"/react/projectStructure/"},{"title":"setState의 비동기적 특성과 Dependency","text":"🐤 setState의 특성 setState는 비동기적으로 동작한다.그리고 state의 업데이트를 매 setState마다 수행하지 않고, 여러 요청이 들어올 때 한 번의 취합과정을 통해 단 한 번 수행한다. 이는 state가 변경될 때마다 리렌더링되는 React의 특성 때문이다. setState가 거의 동시에 4~5개 발생했을 경우 다수의 리렌더링을 방치하는 것보다, 한 번의 업데이트를 통해 한 번의 리렌더링이 될 수 있도록 설계되어 있기 때문이다. 즉, React는 16ms 텀을 기준으로 state를 일괄 업데이트를 진행하여, 렌더링이 한 번만 될 수 있도록 하여 효율성을 증진시킨다. 우선, nodemodules에 접근해 react의 소스코드를 한번 확인해봤다. 1234567891011121314// nodemodules/react/umd/react.development.jsComponent.prototype.setState = function (partialState, callback) { if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) { { throw Error( &quot;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&quot; ); } } this.updater.enqueueSetState(this, partialState, callback, 'setState');};/// nodemodules/react/index.d.tsfunction useState&lt;S&gt;(initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;]; 위에서 보면 알 수 있듯이, setState의 매개변수에는 partialState와 callback이 들어간다. 그리고 partialState에는 object와 function 타입이 들어갈 수 있는 것으로 보인다. 그리고 이후에 setState가 발동될 때마다 현재의 partialState와 인자로 넘어온 partialState를 병합해준다. 그리고 useState의 매개변수에는 prevState(S) 또는 함수형(()⇒ S)이 들어갈 수 있다. 따라서 한번에 여러번 state를 업데이트해야 할 경우, 그리고 동기적으로 setState를 사용하고 싶다면 setCount(prev ⇒ prev+1)과 같이 setState 내부에 함수형으로 선언을 해줘야 한다. 🐛 useCallback에서의 dependency 결여로 인한 문제점 이번 프로젝트에서는 &lt;input&gt;의 value state가 변경될 때마다 API호출이 일어나야 했고, 해당 value를 req에 담아 Get요청을 보내야 했다. 하지만, onChange 이벤트가 발생할 때마다 state가 업데이트 되고, 이러한 setState의 과정은 비동기적이고 dependency 처리를 해줘야 했기 때문에, 계속 API request에 담겨지는 inputValue값이 default값인 ‘’ 로만 인식되어 담겨졌다. 이러한 문제가 발생하는 이유가 궁금해 setState의 비동기적 특성과 dependency 등에 대한 궁금증이 생겼고, 차근차근 하나부터 공부해보고자 결심했다. 문제점 1234567891011121314const fetcher = useCallback( async (entry) =&gt; { if (list.length &lt; 1) return; const target = entry[0]; if (target.isIntersecting) { setRange((prev) =&gt; prev + 15); const products = await axios.get(`api/productList`, { params: { length: range, text: inputValue }, }); setResults(products.data.requests); } }, [list]); 위의 코드는 잘 작동된다. 하지만 처음에 작성했던 코드에서는 useCallback dependency에 list를 추가해두지 않았기 때문에 list.length 값을 default값인 0으로만 인식했다. useCallback의 특성상, 함수의 참조값이 기준없이 초기화되는 것을 방지하기 위해 반드시 dependency를 추가해줘야 한다. 그래야 해당 dependency를 참조하며 해당 값의 변화를 감지하고, 해당 값의 변화가 있을 때에만 콜백함수의 참조값이 초기화 되기 때문이다. 이에 따라, list의 길이가 변경될 때마다 함수의 참조값이 초기화 되어 새로운 list.length의 값을 새로 불러들여 활용할 수 있도록 dependency에 list props를 넣어주며 문제를 해결했다.","link":"/react/setStateAsync/"},{"title":"[React] Virtual DOM","text":"DOM이란 무엇인가? 가상 DOM(Virtual DOM)을 이해하기 위해선, DOM이 무엇인지 먼저 확실하게 이해해야 한다. DOM(Document Object Model)은 우리가 작성한 HTML 코드가 브라우저에 의해 파싱되어 구조화 및 계층화 된 노드 트리다. 글만 봐서는 이해하기 힘든 것이 당연하기에 아래 HTML 코드를 봐보자. 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;My first web page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;How are you?&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 이처럼 우리가 작성한 HTML 코드가 DOM으로 표현되면 아래와 같을 것이다.각 노드들이 트리 형태로 연결되어 있는 모습이다. 브라우저는 이를 기반으로 페이지에 우리가 작성한 HTML코드를 표시해준다. DOM을 쓰면 되지 굳이 왜…? DOM에 특별한 하자가 있는 것도 아닌데, 왜 우리는 가상 돔을 사용해야 하는 것일까? DOM을 조작(manipulate)하는 것에 대한 시간복잡도가 비효율적이기 때문이다. 다시 말해, DOM의 변화를 브라우저에 적용시키는 것이 굉장히 느리다. 물론, 확실하게 짚고 넘어가야 할 것이 있는데, DOM 자체의 조작이 느린 것은 아니다. DOM이 새로운 변동사항을 적용하여 최신화 되는 과정은 굉장히 빠르다. javascript가 이를 처리하기 때문이다. 하지만, 이러한 최신화된 DOM이 렌더트리가 되고, 다시 새롭게 배치 및 페이지 상에 그려지는 데에 시간이 오래걸리는 것이 더 정확한 표현일 것이다. 즉, 위 사진에서 노란색 렌더트리 ~ 브라우저 렌더링 까지의 시간이 오래 걸린다는 것이다. 따라서, 우리는 원본 DOM만을 사용해서는 DOM의 변동사항을 브라우저에 효율적이고 빠르게 렌더링시키지 못한다. 이 블로그를 예로 들어, 댓글 하나만 추가됐을 뿐인데 전체 페이지를 다시 재배치하고 페인팅해야 한다면 어떨까? 굉장히 비효율적일 것이다. 따라서 우리가 기대하는 효율적인 렌더링은 “변화가 일어난”부분만 리렌더링 되는 것이다. (위 사진과 같이) 이 때문에 리액트에서는 자체적인 비교 알고리즘을 활용하여 이전 DOM과 최신 DOM 간의 비교를 통해 “변화가 일어난 부분”만 리렌더링 될 수 있도록 해준다(재조정). 이는 우리가 리액트를 사용하는 주된 이유 중 하나일 것이다. 그럼 이제 Virtual DOM이 무엇인지 알아보도록 하자. Virtual DOM이란? 가상 DOM은 원본 DOM을 복제하여 메모리에 담아두고, 원본 DOM과 동기화 한 하나의 DOM이자 객체다. 비유적으로 표현하면, 가상 DOM을 전자기기의 설계도라고 표현할 수도 있을 것 같다. 설계도가 변경된다고 해서 즉각적으로 원래 존재하던 전자기기의 설계가 변경되진 않는다. 설계도를 기반으로 전자기기를 재조립하거나 새로 만들어야 변경사항이 적용된다는 것이다. 이처럼 Virtual DOM 또한 즉각적이고 직접적으로 브라우저에 표시된 페이지를 변화시키진 못한다. 단지, 가상DOM과 가상DOM 간의 비교 알고리즘(diffing)을 통해 변동사항을 감지하고 원본 DOM에 변동사항을 적용시키는 것일 뿐이다. 여기서 또 중요한 내용이 나온다. 가상 DOM과 가상 DOM의 비교다. “엥? 원본 DOM과 가상 DOM을 비교하는 것 아니었어?” 부분적으로는 맞는 말일 수도 있다. 하지만 정확하게는 원본 DOM과 동일한 가상 DOM과 vs 변경사항이 적용된 가상 DOM 간의 비교가 이루어지는 것이다. (물론 원본 가상DOM과 원본 DOM은 같기 때문에, 원본 DOM과 가상 DOM(변경사항이 적용된)의 비교라고 해도 큰 무리는 없을 것이지만 말이다.) 그럼 Virtual DOM은 어떻게 만들어질까? 코드를 활용해 설명해보도록 하겠다. 12345## 우리가 작성한 HTML 코드&lt;ul class=&quot;”itemList”&quot;&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt;&lt;/ul&gt; 위 HTML 코드를 javascript를 통해 객체화 한다면 아래의 모습과 같다. 12345678// 위의 HTML 코드를 DOM의 형태로 객체화{ type: 'ul', props: { 'class' : 'itemList' }, children: [ { type: 'li', props: {}, children: ['item1'] }, { type: 'li', props: {}, children: ['item2'] }] }// 즉, 하나의 node는 아래와 같은 형태를 갖는 것이다.{ type: ‘…’, props: { … }, children: [ … ] } 이를 jsx로 다시 코드를 짠 뒤, 바벨을 활용해 오브젝트 형태로 트랜스파일링 해준다. 1234567891011121314/** @jsx transpile */// 위의 주석 코드를 통해 바벨은 jsx코드를 아래 작성한 transpile함수에 맞게 트랜스파일링 해준다.function transpile(type, props, ...children) { return { type, props, children };}// 우리가 작성한 jsx 코드.const newHTML = ( &lt;ul class='list'&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;/ul&gt;); 이제 트랜스파일 된 자바스크립트 오브젝트를 활용해 가상DOM으로써 활용해준다. 1234567891011121314151617181920212223242526272829/** @jsx transpile */function transpile(type, props, ...children) { return { type, props, children };}const newHTML = ( &lt;ul class='list'&gt; &lt;li&gt;item 1&lt;/li&gt; &lt;li&gt;item 2&lt;/li&gt; &lt;/ul&gt;);function createElement(node) { console.log(node); if (typeof node === 'string') { return document.createTextNode(node); } // 최상단 node의 type은 'ul'이다. const $el = document.createElement(node.type); // ul // node.children = [...{type:'', props:{}, children:[...]}] =&gt; 즉, item1, item2의 node다. node.children .map((child) =&gt; createElement(child)) .forEach($el.appendChild.bind($el)); // 각 하위 노드들이 차례대로 $el에 Child로써 어펜드 된다. return $el; // 최종 DOM}const $root = document.getElementById('root');$root.appendChild(createElement(a)); 여기까지가 순수 자바스크립트를 활용해 Virtual DOM을 생성한 과정이다. (물론 이는 단지 예시일 뿐, 리액트에서는 다른 방식으로 Virtual DOM을 생성하고 manipulating 할 것이다.) 여하튼, Virtual DOM을 통해 변경사항만 리렌더링 된다. 리액트는 DOM 엘리먼트의 타입, 속성(className, style 등)의 변동사항을 캐치하여 해당 타입 또는 속성만 갈아 끼워 넣어주기도 한다. 뿐만 아니라, 엘리먼트의 내용(텍스트)이 변경된 경우에도 변경된 엘리먼트만 업데이트 한다. 1234&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt; 1234&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;third&lt;/li&gt; // 이 부분만 변경&lt;/ul&gt; 또한, 아래와 같이 새롭게 추가되거나 제거된 엘리먼트도 효율적으로 핸들링 한다. 이는 first 엘리먼트는 같네? → second 엘리먼트도 같네? → 어 third는 없었는데 추가됐네?와 같이 순차적이고 선형적인 방식으로 비교가 진행된다. 12345678910&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt; // 추가&lt;/ul&gt; 하지만 이런 경우는 어떨까? 123456789101112// old&lt;ul&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt;&lt;/ul&gt;// new&lt;ul&gt; &lt;li&gt;grape&lt;/li&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;orange&lt;/li&gt;&lt;/ul&gt; &lt;li&gt;apple&lt;/li&gt; ≠ &lt;li&gt;grape&lt;/li&gt;, &lt;li&gt;orange&lt;/li&gt; ≠ &lt;li&gt;apple&lt;/li&gt;… 와 같은 식으로 비교(diffing)가 진행되기 때문에 상단에 grape만 추가됐을 뿐인데 모든 엘리먼트들이 업데이트되게 될 것이다. 이러한 상황이 매우 크고 복잡한 엘리먼트에서 발생한다면 심각한 비효율성을 초래할 것이다. 따라서 이 때 활용되는 것이 Keys다. Keys 리액트는 엘리먼트에 key 속성이 존재한다면, key를 기준으로 엘리먼트들을 비교한다. 따라서 아래의 코드는 이제 apple과 orange에는 변동사항이 없는 것으로 판별될 것이다. 따라서 grape 엘리먼트의 추가만 변동사항으로 인식하여 트리를 업데이트 할 것이다. 123456789101112// old&lt;ul&gt; &lt;li key='1'&gt;apple&lt;/li&gt; &lt;li key='2'&gt;orange&lt;/li&gt;&lt;/ul&gt;// new&lt;ul&gt; &lt;li key='0'&gt;grape&lt;/li&gt; &lt;li key='1'&gt;apple&lt;/li&gt; &lt;li key='2'&gt;orange&lt;/li&gt;&lt;/ul&gt; 정리 및 요약가상 DOM은 원본 DOM의 조작 또는 변동사항이 일어날 경우, 전체 DOM이 다시 생성 및 재배치되는 비효율성을 방지하고자 활용되는 DOM이다. 가상DOM은 메모리에 저장되는 원본 DOM의 복제본이며, 리액트에서의 재조정 및 비교의 주체가 되어 변경사항만 선택적으로 리렌더링 될 수 있도록 한다. 즉, 가상 DOM은 변경사항이 생겼을 때, 전체 DOM이 리렌더링되는 것이 아닌, 변경사항만 적용되어 선택적 리렌더링이 될 수 있도록 하는 데 핵심적인 역할을 한다. 세 줄 요약 가상 DOM은 원본 DOM의 복제본이다. 가상 DOM과 비교알고리즘(diffing)을 통해 변경된 부분만 기존 DOM 트리에 업데이트 한다. 변경사항만 리렌더링 되기 때문에 훨씬 빠르고 효율적인 성능을 기대할 수 있다. 참조한 자료How to write your own Virtual DOM What, exactly, is the DOM? What is Virtual DOM? How Virtual DOM works ? What is Reconciliation ? What is diffing algorithm? What makes React so fast ? 재조정 (Reconciliation) - React","link":"/react/virtualDOM/"},{"title":"2. Redux Dispatch","text":"Dispatch 뷰(컴포넌트)에서 Dispatch를 통해 특정한 action을 실행시키고, 그에 따라 reducer가 실행된다.그리고 state가 지정해놓은 규칙에 따라 변경되어 구동하고 있는 컴포넌트들에 반환될 것이다. mapDispatchToProps 나는 userObject의 업데이트를 store에서 관리하고, 이를 필요한 컴포넌트에 뿌려주고싶다. 따라서 App.jsx에서 onAuthStateChanged 함수가 실행됐을 때 snapshot 함수 내에서 dispatch를 발동시켜줬다. 이에 따라 로그인을 했을 때, 혹은 유저 정보에 변화가 생겼을 때 userObject가 snapshot에 의해 업데이트 되고, 이후에 변경된 값이 dispatch를 통해 리듀서에 전달된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// App.jsconst userSnapshot = async (user) =&gt; { const userRef = doc(db, 'Users', auth.currentUser.email); // 유저 이름이 등록되어있지 않을 때 if (!user.displayName) { onSnapshot(userRef, async (snapshot) =&gt; { const newUserObject = { displayName: 'User', ...snapshot.data(), }; setUserObject(newUserObject); // updateUser 디스패치가 발동된다. props.updateUser(newUserObject); return setIsLoading(false); }); } // 등록되어 있을 때 onSnapshot(userRef, async (snapshot) =&gt; { setUserObject(snapshot.data()); // updateUser 디스패치가 발동된다. props.updateUser(snapshot.data()); return setIsLoading(false); });};// onAuthStateChanged를 통해 유저정보 변화를 listening한다useEffect(() =&gt; { onAuthStateChanged(auth, (user) =&gt; { if (user) { userSnapshot(user); } else { setUserObject(null); setIsLoading(false); } });}, []);// mapStateToProps는 구독중인 state를 받아올 수 있도록 한다.const mapStateToProps = (state) =&gt; { return { user: state.user, };};// dispatchconst mapDispatchToProps = (dispatch) =&gt; { return { // updateUser라는 이름으로 updateUser() 디스패치를 실행시켜 응답을 받아온다. updateUser: (user) =&gt; dispatch(updateUser(user)), };};export default connect(mapStateToProps, mapDispatchToProps)(App); 12345678910111213141516171819202122232425// .../redux/authentication/userUpdate.js// Actionexport const updateUserAction = 'UPDATE_USER';// Action Creatorexport const updateUser = (user) =&gt; ({ type: updateUserAction, payload: user });const initialState = { user: {} };function updateUserReducer(state = initialState, action) { // reducer가 이 action을 참조하는지 체크 if (action.type === updateUserAction) { // 만약 참조한다면, state를 복사 console.log(action.payload); return { ...state, // 그리고 새로운 값을 업데이트 해준다. // payload에 담긴 값을 spread operator를 통해 덮어준다. user: { ...state.user, ...action.payload }, }; } // 위 조건에 해당되지 않으면 그냥 기존 state값을 리턴해준다. return state;}export default updateUserReducer; 미들웨어 사용하기 logger와 composeWithDevTools를 통해 조금 더 쉽게 redux의 프로세스와 상태를 확인할 수 있다. 123456789// .../src/index.jsimport logger from 'redux-logger';import { composeWithDevTools } from 'redux-devtools-extension';const store = createStore( updateUserReducer, composeWithDevTools(applyMiddleware(logger)));","link":"/redux/Dispatch/"},{"title":"1. Redux 기초","text":"내가 userObject를 component에 전달하던 방식 이전까지는….최상단 루트인 App.js에 userObject를 두고, 유저 정보의 변경을 루트에서 하향식으로 각 컴포넌트에 뿌려줬다. 근데 이런 방식이 굉장히 불편하고 비효율적이라고 느껴졌다. 이에 따라, 가장 널리 알려진 상태관리 라이브러리 Redux를 통해 state들을 관리해보고자 한다.특히, userObject를 계속 props를 통해 컴포넌트에게 뿌려주는 것이 가장 귀찮고 번거로웠다… Redux 기본 컴포넌트 안에서만 사용되던 state를 이제 store라는 곳에 담아두고 사용한다.그리고 필요한 컴포넌트에서 해당 store를 구독(subscribe)하고, 해당 state가 변경되면 그 state를 구독하고 있는 컴포넌트가 리렌더링 된다. 기본 로직과 컨셉 -뷰에서 Dispatch를 통해 Action을 발동시킨다 -그리고 해당 Store에서, 정해진 reducer를 통해 state를 변경한다. -해당 state(store)를 구독하고 있는 컴포넌트는 리렌더링 된다. Redux 설치 참고로, Redux는 React를 위해서 만들어진 라이브러리가 아니다…순수 javascript 앱을 위해 만들어진 것이기 때문에 react-redux를 통해 redux와 react를 연결시켜줘야 한다. 12$ npm install redux react-redux redux-logger$ npm install --save redux-devtools-extension Reducers reducer는 하나의 함수다.현재 state와 action 오브젝트를 받고, 만약 필요하다면 state를 update해준다. 🔥 불변성을 지켜야 한다. Redux는 참조값을 기준으로 state가 업데이트 된 것인지 아닌지를 판단한다. 따라서 직접적으로 state를 업데이트 하면, 참조값이 변했다는 것을 인식하지 못한다. 12// 올바른 불변성 유지 방법state.something = {...something, action.something} Action 생성 action은 reducer를 실행시킨다.이 중에서도 type은 특정 action의 고유 주소값(이름)이라고 생각하면 된다.그리고 payload는 이 action의 실행에 필요한 어떠한 데이터다. 1234567// Actionexport const updateUserAction = 'Update_User';// Action Creatorexport const updateUser = (user) =&gt; ({ type: updateUserAction, payload: user,}); reducer 생성 12345678910111213141516const initialState = { user: { test: 'hello' } };function updateUserReducer(state = initialState, action) { // reducer가 이 action을 참조하는지 체크 if (action.type === updateUserAction) { // 만약 참조한다면, state를 복사 return { ...state, // 그리고 새로운 값을 업데이트 해준다. user: state.user, }; } // 위 조건에 해당되지 않으면 그냥 기존 state값을 리턴해준다. return state;}export default updateUserReducer; rootReducer 생성 위에서 생성한 개별 reducer를 하나로 합쳐줄 rootReducer를 만들어야 한다.‼️ 근데 만약 reducer가 하나라면 combineReducers를 사용해선 안된다. 123456import { combineReducers } from 'redux';import updateUserReducer from './authentication/userUpdate';const rootReducer = combineReducers({ updateUserReducer });export default rootReducer; Store 적용하기123456789101112131415161718192021222324// ../src/index.jsimport { createStore, applyMiddleware } from 'redux';import logger from 'redux-logger';import { composeWithDevTools } from 'redux-devtools-extension';import { Provider } from 'react-redux';// reducer가 여러개라면?import rootReducer from './reducers/rootReducer';// reducer가 하나라면 ?import updateUserReducer from './redux/authentication/userUpdate';const store = createStore( rootReducer, composeWithDevTools(applyMiddleware(logger)));ReactDOM.render( &lt;React.StrictMode&gt; &lt;GlobalStyle /&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 컴포넌트에서 redux 활용하기 이제 기본적인 세팅이 끝났으니, 각 컴포넌트에서 redux를 활용해볼 수 있다. 1234567891011121314151617181920// someComponent.jsximport { connect } from &quot;react-redux&quot;;const someComponent = (props)=&gt; { console.log(props) return ( &lt;div&gt;Welcome!!&lt;/div&gt; &lt;div&gt;{props.user}&lt;/div&gt; )}const mapStateToProps = (state) =&gt; { return { user: state.user }}const mapDispatchToProps = (dispatch)=&gt; { updateUserReducer}export default connect(mapStateToProps)(someComponent) 성공적으로 불러와졌다…!! 다음 포스팅에서는 이러한 redux state를 dispatch하여 변경시키는 것을 시도해보려고 한다.","link":"/redux/Redux_basic/"},{"title":"타입스크립트란? (Typescript)","text":"타입스크립트? 타입스크립트는 자바스크립트의 슈퍼셋 언어로, 쉽게 말해 자바스크립트 기반으로 만들어진 조금 더 확장되고 상위의 언어라고 할 수 있다. 원래 자바스크립트는 클래스 기반 객체지향 언어가 아닌, 프로토타입 기반 객체지향 언어다. 따라서 자바스크립트는 클래스를 정의하지 않아도 객체를 생성할 수 있다. 또한 동적 타입(dynamic typed)언어로써, 변수를 선언하기 전에 해당 변수의 타입을 지정할 필요가 없다. 이러한 이유들로 인해 바닐라 자바스크립트 자체는 클래스 기반 객체지향 언어와 달리 오류를 내기 쉬우며, 코드의 효율성이 떨어지는 문제를 야기할 수 있다. 이러한 자바스크립트의 문제점을 해결하고자 C#을 개발한 아네르스 하일스베르가 TypeScript를 개발했다. 타입스크립트의 특징 ES5와 ES6의 문법과 기능들을 모두 사용할 수 있다. React, Angular, Vue 등의 프레임워크에서 모두 호환 가능하다. 타입스크립트의 장점 ✨ 정적 타입을 지원 1234// 이렇게 하면 sum()에는 숫자만 들어갈 수 있고, 다른 타입이 입력되면 오류가 발생한다.function sum(a: number, b: number) { return a + b;} 정적타입을 지원하게 되면, 컴파일 단계에서 사전에 오류를 포착할 수 있다. 예를 들어 함수 sum(a,b) 에는 숫자만 들어가야 한다고 가정했을 때, 타입스크립트의 정적타입 지원성을 활용해 해당 함수에는 숫자만 입력되도록 설정할 수 있는 것이다. 따라서 우리는 타입스크립트를 사용하여 효율적으로 코드를 디버깅 할 수 있고, 코드 생산성을 높일 수 있다. IDE를 포함한 다양한 툴 활용 가능 타입 정보가 제공된다는 이유 하나만으로 타입스크립트는 매우 큰 장점을 선점할 수 있다. 즉, VSCode를 포함한 다양한 에디터에서 이 언어를 지원하고, 다양한 라이브러리와 툴킷들을 활용할 수 있다. 객체지향 프로그래밍 지원 큰 프로젝트나, 복잡한 코드를 짜야 하는 경우에는 클래스 기반 객체지향 프로그래밍이 필수적이다. 따라서 이제 자바스크립트도 타입스크립트의 도움을 받아 JAVA, C#에 못지 않게 큰 프로젝트에도 효율적으로 활용될 수 있고 다른 언어의 개발자들이 자바스크립트를 학습하는데 러닝커브를 낮춰줄 수도 있다. 브라우저 호환성을 높일 수 있다. Babel에서와 같이, 내가 작성한 코드를 오래된 버전의 javascript 언어로 컴파일 할 수도 있고, 최신 버전의 javascript로 컴파일 할 수도 있다. 따라서 상황에 따라 유연하게 활용할 수 있다는 장점을 갖는다. 타입스크립트의 단점 😓 브라우저 및 자바스크립트 환경에서 실행되지 못한다. 도대체 무슨 말일까….? 자바스크립트 슈퍼셋 언어인 타입스크립트가 브라우저나 자바스크립트 환경 자체에서 사용이 불가능 하다니…. 이러한 이유 때문에 타입스크립트라는 언어이자 하나의 도구는, 자동으로 javascript언어로 코드를 컴파일 해준다. 따라서 타입스크립트로 코드를 작성해도 javascript로 컴파일 되어 브라우저에서 사용 가능하다. babel과 같은 원리라고 보면 될 것 같다. 타입스크립트 설치 &amp; 설정 이제 전반적인 타입스크립트의 개념에 대해 알아봤으니 타입스크립트를 직접 설치해보고 활용해보면 될 것 같다. 설치 node.js도 필수적으로 설치해야 하나, 이전에 이미 node.js를 설치했기에 생략… 12345# 현재 프로젝트에 설치하고 싶다면?$ npm install typescript --save-dev# 컴퓨터 전체에 설치하고싶다면$ npm install -g typescript 리액트에서 사용할 경우1$ npx create-react-app [아무 이름] --template typescript","link":"/typescript/1.Typescript_Basic/"},{"title":"[타입스크립트] 기본 타입","text":"타입스크립트의 기본타입 자바스크립트는 string, number, boolean, object 등의 타입을 typeof를 통해 구별할 수 있다.물론 코드 내에서 if문을 걸어 타입의 검사가 가능하긴 하지만, 이는 개발 단계에서 버그를 잡아내는데 비효율적일 수 있다. 따라서 우리는 타입스크립트를 통해 변수의 타입을 미리 설정하고, 이를 통해 개발 단계에서 사전에 에러를 발견하여 즉각적으로 수정할 수 있다. number, string, boolean 타입 (기초) 아래와 같이 코딩을 하게 되면, 1은 string이고 2는 number이기 때문에 문자열로 변환되어 ‘12’가 반환된다. 12345678function sum(a, b) { return a + b;}const num1 = '1';const num2 = 2;console.log(sum(num1, num2)); 하지만 타입스크립트를 활용하여 아래와 같이 코딩을 하면 우리는 사전에 오류를 잡아낼 수 있고, 의도한 대로 코드의 결과 값을 반환 받을 수 있다. 123456789101112function sum(a: number, b: number, c: boolean) { if (c) { return a + b; }}const num1 = '1';const num2 = 2;const isTrue = true;console.log(sum(num1, num2, isTrue));//Argument of type 'string' is not assignable to parameter of type 'number'.ts(2345)// 이렇게 오류를 잡아주기 때문에 우리는 즉각적으로 잘못된 코드의 방향성을 바로잡을 수 있는 것이다. 초기화와 할당 변수를 선언할 때 할당이 이미 특정 타입으로 되어있는 것과, 그냥 생성+초기화만 되어있는 것과는 타입 할당 방법에 차이가 존재한다. 무슨 말인가 하면… 아래와 같이 이미 특정 변수에 특정 타입의 값이 선언되어 있다면, 타입스크립트는 해당 변수의 타입을 해당 값의 타입으로 할당해버린다. 12345// 이제 value의 타입은 number인 것이다.let value = 5;// 이 때문에 이와 같은 타입 지정은 중복 또는 반복이기에 굳이 타입을 할당해줄 필요가 없다.let value: number = 5; 하지만 아래와 같은 경우는 타입을 할당해주는 것이 옳다 123// 이렇게 변수의 생성과 할당이 분할되어 있는 경우에는 선언 당시에 타입을 할당해줘야 한다.let value: string;value = 5; 타입스크립트에서의 객체와 배열 타입 타입스크립트에서는 객체 안에 들어가는 value들의 타입도 손쉽게 사전 정의해줄 수 있다. 오브젝트의 기본 타입 선언법 12345678910111213141516// 이렇게 기본적인 오브젝트 타입 선언을 할 수 있다.const profile = { name: string; age: number;}// 아래는 조금 더 심화된 예시다.const profile = { name : string; age: number; friends: string[]; details: { uiv: string; gpa : number; }} 위의 심화 타입스크립트 코드를 JS코드로 표현하면 이와 같을 것이다. 그렇다면 **배열(Array)**은 타입스크립트에서 어떻게 다뤄질까? 위에서 약간의 힌트가 나왔지만, 해당 배열의 요소들이 가질 타입을 [] 앞에 선언해주면 된다. 1const friends: string[]; 근데 그러면 배열 안에 들어가는 요소들이 다양한 경우엔 어떻게 처리할까…? 아래와 같이 any를 사용해주면 된다. 하지만 any를 너무 남발하는 것은 타입스크립트의 이점을 제대로 활용하지 못하는 경우가 될 수 있으니 최대한 요소들의 타입을 고려하여 배열의 타입을 지정해줘야 한다. 123let friends: any[];friends = ['hoonjoo', 185, 77]; // 이렇게 어떤 타입이 들어와도 오류를 반환하지 않는다. 튜플 타입스크립트에는 튜플이라는 타입이 존재한다. 이는 배열과 모양새가 비슷한데, 위에서 설명한 것과 같이 배열 요소의 타입들이 순서에 따라 지정되어 있는 타입을 의미한다. 12const profile = [string, number];profile = ['age', 50]; // 이런식으로 순서를 반드시 고려하여 그에 맞는 타입을 집어 넣어주면 된다. enum enum 타입 또한 자바스크립트에는 존재하지 않는 타입이다.enum은 내가 사전에 정의한 특정 변수의 고정값을 두어 활용하고 싶을 때 사용한다. 글로만 보면 이해가 쉽지 않을 수 있는데, 아래의 코드를 보면 이해가 쉬울 수 있다. 1234567891011// 이렇게 enum을 사용하면, 사전에 특정 변수에 고정값을 지정해두고 활용 가능하다.enum Role { ADMIN = 0, READ_ONLY = 1, BANNED = 2,}const person = { name: 'hoonjoo', role: Role.ADMIN, // 0의 값이 자동으로 지정된다.}; 기타 타입 이제 타입스크립트에서의 모든 핵심 타입은 모두 훑어봤다.그 외의 타입들만 더 알아보면 될 것 같다…!! 조합 타입 우선 조합 타입이다. 이는 javascript의 삼항연산자와 비슷한 느낌이라고 볼 수 있는데or, || 과 같은 맥락이라고 보면 이해하기 쉽다. 123456function combine(a: number | string, b: number | string) { return a + b;}combine('hoonjoo', 'park'); // hoonjooparkcombine(5, 15); // 20 리터럴 타입 위에서 설명한 enum과 궤를 같이 한다고 볼 수 있다.특정 값을 조합(union)타입과 함께 사용할 수도 있는 조금 더 유연한 타입이다. 1234function combine(a: number | string, b: number | string, c: 'toNum' | 'toStr'){ c === 'toNum' ? return a + b || return a.toString() + b.toString();}; 근데…. 계속 이렇게 타입을 타이핑 하는게 귀찮을 땐 어떻게 방법이 없을까? type Alias를 사용하면 된다 🙂 123456789101112131415// 이렇게 타입을 변수화 하여 사용할 수 있다.type CalcType = number | string;function combine(a: CalcType, b: CalcType){ return a + b;}// 이런 방식도 물론 가능하다.type User = { name: string; age: number };function sayHello(user: User){ console.log(`Hi ${user.name}, you are ${user.age} years old right?')};sayHello('Jonh Doe', 33); 함수 타입 &amp; ‘절대’ 타입 &amp; ‘알 수 없는’ 타입함수 return 값의 타입 지정 타입스크립트에선 함수에서 내가 반환하고자 하는 값을 미리 산정하여 해당 타입의 값만 return 되도록 설정할 수 있다. 123456789// return값이 number만 반환될 수 있도록 지정한다.function sum(a: number, b: number): number { return a + b;}// return값이 아예 없도록 지정한다. (void)function sayHello(a: string): void { console.log(`hi ${a}!!`); // console.log는 return이 아니라는 점에 유의하자!} 함수 자체를 타입으로 지정해주기 특정 변수에 함수 자체를 담아야 하는 경우가 발생할 수도 있다.이런 경우에는 아래와 같이 함수를 타입으로 지정해주면 된다. 1234567891011const add(num1: number, num2: number) { return number1 + number2;};const combine(input1: string, input2: string) { return input1 + input2;};let sum: (a: number, b: number) =&gt; number;sum = add; // 두 함수의 들어가는 매개변수 타입이 동일하기 때문에 오류 없이 잘 실행될 수 있다.sum = combine // 이는 매개변수 타입이 서로 상이하기 때문에 오류가 발생된다. 콜백을 지정해주기12345678const add(num1: number, num2: number, (num: number)=&gt; void) { testCallback(num1 + num2);};// 위에서 콜백함수의 리턴값을 void로 지정해줬기 때문에, return이 아닌 console.log를 사용했다.add(5,10, (result)=&gt;{ console.log(result)})","link":"/typescript/2.Typescript_basicType/"},{"title":"[타입스크립트] React에서 Typescript 사용하기(1)","text":"CRA를 통한 프로젝트 생성 기존의 CRA와 크게 다를 것이 없다. 1$ npx create-react-app [project-name] --template typescript 하지만, 만약 기존 작업 중이던 프로젝트에 typescript를 설치하고싶다면 아래의 코드를 사용해야 한다. 1$ npm i --save typescript @types/node @types/react @types/react-dom @types/jest 기본 세팅 이 또한 기존의 일반 CRA에서의 방식과 거의 비슷하다. 물론 취향에 따라 css와 같은 것들을 살려두는 경우도 있겠지만, 나의 경우는 styled-components를 사용하기에 css파일까지 모두 삭제했다. styled-components in Typescript 여기에서 조금 세부적인 차이점이 드러나는데, typescript에서 활용하기 위해 추가적으로 설치해줘야 할 것이 있다. 12## 뒤에 붙은 @types~까지 설치해줘야 정상적으로 작동한다.$ npm i styled-components @types/styled-components React.FC Function Component의 약자Nodemodules의 React에 저장되어 있는 React에서 제공하는 타입이다. tsx파일에서 눈에 띄는 것이 있는데, 바로 React.FC다. 이 타입을 선언해주면, FC 안에 jsx형식이 아닌 그냥 함수가 들어갈 경우 에러를 반환해준다. 123456789// 정상 동작const App: React.FC = () =&gt; { return &lt;div className='App'&gt;&lt;/div&gt;;};// 이 경우는 오류가 남 (FC를 선언해줬는데, 그냥 함수로써 사용했기 때문)const App: React.FC = () =&gt; { return;}; 하지만 이러한 React.FC를 굳이 선언해야 하는지, 말아야 하는지에 대해서는 왈가왈부가 많다. 하지만 내가 리스펙하는 벨로퍼트님께서는 굳이 사용하지 않는 방향성을 추천하셨다… 그래서 그런지 뭔가 그쪽으로 마음이 많이 끌리는 것은 사실이다… Typescript에서 props 주고 받기 기존의 일반 React에서는 props를 다른 컴포넌트로 넘겨줄 때, 그냥 컴포넌트 태그 안에 key와 value값을 넣어주기만 하면 됐었다. 하지만 typescript에서는 해당 props에도 타입을 지정해줘야 한다. 12345678// App.tsxconst App: React.FC = () =&gt; { return ( &lt;div className='App'&gt; &lt;TODO items={todos} /&gt; &lt;/div&gt; );}; 12345678910// TODO.tsx// 이와 같이 props에 대한 interface를 정의하는 방법이 있다.interface TodoProps { items: { id: string; text: string }[];}// 그리고 해당 interface를 FC 옆에 아래와 같이 넣어주면 된다.const TODO: React.FC&lt;TodoProps&gt; = () =&gt; { return &lt;ul&gt;&lt;/ul&gt;;}; 하지만 만약 React.FC를 사용하지 않는다면? 아래와 같이 props 전달을 하면 된다. 123456789101112131415// TODO.tsxinterface TodoProps { items: { id: string; text: string }[];}// 일반 함수function TODO({ items }: TodoProps) { return &lt;ul&gt;&lt;/ul&gt;;}// arrow 함수const TODO = ({ items }: TodoProps) =&gt; { return &lt;ul&gt;&lt;/ul&gt;;}; 이제 아주 기본적인 것들은 끝났다.따라서 다음 포스팅에선 React와 Typescript를 활용한 Todo App을 만드는 과정을 통해 state, hooks등의 typescript 활용법에 대해서 다뤄보고자 한다.","link":"/typescript/3.reactAndTypescript/"},{"title":"[타입스크립트] React에서 Typescript 사용하기(2)","text":"📝 Todo-List를 만들며 Typescript에 익숙해지기 이번 포스트에서는 리액트와 타입스크립트를 통해 투두앱을 만들며 배운 점들(TIL)을 정리해보려 한다. 투두리스트라고 해서 굉장히 빨리, 그리고 쉽게 만들 수 있을 것 같았는데… 막상 타입스크립트를 활용해서 실전에 적용해 보려고 하니 생각보다 시간이 오래 걸렸다. 📁 디렉토리 구조 📚 TIL 지극히 개인적으로 내가 투두앱을 만들며 막혔던, 그리고 잘 모르겠었던 부분들만 모아서 정리해보고자 한다. useState에 type 지정하기생각보다 그렇게 복잡하고 어렵지는 않다. 만약 default값을 useState에 선언해 줬다면 굳이 type이나 interface를 생성해줄 필요도 없다. 12// 이처럼, 기본 default값을 ''으로 지정해줬기 때문에, typescript는 해당 useState의 타입을 string으로 인식한다.const [todo, setTodo] = useState(''); object로 이루어진 array의 타입 지정처음에는 오브젝트가 앞으로 가야하나, 뒤로 가야하나, 아니면 안에 담겨야 하나 참 헷갈렸었다. 하지만 string으로 이루어진 배열의 타입을 정의하는 것과 같은 맥락이라고 생각하니 쉽게 해답을 찾을 수 있었다. interface를 사용할 경우 123456789// TodoBox.tsx// 아래와 같이 interface를 정의하고,interface Props { todos: { id: number; text: string; isChecked: boolean }[];}// 이처럼 useState에 적용시켜주면 된다.const [todos, setTodos] = useState&lt;Props['todos']&gt;([]); type을 사용할 경우 12345// TodoBox.tsxtype TodosType = { id: number; text: string; isChecked: boolean }[];const [todos, setTodos] = useState&lt;TodosType&gt;([]); interface 타입들의 모음집이라고 생각하면 편할 것 같다.여러 타입들을 모아둔 하나의 “큰 타입”인 것이다. 하지만 내가 간과한 것이 있는데, interface 안에서 정의한 여러 타입 중 몇 개만 선택적으로 골라서 쓸 수 있을 것이라 착각했었다. 내가 특정 변수에 interface를 타입으로 지정해줬다면, 해당 변수는 반드시 해당 interface 안에 포함된 모든 타입들을 포함시켜야 한다. 12345678910111213interface Todos { id: number; text: string; isChecked: boolean;}// 이렇게 선택적으로는 절대 사용할 수 없다.let newTodo: Todos;newTodo = '책 읽기';// 아래와 같이 모든 Todos의 타입들을 포함시켜야 한다.let newTodo: Todos;newTodo = { id: 0, text: '책 읽기', isChecked: false }; ❗하지만…!! 어떤 interface의 프로퍼티를 선택적으로 사용할 수 있도록 하고싶다면, 아래와 같이 프로퍼티 뒤에 ?를 붙여주면 에러 없이 사용할 수 있다. 123456789interface Todos { id: number; text: string; isChecked?: boolean;}// isChecked가 포함되지 않았는데도 에러가 나지 않는다let newTodo: Todos;newTodo = { id: 1, text: '운동하기' }; setState props로 넘겨주기 상위 컴포넌트에서 하위 컴포넌트로 setState를 넘겨주는 방법에서 막혀 조금 헤맸다. 하지만 다시 생각해보니 그냥 하위 컴포넌트에서 setState에도 type을 지정해주면 되는 일이었다. 부모 컴포넌트 12345678910111213// TodoBox.tsxinterface Props { todos: { id: number; text: string; isChecked: boolean }[];}const [todos, setTodos] = useState&lt;Props['todos']&gt;([]);// ...생략return ( &lt;TodoBox&gt; &lt;TodoList todos={todos} setTodos={setTodos} /&gt; &lt;/TodoBox&gt;); 하위 컴포넌트 12345678910// TodoList.tsx// 이처럼 하위 컴포넌트에서 Props에 대한 타입들을 지정해주고,interface Props { todos: { id: number; text: string; isChecked: boolean }[] | []; setTodos: (val: any) =&gt; void;}// 컴포넌트 내에서 해당 props들을 아래와 같이 지정해주면 된다.export const TodoList = ({ todos, setTodos }: Props) =&gt; {//...생략} styled-components로 props 넘겨주기 전혀 생각지도 못했던 styled-components에서의 props 활용법이다.styled-components… 아무리 생각해도 참 대단한 것 같다. 12345678910// 원하는 태그 안에 props를 담아준 뒤,&lt;Task color={color}&gt;&lt;/Task&gt;;// styled-components에서 아래와 같이 해당 props를 선언해주면 된다!const Task = styled.div &lt; { color: string } &gt; ` background-color: ${(props) =&gt; props.color};`; setState를 활용한 토글 기능 (하위 컴포넌트에서 실행) React에서 여닫기 기능이나, 체크 기능 등을 활용하고자 할 때, toggle 방식의 setState를 자주 사용했었다. 하지만 타입스크립트에서 setState를 하위컴포넌트로 넘겨줬을 경우, setState 안에 prev 인자에도 type을 지정해줘야 해서 조금 헤맸다… 1234567891011121314151617// 하위컴포넌트.tsximport { Dispatch, SetStateAction } from 'react';interface Props { setIsOpen: Dispatch&lt;SetStateAction&lt;boolean&gt;&gt;; isOpen: boolean;}// ...생략const handleOpen = () =&gt; { // 이렇게 하면 에러가 난다... setIsOpen((prev) =&gt; !prev); // 이렇게 해야 오류가 나지 않는다! setIsOpen((prev: any) =&gt; !prev);}; 🌐 타입스크립트 공부할 때 유용한 링크들TypeScript 한글 문서 https://github.com/typescript-cheatsheets/react","link":"/typescript/4.reactAndTypescript2/"},{"title":"[타입스크립트] 느낌표와 물음표","text":"⁉️ Typescript에서의 느낌표와 물음표? React-Redux에서 Typescript를 사용하다 보니, 초기값 설정 때문인지 state가 내가 의도한 상태 (배열, 오브젝트 등등)가 되기 전까지는 아래와 같은 타입스크립트 에러가 발생하는 현상을 자주 겪었다. 위의 사진을 보면, 나는 currentUser의 초기값(initailState)을 null로 지정해줬고, 특정 action이 발동 됐을 때만 currentUser state가 오브젝트 형태로 업데이트 되도록 했다. 이 때문에 currentUser가 특정 값으로 업데이트 되기 전까지는 null이기 때문에, 위와 같은 오류가 발생하는 것이었다. 이런 경우, 느낌표(!) 또는 물음표(?)를 사용하면 문제가 깔끔하게 해결됐기에 이를 자주 사용했다.하지만 그동안 이를 사용하며 정확히 어떤 의미인지, 무엇 때문에 오류가 해결되는지에 대해서는 확실히 짚고 넘어가지 못했기 때문에 이를 블로그에 정리해보고자 한다. ❗️ 느낌표 느낌표(!)는 값이 무조건 할당 되었으니, 또는 무조건 할당 될 것이니** null이나 미할당의 문제를 넘어가라고 컴포넌트에 명령을 내리는 것과 같다고 생각하면 된다. 이를 nullable이라고 하는데, null값 또는 undefined를 허용하도록 하겠다는 것과 같다고 볼 수 있다. 아래의 코드 예시를 봐보자. 코드 예시 이 경우 세 번째 isOwner를 사용하기 위해선, 해당 값이 할당 될 것이라고 컴포넌트에 미리 언질을 줘야한다. 만약 그렇지 않으면 isOwner 내에 사용된 currentUser.userId는 null이 될 수도 있는 가능성이 존재하기에, 타입스크립트는 에러를 출력할 것이다. ❓ 물음표 타입을 지정해줄 때, “프로퍼티의 값이 있을 수도 있고 없을 수도 있어!” 라고 선언해주는 것과 같다고 생각하면 쉽다. 이를 optional이라고 한다. 즉, 내가 선언한 타입이 필수적으로 입력 및 사용되어야 하는 프로퍼티가 아님을 의미한다. 아래 예시를 확인해보자! 코드 예시 위 예시에서 볼 수 있듯이, aboutMe에 분명 Person이라는 인터페이스를 선언했으나, age가 포함되지 않았는데도 어떠한 오류도 발생하지 않는다. 이는 Person 인터페이스의 age에 물음표(optional)을 선언해줬기 때문이다. nullable과 같은 역할을 하기도 한다.내가 null.length나 null.filter() 등을 사용하고자 할때 활용할 수 있다. 즉, 내가 사용하고자 하는 값이 null 또는 undefined여도 일단 에러 없이 코드를 실행시킬 수 있는 것이다.","link":"/typescript/5.nullableOptional/"},{"title":"[Node.js] 11047번 : 동전 0","text":"문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) 출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다. 풀이 과정 실수로 완전탐색 방식으로 풀어버릴 뻔 했다….처음 풀어보는 그리디 알고리즘 유형이었어서 여러 풀이법들을 참고했다. 그리디 알고리즘…? 그리디 알고리즘은 모든 경우의 수를 탐색하는 알고리즘이 아니다. 따라서 경우에 따라 내가 도출한 답이 최적의 답이 아닐 수도 있다. ( 하지만 빠를 수는 있음 ) 코드 로직 우선 N값과 K값을 선언해준다. 카운트를 세야 하기 때문에 count 변수 또한 선언해준다. 그리디 알고리즘이기 때문에, 작은 값에서 큰 값으로 탐색하는 것은 비효율적이다. 따라서, 배열의 가장 우측에서부터 차례대로 탐색하는 것이 빠른 해답을 찾기 위한 방법일 것이다. for문 또한 i가 감소하는 식으로 구성한다. 우측에서부터 진행되기 때문에 최소 조합을 구성하기 위해선 K/Arr[i]가 count에 담기면 된다. 그리고 K값은 해당 Arr[i]값으로 나눈 나머지, 즉 K%= Arr[i]가 되면 된다. 이렇게 반복문을 계속 돌리면 우측에서부터 탐색했을 경우의 최소 동전 집합의 개수를 구할 수 있다. 소스 코드123456789101112function coin(arr, NK) { // K와 N 선언 const N = NK[0]; let K = NK[1]; let count = 0; // 합이 K가 되는 동전 조합의 최소값 구하기 for (let i = N - 1; i &gt; 0; i--) { count += Math.floor(K / arr[i]); K %= arr[i]; } return count;}","link":"/algorithm/boj/11047/"},{"title":"[Node.js] 13305번 : 주유소","text":"문제어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다. 처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다. 예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다. 각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오. 입력표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 제일 왼쪽 도로부터 N-1개의 자연수로 주어진다. 다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 도시부터 순서대로 N개의 자연수로 주어진다. 제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 1이상 1,000,000,000 이하의 자연수이다. 리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다. 출력표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다. 풀이 과정 현재 가격과 다음 목적지의 가격을 비교하면 쉽게 풀 수 있을 것 같다. 우선 첫 시작점에서는 반드시 주유를 해야한다. 두번째 목적지에서 부터는 목적지별 주유비용을 서로 비교하며, 더 싼 가격이 나오기 전 까지는 같은 값을 유지한다. (거리만큼 계속 곱해나감) 그리고 더 저렴한 목적지가 나오면 그 뒤로부터는 다시 기준 주유비용을 현재 목적지의 주유비용으로 설정한다. 소스코드12345678910111213function gasStation(N, distance, cost) { let answer = distance[0] * cost[0]; for (let i = 1; i &lt; N - 1; i++) { if (cost[i] &lt; cost[i - 1]) { answer += cost[i] * distance[i]; } else { answer += cost[i - 1] * distance[i]; } } return answer;}gasStation(4, [2, 3, 1], [5, 2, 4, 1]);","link":"/algorithm/boj/13305/"},{"title":"[Node.js] 1541번 : 잃어버린 괄호","text":"문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다. 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오. 입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 출력첫째 줄에 정답을 출력한다. 풀이 과정 마이너스 앞에 있는 숫자를 최소로 만들고, 마이너스 뒤에 있는 숫자들의 크기를 가장 크게 만들면 주어진 조건을 만족할 수 있을 것 같다. -를 기준으로 문자열을 split 그리고 다시 +를 기준으로 split 각 배열들의 합을 우선 구한다. (map &amp; reduce) 그리고 그 합들을 모두 빼준다. (reduce) 소스코드12345678910111213function lost(input) { // -를 기준으로 String을 배열로 나눠준다. let arr = input.split('-'); // +를 기준으로 +가 들어있는 배열들을 다시 또 나눠준다. arr = arr.map((el) =&gt; el.split('+')); // 그리고 각자 배열들의 요소들을 reduce를 사용하여 더해준다. arr = arr.map((el) =&gt; el.reduce((prev, cur) =&gt; Number(prev) + Number(cur))); // 이제 각 값들을 빼주기만 하면 된다 let answer = arr.reduce((prev, cur) =&gt; Number(prev) - Number(cur)); return answer;}lost('55-50+40');","link":"/algorithm/boj/1541/"},{"title":"[Node.js] 11399번 : ATM","text":"문제인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다. 사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다. 줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다. 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000) 출력첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다. 풀이 과정 최소한의 대기시간으로 사람들이 ATM업무를 처리할 수 있도록 하는 줄서기 배열을 구하고, 총 걸린 시간을 반환하면 된다. 앞 사람의 업무처리 시간이 길수록 뒷 사람들의 대기시간은 더 늘어난다. 따라서 업무처리 시간이 짧은 순서대로 사람들을 줄 세워야 한다. 업무처리 시간을 기준으로 오름차순 정렬하면 쉽게 풀 수 있는 문제다. tempSum : 자신을 제외한 이전까지의 합을 구하기 위한 변수 sum : 대기시간 + 업무처리 시간까지 모두 합한 해당 요소까지의 시간 소스코드123456789101112131415function ATM(n, arr) { // 우선 업무처리시간이 짧은 순으로 오름차순 정렬한다. arr.sort((a, b) =&gt; a - b); // 자신을 제외한 이전까지의 합을 담는 tempSum let tempSum = 0; // 자신을 포함한 모든 대기시간 + 업무처리시간의 합 let sum = 0; for (let i = 0; i &lt; n; i++) { // tempSum은 총 대기시간이 된다. (앞의 요소들의 업무처리 시간들의 합이기 떄문) // 또한 tempSum이 뒤에 연산되기 때문에 sum에 더해지는 tempSum은 이전까지의 대기시간 + 업무처리 시간이다 sum += tempSum + arr[i]; tempSum += arr[i]; } return sum;}","link":"/algorithm/boj/11399/"},{"title":"[Node.js] 1931번 : 회의실 배정","text":"문제한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. 입력첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다. 풀이 과정 최대한 회의실 사용 일정을 꽉꽉 채워 담아야 한다.따라서 이번에는 큰 수에서 내림차순으로 탐색하는 것이 아니라, 작은 수에서 오름차순으로 탐색해야 한다. 배열을 회의가 끝나는 시간이 가장 빠른 순으로 오름차순 정렬한다. 끝나는 시간 순으로 정렬을 했기 때문에, 시작 시간이 끝나는 시간보다 크거나 같으면 해당 미팅을 진행할 수 있다. 따라서, 미팅을 스케줄에 넣을 때 마다 endpoint가 방금 추가된 미팅의 끝나는 시간으로 설정되어야 한다. (아래 그림 참조) 반복문 활용 arr[i][0] === end라면 count를 더한다. 그리고 end값을 수정한다. 최종적으로 count를 return해준다. 소스코드12345678910111213141516function meetingRoom(arr, N) { // 보기에서는 끝나는 시간 순으로 이미 정렬되어 있었지만, 다른 인풋값이 들어올 경우를 대비해 정렬을 해줬다. arr.sort((a, b) =&gt; a[1] - b[1]); // 두 번째 시간부터 체크할 것이기 때문에 카운트는 1, end도 첫 째 미팅의 끝나는 시간으로 선언 let count = 1; let end = arr[0][1]; for (let i = 1; i &lt; arr.length; i++) { // 만약 현재 미팅의 시작시간이 전에 추가된 미팅의 끝나는 시간보다 크거나 같으면 추가할 수 있다. if (arr[i][0] &gt;= end) { // 카운팅을 하고, end값을 현재 미팅의 종료시간으로 갱신한다. count++; end = arr[i][1]; } } return count;}","link":"/algorithm/boj/1931/"},{"title":"프로그래머스 - 큰 수 만들기 (Javascript)","text":"문제 설명어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. 예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다. 문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요. 제한 조건 number는 1자리 이상, 1,000,000자리 이하인 숫자입니다. k는 1 이상 number의 자릿수 미만인 자연수입니다.⇒1 &lt; k &lt; number.length 입출력 예 number k return “1924” 2 “94” “1231234” 3 “3234” “4177252841” 4 “775841” 풀이 과정 각 경우의 수들을 모두 배열 형태로 나열해보고 → Number로 바꾼 뒤에 가장 큰 수를 찾아서 해당 값의 원본 배열에서의 index값을 찾는다. 배열화 하여 모든 요소들을 숫자로 변환한다. 반복문을 돌린다. while(answer.length &lt; length){} 만약 Math.max(…arr)의 값의 index+length &gt; arr.length-1이 아니라면 해당 값이 가장 첫번째 자리수다. 해당 max숫자의 index를 indexOf를 통해 찾는다. (maxIndex) 그리고 그 인덱스+1 이전의 배열들은 잘라낸다. (arr.slice(maxIndex+1)) 그리고 해당 max값을 answer에 담는다. (answer.push(max)) 다시 반복문을 재개한다. 소스코드 (1차시도) 시간초과 4회 123456789101112131415161718192021222324252627282930function solution(number, k) { let answer = []; const endpoint = number.length - k; let length = number.length - k; let arr = [...number]; arr = arr.map((el) =&gt; Number(el)); let sortedArr = [...number]; sortedArr = arr.map((el) =&gt; Number(el)); sortedArr.sort(); let minIndex = arr.length - length; let i = sortedArr.length - 1; while (answer.length &lt; endpoint) { let max = sortedArr[i]; let maxIndex = arr.indexOf(max); if (maxIndex &lt; 0) { i--; } else if (maxIndex &lt;= minIndex) { answer.push(max); arr = arr.slice(maxIndex + 1); length--; minIndex = arr.length - length; i = sortedArr.length - 1; } else { i--; } } answer = answer.join(''); return answer;} 소스코드 (2차시도)12345678910111213141516171819202122232425function solution(number, k) { let answer = []; let count = 0; for (let i = 0; i &lt; number.length; i++) { let current = number[i]; if (answer.length === 0) { answer.push(current); continue; } while (answer[answer.length - 1] &lt; current) { answer.pop(); count++; if (count === k) { return answer.join('') + number.slice(i); } if (answer.length === 0) { break; } } answer.push(current); } return answer.join('').slice(0, number.length - k);}solution('4177252841', 4);","link":"/algorithm/programmers/BiggerNumber/"},{"title":"프로그래머스 - 구명보트 (Javascript)","text":"문제 설명무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다. 예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다. 구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다. 사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요. 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다. 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다. 입출력 예 people limit return [70, 50, 80, 50] 100 3 [70, 80, 50] 100 3 풀이 과정 사람들을 우선 무게별로 내림차순 정렬한 뒤, 이중 포인터를 사용해서 풀이했다. sort((a,b) ⇒ b-a)를 통해 무게별 내림차순 정렬한다. 다중 포인터를 선언한다 (i,j) 양 끝값이 limit보다 작거나 같으면 포인터를 모두 좁힌다. 만약 위의 조건을 통과하지 못하면 좌측 포인터를 한칸 우측으로 이동시킨다 (가장 무거운 사람) 소스 코드123456789101112131415161718192021222324function solution(people, limit) { people.sort((a, b) =&gt; b - a); let rescued = 0; let count = 0; // 초기 i,j값은 각각 양 끝이다. let i = 0; let j = people.length - 1; // 구조된 사람의 숫자와 기존 사람 숫자가 같아지면 반복문을 종료한다. while (rescued &lt; people.length) { // 만약, 양 끝의 합이 limit보다 작거나 같으면 두 사람을 우선 구조한다. j--, i++ if (people[i] + people[j] &lt;= limit) { j--; i++; count++; rescued += 2; // 근데 둘의 합이 100을 넘으면 i의 사람을 먼저 구조하고 i++를 한다.(정렬되어 있기 때문에 어차피 누구와도 같이 못탐) } else { i++; rescued++; count++; } } return count;}","link":"/algorithm/programmers/Boat/"},{"title":"프로그래머스 - 조이스틱 (Javascript)","text":"문제 설명조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA 조이스틱을 각 방향으로 움직이면 아래와 같습니다. 🔼 - 다음 알파벳🔽 - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동 예를 들어 아래의 방법으로 “JAZ”를 만들 수 있습니다. 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.따라서 11번 이동시켜 “JAZ”를 만들 수 있고, 이때가 최소 이동입니다. 만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요. 제한 사항 name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다. 입출력 예 Name Return “JEROEN” 56 “JAN” 23 풀이 과정 예전에 백준에서 비슷한 문제를 풀어본적 있던 것 같다.아래의 아스키 코드를 활용하면 될 것 같고, 거리계산을 효율적으로 하면 풀 수 있을 것 같다. 😅 …는 나의 헛된 망상이자 꿈이었다….ㅋㅋ 😅 아스키코드 Cheat Sheeta~z : 97122**AZ** : 6590**09** : 48~57 우선 String을 배열로 split한다 그리고 각 배열의 요소들을 charCodeAt을 통해 아스키 코드로 변환한다 어떻게 위로 올리는게 효율적인지, 아래로 내리는게 효율적인지 판단할까? ⇒ Math.min(Math.abs(bottom - num), Math.abs(top - num)) 바닥값과 천장값 사이의 거리 중에 가장 가까운 것을 선택하면 된다. 좌우 커서 이동의 경우의 수 ⇒ 총 4개의 케이스를 고려한다. Case1 : 우측으로만 이동할 때 Case2 : 좌측으로만 이동할 때 Case3 : 우측으로 시작했는데 도중에 좌측으로 꺾을 때 Case4 : 좌측으로 시작했는데 도중에 우측으로 꺾을 때 저 네 개의 Case 중에 가장 최솟값을 answer에 더해주면 된다. 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function solution(name) { let answer = 0; let arr = name.split(''); arr = arr.map((el) =&gt; el.charCodeAt(0)); let indexes = []; // 상하 이동값부터 계산 for (let i = 0; i &lt; arr.length; i++) { if (arr[i] !== 65) { answer += Math.min(Math.abs(65 - arr[i]), Math.abs(91 - arr[i])); // A가 아닌 값들의 index를 관리하기 위한 indexes 배열을 만들어 활용했음 indexes.push(i); } } // 처음 값이 A가 아닐 경우에는 어차피 커서 좌우 이동에 영향을 주지 않기 때문에 그냥 indexes에서 빼줘도 된다. if (arr[0] !== 65) { indexes.shift(); } // 만약에 길이가 하나면, 굳이 아래의 모든 케이스를 돌려볼 필요가 없다. // 따라서 우측으로 이동하는게 더 나은지, 좌측으로 이동하는게 더 나은지만 판단하면 된다. if (indexes.length === 1) { let left = Math.abs(arr.length - indexes[indexes.length - 1]); let right = indexes[0]; answer += Math.min(left, right); console.log(left, right); return answer; } // 이제 좌우값 체크 // #Case1 : 우측으로만 갈 때 let case1 = arr.length - 1; // #Case2 : 좌측으로만 갈 때 let case2 = Math.abs(arr.length - indexes[0]); // #Case3 : 우측으로 시작했는데 한 번 꺾을 때 let case3 = 0; // 만약에 첫 값이 A가 아니라면 그 값을 건너 뛰어서 시작해야된다. let i = arr[0] !== 65 ? 1 : 0; // 단지 let case3BCount = 0; while (true) { if (case3BCount !== 0 &amp;&amp; arr[i + 1] === 65) { break; } else if (case3BCount === indexes.length - 1) { break; } if (arr[i + 1] !== 65) { case3BCount++; i++; } else { i++; } } // 한번 갔다가 같은만큼 돌아오기 때문에 2를 곱해준다. case3 = i * 2 + arr.length - indexes[case3BCount]; // #Case4 : 좌측으로 시작했는데 한 번 꺾을 때 let case4 = 0; let j = arr[arr.length - 1] !== 65 ? arr.length : arr.length - 1; let case4BCount = 0; while (true) { if (case4BCount !== 0 &amp;&amp; arr[j - 1] === 65) { break; } else if (case4BCount === indexes.length - 1) { break; } if (arr[j - 1] !== 65) { case4BCount++; j--; } else { j--; } } case4 = (arr.length - j) * 2 + indexes[indexes.length - case4BCount - 1]; return answer + Math.min(case1, case2, case3, case4);}","link":"/algorithm/programmers/JoyStick/"},{"title":"프로그래머스 - H-Index (Javascript)","text":"문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. 풀이 과정 문제가 좀 불친절했다..그래도 굉장히 쉽게 풀어낼 수 있었던 문제였다. 인용 횟수의 최대값에서부터 내림차순으로 순회하도록 설계했다. 그리고 기준 인용 횟수(i)의 값보다 인용 횟수가 크거나 같은 것들의 개수가 i 이상이면 비교 기준이 될 수 있다. 좀 더 쉽게 설명하자면, [4,5,6,1,2]에서 인용 횟수가 3 이상인 논문들은 총 세개이기 때문에 h-index에 포함될 수 있다. 하지만 위 배열에 4 이상인 논문들은 동일하게 3개지만, 4(i)&gt;3(인용횟수)이기 때문에 h-index에 포함될 수 없다. 주의사항 배열의 길이가 1이고, 유일한 값이 0이 아닌 이상 return 값은 1이 나오게 된다. 정답은 배열의 길이를 초과할 수 없다. 이러한 이유 때문에 반복문의 시작점(max)를 citations.length로 잡은 것이다. 소스 코드1234567891011121314function solution(citations) { let answer = 0; let count = 0; if (citations.length === 1 &amp;&amp; citations[0] === 0) return 0; const max = citations.length; for (let i = max; i &gt;= 0; i--) { count = 0; for (let j = 0; j &lt; citations.length; j++) { if (citations[j] &gt;= i) count++; } if (count &gt;= i) return (answer = i); } return answer;}","link":"/algorithm/programmers/HIndex/"},{"title":"프로그래머스 - 완주하지 못한 선수 (Javascript)","text":"문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요. 제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. completion의 길이는 participant의 길이보다 1 작습니다. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 participan completion return [“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo” [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko” [“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” 입출력 예 설명예제 #1”leo”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #2”vinko”는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다. 예제 #3”mislav”는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다. 풀이 과정 생각보다 풀기는 수월했던 문제다. completion의 참가자들을 for문을 통해 object화 한다. key : 이름, value: count participant 배열을 다시 for문 돌려서 object에 해당 key가 존재하는지 체크한다. 존재하면 obj에서의 value를 1씩 차감시킨다. 만약 해당 참가자의 이름에 해당하는 value가 0이면 해당 참가자가 완주하지 못한 참가자다 소스코드123456789101112131415function solution(participant, completion) { var answer = ''; let obj = {}; for (let person of completion) { obj[person] ? obj[person]++ : (obj[person] = 1); } for (let person of participant) { if (!obj[person]) { answer = person; break; } obj[person]--; } return answer;}","link":"/algorithm/programmers/RetardRunner/"},{"title":"프로그래머스 - K번째 수 (Javascript)","text":"문제 설명배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다. 예를 들어 array가 [1, 5, 2, 6, 3, 7, 4], i = 2, j = 5, k = 3이라면 array의 2번째부터 5번째까지 자르면 [5, 2, 6, 3]입니다. 1에서 나온 배열을 정렬하면 [2, 3, 5, 6]입니다. 2에서 나온 배열의 3번째 숫자는 5입니다. 배열 array, [i, j, k]를 원소로 가진 2차원 배열 commands가 매개변수로 주어질 때, commands의 모든 원소에 대해 앞서 설명한 연산을 적용했을 때 나온 결과를 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 array의 길이는 1 이상 100 이하입니다. array의 각 원소는 1 이상 100 이하입니다. commands의 길이는 1 이상 50 이하입니다. commands의 각 원소는 길이가 3입니다. 입출력 예 number k return [1, 5, 2, 6, 3, 7, 4] [[2, 5, 3], [4, 4, 1], [1, 7, 3]] [5, 6, 3] 입출력 예 설명[1, 5, 2, 6, 3, 7, 4]를 2번째부터 5번째까지 자른 후 정렬합니다. [2, 3, 5, 6]의 세 번째 숫자는 5입니다.[1, 5, 2, 6, 3, 7, 4]를 4번째부터 4번째까지 자른 후 정렬합니다. [6]의 첫 번째 숫자는 6입니다.[1, 5, 2, 6, 3, 7, 4]를 1번째부터 7번째까지 자릅니다. [1, 2, 3, 4, 5, 6, 7]의 세 번째 숫자는 3입니다. 풀이 과정 시간복잡도 때문에 최대한 반복문 안에 sort나 slice 등의 O(N) 메소드를 사용하지 않아보려고 했는데…도저히 떠오르지 않아서 일단 그냥 풀어봤다. 원본 배열 array는 손상되어서는 안된다. (tempArray 만들어줌) commands의 길이만큼 array에서 배열을 잘라내어 정렬하고 (slice), n번째 숫자를 알아내야 한다. 잘라내야 하는 횟수는 commands.length와 같다 따라서 for문도 commands.length를 기준으로 돌리면 된다. slice를 통해 잘라내고, 바로 오름차순으로 정렬한다. 그리고 해당하는 값을 anwer에 push해준다. commands.length는 최대 50까지다. 소스 코드12345678910function solution(array, commands) { let answer = []; let tempArray = []; for (let i = 0; i &lt; commands.length; i++) { tempArray = array.slice(commands[i][0] - 1, commands[i][1]); tempArray.sort((a, b) =&gt; a - b); answer.push(tempArray[commands[i][2] - 1]); } return answer;}","link":"/algorithm/programmers/KthNumber/"},{"title":"프로그래머스 - 모의고사 (Javascript)","text":"문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, …2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, …3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한 조건 시험은 최대 10,000 문제로 구성되어있습니다. 문제의 정답은 1, 2, 3, 4, 5중 하나입니다. 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요. 입출력 예 answers return [1,2,3,4,5] [1] [1,3,2,4,2] [1,2,3] 입출력 예 설명입출력 예 #1 수포자 1은 모든 문제를 맞혔습니다. 수포자 2는 모든 문제를 틀렸습니다. 수포자 3은 모든 문제를 틀렸습니다. 따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다. 입출력 예 #2 모든 사람이 2문제씩을 맞췄습니다. 풀이 과정 반복문을 돌려서 각 학생들이 가진 정답패턴으로 몇 개의 정답을 맞힐 수 있는지 계산하면 된다 answers는 1~마지막 문제 까지의 정답이 담긴 배열이다. 우선 각 학생들의 찍기 패턴을 선언한다. answers의 길이가 학생의 찍기패턴 한 단위보다 길 수 있다. 따라서 이 경우도 생각해줘야 한다. object 하나를 만들어서 각 학생별 정답 수를 카운팅한다. 각각 반복문을 돌린 뒤 (i는 answers의 포인터로, j는 학생의 찍기패턴 포인터로) 정답이 맞을 때마다 object[1~3]++를 해준다. object의 values들을 체크하여 비어있으면 [1,2,3]을, 비어있지 않다면 Math.max를 통해 최대값을 산출한다 최종적으로 해당 max와 일치하는 value값을 갖는 object를 찾아주고 answer 배열에 push해준다. 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function solution(answers) { let answer = []; const student1 = [1, 2, 3, 4, 5]; const student2 = [2, 1, 2, 3, 2, 4, 2, 5]; const student3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; let obj = {}; for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student1.length) { j = 0; } if (answers[i] === student1[j]) { if (!obj[1]) { obj[1] = 1; } else { obj[1]++; } } j++; } for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student2.length) { j = 0; } if (answers[i] === student2[j]) { if (!obj[2]) { obj[2] = 1; } else { obj[2]++; } } j++; } for (let i = 0, j = 0; i &lt; answers.length; i++) { if (j === student3.length) { j = 0; } if (answers[i] === student3[j]) { if (!obj[3]) { obj[3] = 1; } else { obj[3]++; } } j++; } // 오브젝트에 담아줬기 때문에 각 값들을 다시 풀어준다. let values = Object.values(obj); // 만약 values가 비어있다면 아무도 한 문제도 못 맞힌 것이다. if (values.length === 0) { return [1, 2, 3]; } let max = Math.max(...values); // 반복문을 통해 object 안에 있는 key들의 value가 max와 일치하는 것들을 answer에 push한다 for (let i = 1; i &lt; 4; i++) { if (obj[i] === max) { answer.push(i); } } return answer;} 소스코드 (2차 풀이) 위의 코드가 너무 지저분해서 한번 리팩토링을 해봤다. 생각해보니 j값을 따로 두고 계속 학생의 정답패턴의 끝에 닿을 때 초기화 시킬 필요 없이 %를 사용하면 쉽게 해결할 수 있는 문제였다. 12345678910111213141516171819function solution(answers) { let answer = []; const s1 = [1, 2, 3, 4, 5]; const s2 = [2, 1, 2, 3, 2, 4, 2, 5]; const s3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; const s1Count = answers.filter((a, i) =&gt; s1[i % s1.length] === a).length; const s2Count = answers.filter((a, i) =&gt; s2[i % s2.length] === a).length; const s3Count = answers.filter((a, i) =&gt; s3[i % s3.length] === a).length; const max = Math.max(s1Count, s2Count, s3Count); if (s1Count + s2Count + s3Count === 0) return [1, 2, 3]; s1Count === max &amp;&amp; answer.push(1); s2Count === max &amp;&amp; answer.push(2); s3Count === max &amp;&amp; answer.push(3); return answer;}","link":"/algorithm/programmers/SemiTest/"},{"title":"프로그래머스 - 위장 (Javascript)","text":"문제 설명스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 같은 이름을 가진 의상은 존재하지 않습니다. clothes의 모든 원소는 문자열로 이루어져 있습니다. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_‘ 로만 이루어져 있습니다. 스파이는 하루에 최소 한 개의 의상은 입습니다. 입출력 예 clothes return [[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]] 5 [[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]] 3 입출력 예 설명예제 #1 headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다. yellow_hat blue_sunglasses green_turban yellow_hat + blue_sunglasses green_turban + blue_sunglasses 예제 #2 face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다. crow_mask blue_sunglasses smoky_makeup 풀이 과정 수학적 지식과 센스가 필요했던 알고리즘 문제였다..그래서 조금 애를 먹었다ㅜ 오브젝트로 된 옷장을 만들어 관리해보자. 사실 어떤 옷이 들어갔느냐는 중요하지 않다. 각 카테고리별 몇 개의 옷이 들어갔는지가 중요하다. 따라서 옷장 closet 객체를 생성해준다. (각 카테고리별 옷의 개수가 담길 객체) clothes.forEach를 통해 각 카테고리별 옷의 개수를 카운팅 후 → closet에 할당해준다. 마지막으로 경우의 수를 구해준다. (여기가 키 포인트!) ⭐️ ⇒ 조합에 대한 경우의 수의 경우 만약 A,B,C 카테고리가 존재한다면 A+B+C+AB+AC+CB+ABC가 경우의 수를 도출하는 공식이 된다. 따라서 경우의 수 공식에 따라, **(A+1)(B+1)(C+1)-1**을 해주면 모든 옷에 대한 조합의 경우의 수를 구할 수 있는 것이다. (아래에서 더 자세히 설명해보도록 하겠다) 경우의 수 설명 아래 사진과 같이 모자류 하나, 상의류 두 개, 하의류 두 개가 인풋값으로 주어졌다고 가정해보자. 여기서 간과해서는 안되는 것이 있는데, 각 의류들은 입어도 되고 안입어도 된다는 것이다. 이 때문에 각 종류별로 옷을 입지 않는 경우의 수 X를 추가적으로 배치해둔 것이다. 자, 이제 그럼 왜 위의 그림에서 옷 조합의 경우의 수가 (1+1)*(2+1)*(3+1)-1이 되는지 차근차근 짚고 넘어가보도록 하자. 옷 종류(n) + 입지 않는 경우의 수(1) 곱셈 = 몇 번 반복되는가? 우선, 하의는 차치하고 상의와 모자만의 경우로 좁혀서 생각해보자. 초등학교 때 수도 없이 들었듯, 곱셈은 덧셈이 반복되는 횟수라고 할 수 있다. 2*5의 의미 = “+2의 5번 반복”이듯이 말이다. 위 그림을 글로 풀어 설명해보면 이렇다. 모자를 썼을 때 그리고 안 썼을 때에는… 파란색 티셔츠를 고를 수 있다. 빨간색 티셔츠를 고를 수 있다. 상의를 아예 입지 않을 수도 있다. 즉, 모자를 썼을 때와 안 썼을 때의 경우의 수(2)는 상의의 경우의 수만큼 반복된다는 것이다. 따라서 2*3이라는 공식이 도출된다. 마지막으로, 이제 하의의 경우의 수까지 봐보도록 하자. 위에서 도출한 2*3의 경우의 수는 하의의 경우의 수에 의해 몇 번 반복될까? 당연히 세 번이다. 파란색 바지를 입는 경우, 츄리닝을 입는 경우, 아예 입지 않는 경우 세 개의 경우의 수가 존재하기 때문이다. 따라서 위에서 도출한 모자와 상의를 입는 조합의 경우의 수 2*3이 세 번 더 반복 되어야 한다는 것이다. 이러한 이유 때문에 최종 공식이 (1+1)*(2+1)*(2+1)-1이 된 것이다. 마지막에 -1은 왜 해주는가? 간단하다, 아무 옷도 입지 않는 경우의 수는 존재하지 않기 때문이다. 문제 제한사항에서도 주어졌듯, 스파이는 변태가 아니기 때문에(물론 상의는 입고 하의는 입지 않는 것도 이상하긴 하지만..) 아예 어떠한 옷도 입지 않고 나가는 경우는 없다. 따라서 어떠한 것도 입지 않는 경우의 수 1을 최종적으로 빼주는 것이다. 소스코드12345678910111213141516function solution(clothes) { let answer = 1; const closet = {}; // 각 카테고리별 옷의 개수를 담을 closet 객체 clothes.forEach((cloth) =&gt; { // closet에 해당 카테고리의 옷이 없으면 1을 할당, 아니면 기존 값에 1 더해주기! closet[cloth[1]] ? closet[cloth[1]]++ : (closet[cloth[1]] = 1); }); Object.keys(closet).forEach((cloth) =&gt; { // 이제 위에서 설명했던 로직 그대로 경우의 수를 구해주자. answer *= closet[cloth] + 1; }); return answer - 1; // 어떠한 옷도 입지 않는 경우의 수 제거}","link":"/algorithm/programmers/Spy/"},{"title":"프로그래머스 - 베스트 앨범 (Javascript)","text":"문제 설명스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. 입출력 예 genres plays return [“classic”, “pop”, “classic”, “classic”, “pop”] [500, 600, 150, 800, 2500] [4, 1, 3, 0] 입출력 예 설명classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다. 고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생 pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다. 고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생 따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다. 풀이 과정 음… 레벨3이라고 해서 굉장히 지레 겁을 먹고 풀기 시작했었는데,생각보다 쉽게 풀어낼 수 있었다. (개인적으로는 직전 위장 문제가 더 어려웠음) {장르: [스트리밍횟수 총합, [스트리밍 횟수, index]]} 와 같은 형태로 오브젝트를 생성해준다. 그리고 해당 오브젝트를 만든 뒤, obj[장르][0]을 기준으로 장르별 우선순위를 구한다. 마지막으로, 장르별 우선순위를 순으로 장르별 베스트앨범 2개를 answer에 push한다. 소스코드112345678910111213141516171819202122232425function solution(genres, plays) { const answer = []; const obj = {}; let sortedList = []; genres.forEach((genre, i) =&gt; { if (!obj[genre]) { obj[genre] = [plays[i], [[plays[i], i]]]; return; } obj[genre][0] += plays[i]; obj[genre][1].push([plays[i], i]); }); // 장르별 정렬 const genreList = Object.keys(obj).sort((a, b) =&gt; obj[b][0] - obj[a][0]); // 스트리밍 횟수별 정렬 genreList.forEach((genre, i) =&gt; { sortedList = []; sortedList = obj[genre][1].sort((a, b) =&gt; b[0] - a[0]); sortedList.forEach((li, i) =&gt; { if (i &gt; 1) return; answer.push(li[1]); }); }); return answer;} 소스코드2 (시간복잡도 개선) 123456789101112131415161718192021222324252627282930313233343536373839function solution(genres, plays) { const answer = []; const obj = {}; genres.forEach((genre, i) =&gt; { if (!obj[genre]) return (obj[genre] = [plays[i], [[plays[i], i]]]); // 장르별 스트리밍 횟수는 계속 더해줌 obj[genre][0] += plays[i]; // 1.현재 기준 장르별 리스트에서 가장 스트리밍 횟수가 높은 곡과 비교 if (obj[genre][1][0][0] &lt; plays[i]) { // 만약 현재 2위곡이 있다면, 원래 1위가 2위가 되어야 하기 때문에 원래 2위는 제거 if (obj[genre][1][1] !== undefined) obj[genre][1].pop(); // 제일 앞에 있던 곡이 현재 곡에 밀린 것이기 때문에 원래 앞에 놈을 맨 뒤로 보냄 obj[genre][1].push(obj[genre][1][0]); // 그리고 새로 들어온 곡을 0번째에 넣어줌 (unshift를 사용해도 되지만 시간복잡도를 고려했음) obj[genre][1][0] = [plays[i], i]; return; } // 2.위 기준 미충족 -&gt; 제일 많이 들은 곡과 동률일 때, 또는 현재 장르 내 2위보다 현재 곡 스트리밍 횟수가 더 클 경우 if ( obj[genre][1][0][0] === plays[i] || (obj[genre][1][1] !== undefined &amp;&amp; obj[genre][1][1][0] &lt; plays[i]) ) { // 원래 2위였던 곡 Out obj[genre][1].pop(); // 현재 곡을 2위로! (같을 경우는 인덱스가 작은 것이 더 우선순위로 와야되기 때문에 선형적 순회 방식을 따르는 현재로썬 그냥 뒤로 보내주는 것이 맞음) obj[genre][1].push([plays[i], i]); return; } // 2위 곡이 계속 비어있으면 안되기 때문에 우선은 아래와 같이 2번 자리는 계속 채워줌 if (obj[genre][1][1] === undefined) obj[genre][1].push([plays[i], i]); }); // 장르별 정렬 const genreList = Object.keys(obj).sort((a, b) =&gt; obj[b][0] - obj[a][0]); // 장르 순으로 각 장르별 베스트2 음악들을 answer에 push genreList.forEach((genre) =&gt; { obj[genre][1].forEach((li) =&gt; answer.push(li[1])); }); return answer;} 주석 제거 (솔루션2)1234567891011121314151617181920212223242526272829function solution(genres, plays) { const answer = []; const obj = {}; genres.forEach((genre, i) =&gt; { if (!obj[genre]) return (obj[genre] = [plays[i], [[plays[i], i]]]); obj[genre][0] += plays[i]; if (obj[genre][1][0][0] &lt; plays[i]) { if (obj[genre][1][1] !== undefined) obj[genre][1].pop(); obj[genre][1].push(obj[genre][1][0]); obj[genre][1][0] = [plays[i], i]; return; } if ( obj[genre][1][0][0] === plays[i] || (obj[genre][1][1] !== undefined &amp;&amp; obj[genre][1][1][0] &lt; plays[i]) ) { obj[genre][1].pop(); obj[genre][1].push([plays[i], i]); return; } if (obj[genre][1][1] === undefined) obj[genre][1].push([plays[i], i]); }); const genreList = Object.keys(obj).sort((a, b) =&gt; obj[b][0] - obj[a][0]); genreList.forEach((genre) =&gt; { obj[genre][1].forEach((li) =&gt; answer.push(li[1])); }); return answer;}","link":"/algorithm/programmers/bestAlbum/"},{"title":"프로그래머스 - 카펫 (Javascript)","text":"코로나에 걸려버렸다..뭐 아직까진 무증상에 가깝지만 집에 가만히 있기 따분해서 격리 기간동안 알고리즘이나 열심히 풀어보려 한다..!! 문제 설명Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다. Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다. Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요. 제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예 brown yellow return 10 2 [4, 3] 8 1 [3, 3] 24 24 [8, 6] 소스코드 (첫 시도) 프로그래머스에서는 틀린 테스트케이스를 확인할 수가 없어서…도저히 아래 풀이법이 왜 틀린건지 모르겠다 ㅜ 아래와 같이 풀면 시간복잡도도 굉장히 우수할 것 같은데 말이다. 123456789101112131415function solution(brown, yellow) { const answer = []; let border = 0; function paint(row, col) { if (!col) return; border = 2 * (row + col) + 4; if (border === brown) { return answer.push([col + 2, row + 2]); } paint(row * 2, col / 2); return; } paint(1, yellow); return answer[0];} 소스코드 (최종) 그냥 욕심을 버리고 순차적인 탐색법을 통해 풀었더니 모든 테스트케이스를 통과할 수 있었다.그리고 추가적으로, 반복문 조건에서 Math.sqrt()를 사용하며 시간복잡도를 대폭 개선할 수 있었다. 1234567891011function solution(brown, yellow) { const answer = []; const size = brown + yellow; let col; for (let row = 3; row &lt;= Math.sqrt(size); row++) { if (size % row !== 0) continue; col = size / row; if ((col + row) * 2 - 4 === brown) answer.push(col, row); } return answer;} 반복문 조건 시작점이 3인 이유 Yellow는 반드시 한 줄이 필요하다. 따라서 Yellow가 한 줄일 때 위 아래로 한 줄씩 brown이 감싸면 총 row는 3이 되기 때문에 반복문의 시작점이 3인 것이다. 조건문에서 Math.sqrt()를 사용한 이유 문제의 제한사항 때문이다!문제에서는 반드시 카페트가 정사각형 또는 가로가 더 긴 직사각형이어야 한다고 했다. 위 그림을 기준으로 설명을 해보면, 반복문의 종료지점은 size 30의 제곱근인 5.xx가 될 것이다. 이는 쉽게 말해 row의 최대값이 5라는 것이다. 왤까? 아래의 그림을 살펴보자. 위 그림에서 자세히 나와있듯, 이번 문제의 제한사항에서 row가 가질 수 있는 최대값은 딱 size의 제곱근 까지다. 이 덕분에 반복문의 반복횟수를 효과적으로 감축할 수 있었다.","link":"/algorithm/programmers/carpet/"},{"title":"프로그래머스 - 기능 개발 (Javascript)","text":"문제 설명프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 입출력 예 progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1] [95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2] 입출력 예 설명입출력 예 #1첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다. 따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다. 입출력 예 #2모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다. 따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다. 소스코드12345678910111213141516171819202122232425262728293031// [7, 3, 9]function solution(progresses, speeds) { let answer = []; let count = 1; // 남은 진행률 = lefts const lefts = progresses.map((progress) =&gt; 100 - progress); // 완료까지 며칠이 걸리는지 = daysToComplete const daysToComplete = lefts.map((left, i) =&gt; Math.ceil(left / speeds[i])); // 현재로써 가장 오래 걸리는 노드 = maxNode let maxNode = daysToComplete[0]; function getCount(start) { // 우선,끝에 닿았을 때는 현재 count를 그냥 push해주고 함수를 종료다. if (start === daysToComplete.length - 1) return answer.push(count); // 1. 만약 maxNode보다 다음 노드가 작거나 같다면 count를 늘리고 다음 노드로 넘어가야 함 if (daysToComplete[start + 1] &lt;= maxNode) { count++; getCount(start + 1); return; } // 2. 여기부터는 다음 노드가 maxNode보다 클 경우다. // maxNode는 다음 노드로 갱신되고, answer에 현재까지의 count를 push해준다. maxNode = daysToComplete[start + 1]; answer.push(count); // 3. count를 1로 초기화 한다. count = 1; // 4. 재귀 실행 getCount(start + 1); } getCount(0); return answer;}","link":"/algorithm/programmers/functionDevelop/"},{"title":"프로그래머스 - 소수 찾기 (Javascript)","text":"문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 제한사항 numbers는 길이 1 이상 7 이하인 문자열입니다. numbers는 0~9까지 숫자만으로 이루어져 있습니다. “013”은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 입출력 예 numbers return “17” 3 “011” 2 입출력 예 설명예제 #1 : [1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다. 예제 #2 : [0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다. 11과 011은 같은 숫자로 취급합니다. 풀이 과정 소수를 구하는게 문제가 아니라…모든 숫자들의 순열 조합들을 구하는게 굉~~장히 까다로웠다. 순열과 조합을 생성하기 위한 헬퍼 함수를 만든다. 그리고 numbers의 모든 순열조합을 중복 없이 사용하기 위한 Set을 생성해 사용한다. Set을 통해 모든 순열조합들의 소수여부를 판별한다. 소스 코드12345678910111213141516171819202122232425262728function solution(numbers) { let answer = 0; const numArr = [...numbers]; const numSet = new Set(); function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); nums.forEach((num, i) =&gt; { // nums를 깊은 복사! (splice에 의해 원본 배열이 변경되는 것 방지) let copy = [...nums]; copy.splice(i, 1); // temp에서 i번째 요소를 제거 permutation(copy, numString + num); // 재귀 시작(잘린 배열, '넘겨진 숫자'+'위에서 빠진 놈') }); return numSet.add(Number(numString)); } permutation(numArr, ''); const allCombinations = Array.from(numSet); allCombinations.forEach((num) =&gt; (answer += isPrimeNum(num) ? 1 : 0)); return answer;}function isPrimeNum(num) { // 소수를 찾을 때에는 타겟넘버의 제곱근 까지만 판별해도 된다고 한다. for (let i = 2; i &lt;= Math.sqrt(num); i++) { // 순회를 하다가 단 하나라도 i로 나눴을 때 0으로 나누어 떨어지면 이 숫자는 소수가 아니다. if (Number(num) % i === 0) return false; } return 2 &lt;= Number(num); // 넘어온 num 자체가 0 또는 1일 수 있으므로 이와 같이 처리.} permutation 헬퍼함수 설명 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 입력 예시 : nums = [1,0,3]//#1function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); // 1.처음에 [1,0,3],''가 매개변수 값으로 들어온다. nums.forEach((num, i) =&gt; { let copy = [...nums]; // 2.깊은 복사를 한다. copy.splice(i, 1); // 3.i번째 값을 잘라낸다. (i=0 -&gt; [0,3]) permutation(copy, numString + num); // 재귀함수를 실행시킨다. ([0,3], ''+'1') }); return numSet.add(Number(numString)); } permutation(numArr, &quot;&quot;);}//#2function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); // 1.이번엔 [0,3],'1'이 매개변수 값으로 들어온다. nums.forEach((num, i) =&gt; { let copy = [...nums]; // 2.깊은 복사를 한다. copy.splice(i, 1); // 3.i번째 값을 잘라낸다. (i=0 -&gt; [3]) permutation(copy, numString + num); // 재귀함수를 실행시킨다. ([3], '1'+'0') }); return numSet.add(Number(numString)); } permutation(numArr, &quot;&quot;);}//#3function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); // 1.이번엔 [3],'10'이 매개변수 값으로 들어온다. nums.forEach((num, i) =&gt; { let copy = [...nums]; // 2.깊은 복사를 한다. copy.splice(i, 1); // 3.i번째 값을 잘라낸다. (i=0 -&gt; []) permutation(copy, numString + num); // 재귀함수를 실행시킨다. ([], '10'+'3') }); return numSet.add(Number(numString)); } permutation(numArr, &quot;&quot;);}//#4function permutation(nums, numString) { // 이번엔 nums가 위에서 []로 넘어왔기 때문에 아래 조건문에 걸린다. // 따라서 현재의 numString값을 Set에 add해준다. if (!nums.length) return numSet.add(Number(numString));}// 그럼 이제 그 다음 콜스택인 [0,3], '1'이었던 때로 돌아간다. forEach문으로!//#5function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); // 1.위에서 실행시켰던 #2으로 되돌아 온 것이다. 동일하게 [0,3],'1'이다. nums.forEach((num, i) =&gt; { let copy = [...nums]; // 2.깊은 복사를 한다. copy.splice(i, 1); // 3.이번엔 i가 1 더해진 상태이기 때문에 i=1이다 (위에서 0 실행했음) permutation(copy, numString + num); // 재귀함수를 실행시킨다. ([0], '1'+'3') }); return numSet.add(Number(numString)); } permutation(numArr, &quot;&quot;);}//#6function permutation(nums, numString) { if (!nums.length) return numSet.add(Number(numString)); // 1.이번엔 [0],'13'이 매개변수 값으로 들어온다. nums.forEach((num, i) =&gt; { let copy = [...nums]; // 2.깊은 복사를 한다. copy.splice(i, 1); // 3.i번째 값을 잘라낸다. (i=0 -&gt; [0]) permutation(copy, numString + num); // 재귀함수를 실행시킨다. ([], '13'+'0') }); return numSet.add(Number(numString)); } permutation(numArr, &quot;&quot;);}//#7function permutation(nums, numString) { // 이번엔 [],'130'이 매개변수 값으로 들어왔으나, nums의 length가 0이다. // 따라서 아래 조건에 걸리기 때문에 '130'을 Set에 add 해준다. if (!nums.length) return numSet.add(Number(numString));}// #8 =&gt; 이하는 생략하도록 하겠다.// #2의 forEach문이 이제 다 돈 것이기 때문에, 이제 #1의 forEach문으로 (i=1) 돌아가면 된다.","link":"/algorithm/programmers/findePrimeNum/"},{"title":"프로그래머스 - 체육복 (Javascript)","text":"문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve 5 [2,4] [1,3,5] 5 [2,4] [3] 3 [3] [1] 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 풀이 과정 체육복의 여분을 가져온 학생은 우선적으로 reserve에서 제외되어야 한다! 우선 object에 각 key에 대한 카운트를 한다. for문을 통해 reserve에 lost에도 똑같은 값이 있는지 체크하고, 해당 값을 양측에서 모두 제거해준다. ⇒ 단, 그냥 splice를 해버리면 배열의 length가 도중에 줄어들어서 반복문이 배열의 끝에 닿지 못한다. 이번에는 plus, minus 값이 object에 있는지 없는지 체크하고 있다면 해당 값들을 제거한다. 각 조건문마다 answer++를 걸어서 최종적으로 answer값을 도출해주면 된다. 소스코드1234567891011121314151617181920212223242526function solution(n, lost, reserve) { lost.sort(); reserve.sort(); let obj = {}; lost.forEach((el) =&gt; !obj[el] &amp;&amp; (obj[el] = 1)); let answer = n - lost.length; for (let i = 0; i &lt; reserve.length; i++) { if (obj[reserve[i]]) { obj[reserve[i]]--; answer++; reserve.splice(i, 1, 'del'); } } for (let i = 0; i &lt; reserve.length; i++) { let minus = reserve[i] - 1; let plus = reserve[i] + 1; if (obj[plus]) { obj[plus]--; answer++; } else if (obj[minus]) { obj[minus]--; answer++; } } return answer;} 프로그래머스 고인물의 풀이…. (filter 활용)12345678910function solution(n, lost, reserve) { return ( n - lost.filter((a) =&gt; { const b = reserve.filter((c) =&gt; Math.abs(c - r) &lt;= 1); if (!b) return false; reserve = reserve.filter((d) =&gt; d !== b); }) );}","link":"/algorithm/programmers/greedy1/"},{"title":"프로그래머스 - 가장 큰 수 (Javascript)","text":"문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요. 제한 사항 numbers의 길이는 1 이상 100,000 이하입니다. numbers의 원소는 0 이상 1,000 이하입니다. 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 입출력 예 numbers return [6, 10, 2] “6210” [3, 30, 34, 5, 9] “9534330” 풀이 과정 처음에 조금 삽질을 했다…그냥 sort 함수에서 정방향으로 더한 것과 치환하여 더한 것을 비교만 해주면 되는 문제였는데.. 너무 생각이 많았던 것 같다. string 두 개를 붙여준 뒤 해당 값의 대소비교를 해줘야 하기 때문에 stringArr를 만들었다. ⇒ numbers.map(num ⇒ num.toString()) 이제 string으로 변환된 stringArr을 sort()를 활용해 정렬해준다. sortFunction의 원리는 간단하다. 정방향과 치환된 문자열 두 개를 서로 비교해준 뒤, 더 큰 값이 앞으로 정렬되도록 하면 되기 때문이다. javascript Array.prototype.sort()의 동작원리를 이해해보자 사실 위의 풀이 방법은 자바스크립트 내장 메소드인 sort() 동작 원리를 이해해야 쉽게 이해하고 풀이할 수 있다 12345const array = [20, 100, 50, 30];array.sort((a, b) =&gt; a - b); // 오름차순 정렬 =&gt; [20, 30, 50, 100]array.sort((a, b) =&gt; b - a); // 내림차순 정렬 =&gt; [100, 50, 30, 20] 근데 왜 b-a가 내림차순이 되는걸까?sort()는 a와 b의 연산 후 반환값이 음수면 자리를 바꾸고, 양수면 그대로 둔다는 특성을 갖는다.이를 이해하고 아래의 정렬 과정을 보면 이해가 쉬울 것이다. 1234567891011121314// 차례대로 확인해보자! [20,100,50,30]// 그리고 헷갈릴 수도 있는데, sort 함수에서는 a가 뒷 요소, b가 앞 요소를 가리킨다.// 1. 20(b) - 100(a) === 음수(-) -&gt; [100,20,50,30] // 음수니까 자리 바꿈// 2. 20(b) - 50(a) === 음수(-) -&gt; [100,50,20,30] // 상동// 3. 20(b) - 30(a) === 음수(-) -&gt; [100,50,30,20] // 상동// 그럼 이런 경우는 어떨까? [100,50,70,200]// 1. 100 - 50 === 양수 (+) -&gt; [100, 50, 70, 200]// 2. 50 - 70 === 음수(-) -&gt; [100, 70, 50, 200]// 3. 50 - 200 === 음수(-) -&gt; [100, 70, 200, 50]// ... 이 과정이 반복! 이처럼, return값이 양수면 그대로 위치를 유지하고, 음수면 자리를 바꿔준다는 로직만 이해하고 있으면 된다. 따라서 a-b, b-a일 경우에는 대소비교에 따라 음수 양수 값이 정반대가 되기 때문에 b-a일 때에는 내림차순 정렬이, a-b일 때에는 오름차순 정렬이 되는 것이다. 소스코드 (첫 시도… 대실패) 너무 생각이 많았다. 그냥 대소비교를 해주면 될 것을… 뭔가 숨겨진 공식이 있을 것 같아서 머리를 굴리다가 외려 좋지 못한 코드가 나왔다. 1234567891011121314151617181920212223242526272829function solution(numbers) { let answer = ''; const stringArr = numbers.map((num) =&gt; num.toString()); const sortedArr = stringArr.sort((a, b) =&gt; { if (b[0] !== a[0]) return Number(b[0]) - Number(a[0]); if (b.length === a.length) return Number(b) - Number(a); // 앞에가 긴 놈일 때 if (a.length &gt; b.length) { // 앞 자리가 끝 자리보다 클 때 if (Number(a[0]) &gt; Number(a[a.length - 1])) { return Number(a) - Number(b); } // 앞 자리가 끝 자리보다 작을 때 return Number(b) - Number(a); } // 뒤에가 긴 놈일 때 if (b.length &gt; a.length) { // 앞 자리가 끝 자리보다 클 때 if (Number(b[0]) &gt; Number(b[b.length - 1])) { return Number(b) - Number(a); } // 앞 자리가 끝 자리보다 작을 때 return Number(a) - Number(b); } return 0; }); sortedArr.forEach((arr) =&gt; (answer += arr)); return answer;} 소스코드 (최종) 그냥 욕심을 버리고 다시 처음부터 생각해봤다.그냥 간단하게 대소비교만 해주면 된다는 생각에 아래와 같이 간단하게 풀어낼 수 있었다. 12345678function solution(numbers) { let answer = ''; const stringArr = numbers.map((num) =&gt; num.toString()); stringArr.sort((a, b) =&gt; Number(b + a) - Number(a + b)); if (stringArr[0] === '0') return '0'; answer = stringArr.join(''); return answer;}","link":"/algorithm/programmers/largestNumber/"},{"title":"프로그래머스 - 프린터 (Javascript)","text":"문제 설명일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 1231. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다. 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다. location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다. 입출력 예 priorities location return [2, 1, 3, 2] 2 1 [1, 1, 9, 1, 1, 1] 0 5 입출력 예 설명예제 #1 문제에 나온 예와 같습니다. 예제 #2 6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다. 소스 코드12345678910111213141516171819202122232425262728293031function solution(priorities, location) { let answer = 0; // 프린트물들을 [인덱스, 중요도]로 배열화 한다. let prints = priorities.map((priority, i) =&gt; [i, priority]); let isPrinted = false; // 프린트가 될 때까지 while문을 돌린다. while (!isPrinted) { // 현재 가장 앞의 프린트물 = currentPrint const currentPrint = prints.shift(); let isPrimary = true; for (let i = 0; i &lt; prints.length; i++) { // 현재 프린트물이 다른 프린트물들보다 중요도가 높은지 체크 if (currentPrint[1] &lt; prints[i][1]) { // 현재 프린트보다 중요도가 높은 문서가 있으면 isPrimary(제일 중요한지)를 false처리 isPrimary = false; break; } } // 위의 조건문을 거쳤는데도 현재 프린트가 제일 중요하다면? =&gt; 프린트 가능 if (isPrimary) { answer += 1; // 만약 현재 프린트의 인덱스가 location과 같다면? 프린트 됐다는 뜻 if (currentPrint[0] === location) isPrinted = true; } else { // 뒤에 현재 프린트보다 중요한 프린트물이 있으므로 현재 프린트를 제일 뒤로 미룸 prints.push(currentPrint); } } return answer;}","link":"/algorithm/programmers/printer/"},{"title":"프로그래머스 - 다리를 지나는 트럭 (Javascript)","text":"문제 설명트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다. 예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과 시간 다리를 지난 트럭 다리를 건너는 트럭 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 bridge_length는 1 이상 10,000 이하입니다. weight는 1 이상 10,000 이하입니다. truck_weights의 길이는 1 이상 10,000 이하입니다. 모든 트럭의 무게는 1 이상 weight 이하입니다. 입출력 예 bridge_length weight truck_weights return 2 10 [7,4,5,6] 8 100 100 [10] 101 100 100 [10,10,10,10,10,10,10,10,10,10] 110 코드 풀이12345678910111213141516171819202122232425262728function solution(bridge_length, weight, truck_weights) { let answer = 0; const trucks = truck_weights; // 사실 필요 없긴 한데... truck_weights가 너무 길어서 대체 const onBridge = new Array(bridge_length).fill(0); let bridgeWeight = 0; // 다리 위에 있는 트럭들의 총 무게 let currentTruck; while (true) { // 매 반복은 한 번의 이동이 일어난다는 뜻이므로 answer++ answer++; // 만약, 이번 이동에서 트럭이 다리를 빠져나가게 된다면? =&gt; 다리 위의 무게를 그만큼 차감 if (onBridge[0] !== 0) bridgeWeight -= onBridge[0]; // 맨 앞의 다리를 한 칸 제거함 (왼쪽으로 모든 트럭들을 이동시킨다는 뜻) onBridge.shift(); // 그렇게 왼쪽으로 한 칸 이동했는데, 다리가 다음 트럭의 무게를 수용할 수 있다면? if (bridgeWeight + trucks[0] &lt;= weight) { currentTruck = trucks.shift(); // 다음 올라올 트럭 = 트럭 리스트의 맨 앞 onBridge.push(currentTruck); // 다리 끝에 트럭 하나 추가 bridgeWeight += currentTruck; // 추가된 만큼 무게 증가 } else { // 무게가 이미 초과돼서 다음 트럭이 들어올 수 없으면? // 앞에서 이미 한 칸 당겼기 때문에 그냥 우측 끝에는 빈 칸을 의미하는 0을 추가함 onBridge.push(0); } // 만약 다리 위의 무게가 제로가 됐다면 ? === 더 이상 올라올 트럭이 없다는 뜻이기도 함 =&gt; 반복문 종료 if (bridgeWeight === 0) break; } return answer;} 참고로, break 조건을 반복문의 가장 마지막에 둔 이유는, 첫 bridgeWeight 는 0으로 설정되어 있기 때문이다. 따라서 해당 break 조건을 맨 아래에 둬야 반복문이 바로 종료되지 않고 정상적으로 실행될 수 있도록 해야한다. 소스 코드123456789101112131415161718192021function solution(bridge_length, weight, truck_weights) { let answer = 0; const trucks = truck_weights; const onBridge = new Array(bridge_length).fill(0); let bridgeWeight = 0; let currentTruck; while (true) { answer++; if (onBridge[0] !== 0) bridgeWeight -= onBridge[0]; onBridge.shift(); if (bridgeWeight + trucks[0] &lt;= weight) { currentTruck = trucks.shift(); onBridge.push(currentTruck); bridgeWeight += currentTruck; } else { onBridge.push(0); } if (bridgeWeight === 0) break; } return answer;}","link":"/algorithm/programmers/truck/"},{"title":"Udemy - Big O (빅오 표기법)","text":"Big O? 💡 Big O표기법이란, 코드의 상대적 성능과 효율성을 측정할 수 있는 지표다. 왜 사용해야 하는가? 코드 작동과 성능에 대한 명확한 측정 척도가 필요하다. 같은 솔루션 내의 서로 다른 코드의 성능을 상대적으로 비교하는데 도움이 된다. 내 코드의 비효율적인 부분을 찾아서 해결할 수 있다. 그리고…. 면접에 단골 출제된다…!! 뭐가 더 나은 코드일까? 속도가 빠른 코드 ?⇒ 컴퓨터 성능에 따라 상이, 측정값이 정확하지 않다 메모리 점유율이 낮은 코드 ? 가독성이 좋은 코드 ? Big O의 기본 컴퓨터가 처리해야 하는 작업의 횟수를 계산 (컴퓨터 하드웨어와는 무관) O(1) ⇒ n값이 변하던 말던 처리 작업 횟수는 동일함! (일직선 수평 그래프) O(n) ⇒ 1차함수 그래프 O$$(n^2)$$ ⇒ 2차함수 그래프, 중첩 반복문 Big O 심플 계산법 (간소화) n 앞 뒤의 사칙연산 등은 무시해도 된다. 가장 큰 n제곱이 Big O의 n값이 된다. 특정 조건에 따라 리턴값이 달라질 경우 ? 무한대를 가정하고 풀면 된다. 1234567function logAtMost10(n) { // 이 경우 0~9까지는 다른 값들이 출력되는데 10부터는 계속 1~10이 출력된다. // 따라서 무한대를 가정하면 이 시간복잡도는 O(1)이 된다. for (let i = 1; i &lt;= Math.min(n, 10); i++) { console.log(i); }} 공간 복잡도 입력값(n)이 증가함에 따라 알고리즘이 차지하는 공간이 어떻게 변하는지?즉, 알고리즘이 차지하는 메모리에 초점을 맞춤 규칙들 불린, 숫자, undefiend, null은 모두 같은 크기의 공간을 차지한다. 문자열(String)은 O(n)의 크기를 필요로 한다. 배열과 오브젝트 또한 O(n)의 크기를 필요로 한다. 계산 방법 ⇒ 선언되는 변수, 즉 차지하는 메모리에 집중한다. (시간 복잡도는 차치)그리고 이전과 같이 무한대를 가정하기도 한다. 예시11234567function logUpTo(n) { // 이 경우 n값이 아무리 증가해도 메모리 공간은 &quot;i=&quot; 한 자리만 변화하며 필요하기 때문에 // 이 알고리즘의 공간 복잡도는 O(1)이다. for (let i = 1; i &lt;= n; i++) { console.log(i); }} 예시21234567891011function onlyElementsAtEvenIndex(array) { var newArray = Array(Math.ceil(array.length / 2)); // 이 경우는 array의 길이가 증가할 때마다 차지하는 공간도 커진다. // 따라서, 이 알고리즘의 공간 복잡도는 O(n)이다. for (let i = 0; i &lt; array.length; i++) { if (i % 2 === 0) { newArray[i / 2] = array[i]; } } return newArray;} 로그와 섹션 재생 로그 복잡도의 사용 이유 몇몇 검색 알고리즘에서 종종 사용된다. 효율적인 정렬 알고리즘은 로그를 포함한다. 재귀 알고리즘에서 로그 공간 복잡도를 사용한다.","link":"/algorithm/udemy/1.%20BigO/"},{"title":"Udemy - 선택 정렬","text":"선택정렬이란? 선택정렬은, 버블정렬과 반대로 가장 작은 값을 찾아서 배열의 제일 앞에 쌓는 방식을 사용한다.따라서 버블정렬과 알고리즘 메카니즘 자체는 굉장히 비슷하다고 볼 수 있다. 위와 같이 배열의 가장 첫 요소부터 검사를 시작하며, 해당 값보다 작은값이 있는지 계속 체크한다. 기준 값보다 작은 값을 발견하면, 버블 정렬처럼 바로 Swap을 해주는 것이 아니라 포인터를 그 값으로 우선 이동시킨다. 그리고 해당 포인터의 값을 기준으로 다시 남은 끝부분까지 검사를 반복하며 배열에서 “가장 작은 값”을 찾아내어 제일 앞으로 이동시키는 것이다. 따라서 선택 정렬의 핵심은 가장 작은 값을 찾아서 앞으로 옮겨주는 것이라고 할 수 있다. 선택정렬 기본 예제 주어진 배열을 선택 정렬 방식으로 정렬하는 알고리즘을 작성하시오. 1234567891011121314151617181920212223function selection(arr) { // i는 배열의 시작점을, tempMin은 계속 변경될 최소값을, j는 비교를 위한 포인터를 의미한다. let i = 0; let tempMin = i; let j = tempMin + 1; while (i &lt; arr.length - 1) { if (j &gt; arr.length - 1) { [arr[i], arr[tempMin]] = [arr[tempMin], arr[i]]; i++; tempMin = i; j = tempMin + 1; } if (arr[tempMin] &gt; arr[j]) { tempMin = j; j++; continue; } j++; } return arr;}selection([22, 10, 3, 14, 30, 14]); 선택 정렬의 시간 복잡도 $O(n^2)$ 의 시간복잡도를 갖는다.이 또한 그리 효율적이지는 않은 알고리즘이지만, 그래도 swap을 버블정렬보다는 덜 하기 때문에 조금 더 나은 선택이 될 수는 있다.","link":"/algorithm/udemy/11.%20Selection/"},{"title":"Udemy - 삽입 정렬","text":"삽입 정렬이란? 삽입 정렬 또한 가장 초급 수준의 정렬 알고리즘이다.버블정렬, 선택정렬과 맥락이 비슷하지만, 그래도 이 셋중에는 가장 활용도가 높고 상대적으로 효율적인 정렬 알고리즘이라고 할 수 있다. 위의 예시에서 보이는 바와 같이, 계속 한 칸 옆의 배열을 그 앞의 배열들과 비교하여 중간에 삽입할 곳을 찾는다. 즉, 기준점 포인터를 기준으로 순회 포인터 i를 통해 계속 우측으로 이동하며 검색한다. j가 다음 대상으로 이동했을 때, 0~i의 수들을 i-- 하며 계속 숫자를 i와 비교하고, 좌측 값이 i값보다 작거나 같으면 그 값의 오른쪽에 삽입시키면 된다. 삽입 정렬 기본 예제 주어진 배열들을 오름차순으로 삽입 정렬하는 알고리즘을 작성하시오. 1234567891011121314151617181920function insertion(arr) { // 기준 값을 저장할 currentVal 변수를 선언한다. let currentVal; // 0은 좌측에 비교할 대상이 어차피 없기 때문에 1부터 시작한다. for (let i = 1; i &lt; arr.length; i++) { // 우선 currentVal에 현재 값을 저장해둔다. currentVal = arr[i]; // j가 0에 닿을 때 까지 for문을 돌리고 j는 1씩 감소해 나간다. // 그리고 j를 var로 선언한 이유는 해당 for문 블록 스코프 바깥인 상위 for문에서 j값을 활용해야 하기 때문이다. for (var j = i - 1; j &gt;= 0; j--) { // 근데 만약 currentVal이 왼쪽값보다 크거나 같으면 그 왼쪽 값들은 더 탐색할 필요가 없다. // 따라서 그냥 break를 해주고 반복문에 의해 j--를 해준다. if (arr[j] &lt;= currentVal) break; arr[j + 1] = arr[j]; } // 그리고 아까 전 j값 오른쪽(j+1)에 currentVal을 위치시킨다. arr[j + 1] = currentVal; } return arr;} 삽입 정렬 시간 복잡도 보통의 경우는 $O(n^2)$의 시간복잡도를 갖는다.하지만, 정렬이 잘 되어있는 경우에는 더 효율적으로 정렬이 수행될 수 있다. ⇒ 완전히 역순으로 정렬된 배열의 경우 최악의 시간복잡도를 보일 수 있다….! 이 링크를 참고해보면 각 정렬 알고리즘별 시간복잡도 및 효율성을 한 눈에 쉽게 확인해볼 수 있다.Sorting Algorithms Animations","link":"/algorithm/udemy/12.%20Insert/"},{"title":"Udemy - 버블 정렬","text":"정렬 알고리즘에는 정말 많은 종류가 존재한다.하지만 모두 상황에 따라 사용해야 하며, 어떤 상황에서나 완벽하게 적용되는 단 하나의 정렬 알고리즘은 존재하지 않는다.따라서 오늘은 가장 일반적인 버블정렬 알고리즘에 대해 정리해보고자 한다. 정렬을 왜 배워야 하는가? 프로그래밍 또는 알고리즘에서 정말 자주 사용되는 알고리즘이기 때문이다. 삽입, 선택, 버블, 쉘, 병합, 힙, 퀵 정렬 등의 다양한 정렬 알고리즘들이 존재한다. 💡 가장 기초적인 정렬 알고리즘은 버블, 선택, 삽입 정렬 알고리즘이다. (효율성도 조금 떨어짐)=&gt; 그래도 특정 상황에서는 매우 효율적일 수 있음 상황에 따라 효율적인 정렬 알고리즘이 있다. (장단점들이 각기 존재함) 면접에 빈출되는 주제다. sort 자바스크립트 내장함수 평소에 자주 사용했던 sort() 자바스크립트 내장 함수다.시간복잡도는 기본적으로 O(N)이지만 MDN에 따르면 인풋의 크기에 따라 복잡도가 달라질 수 있다고 한다. sort()내장함수는 때에 따라서는 굉장히 손쉽게 사용할 수 있지만, 모든 정렬 기준이 배열 내의 값들을 유니코드(String)으로 변환한 후 → 해당 값을 기준으로 정렬을 한다. 따라서 내가 원하는 결과값을 얻지 못할 확률이 높다. 이를 방지하기 위해 comparator함수를 활용할 수 있다. 12345// 오름차순 정렬somethig.sort((a, b) =&gt; a - b);// 내림차순 정렬something.sort((a, b) =&gt; b - a); 버블 정렬 자주 사용되지는 않는 정렬 알고리즘이다.그래도 이 정렬 알고리즘을 배워야 하는 이유는, 다른 알고리즘들이 얼마나 효율적인지 역체감을 할 수 있기 때문이다. 물론 이와 같이 배열의 순서를 반복문 안에서 계속 변경해줘야 한다는 점과, 지속적인 순회를 해야된다는 점이 까다롭다. 하지만 매 반복마다 순회해야 하는 배열의 길이가 짧아진다는 점도 잊어서는 안된다. 위치 바꾸기 위와 같이 ES6 문법을 사용해서 쉽게 두 요소의 위치를 바꿔줄 수 있다. 기본 예제 배열 요소들을 오름차순으로 정렬하는 버블 정렬 알고리즘을 작성하시오.j와 i 포인터 활용 1234567891011121314151617function bubble(arr) { let i = arr.length - 1; let j = 0; while (i &gt; 0) { if (j === i) { j = 0; i--; } if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } j++; } return arr;}bubble([29, 10, 14, 37, 14]); 버블정렬 최적화 버블정렬의 특성상, 매우 긴 배열에서 이미 정렬이 끝났음에도 불구하고 계속 i가 1에 닿을 때 까지 반복문을 돌린다. 이는 굉장히 비효율적이므로 최적화를 통해 이러한 문제점을 해결해야 한다. 123456789101112131415161718192021222324function bubble(arr) { let i = arr.length - 1; let j = 0; // isSwap이라는 변수를 활용한다. let isSwap; while (i &gt; 0) { // j가 끝에 닿아서 다시 0부터 탐색을 해야 할 때 isSwap을 체크한다. if (j === i) { if (!isSwap) break; // isSwap, 즉 위치 변경이 일어났다면 다시 isSwap을 false로 초기화 시킨다. isSwap = false; j = 0; i--; } // 만약 j가 i에 닿을때 까지 정렬이 한번도 안일어나면 초기의 isSwap=false 값이 유지될 것이다. // 이에 따라 반복문은 break 된다. if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; isSwap = true; } j++; } return arr;} 버블정렬의 시간복잡도 정렬이 이미 많이 된 배열에 대해서는 O(N)의 시간복잡도를 가질 수 있다. (위에서 활용한 isSwap을 사용) 하지만 일반적인 경우의 버블정렬 시간복잡도는 O($$n^2$$)이다.","link":"/algorithm/udemy/10.%20Bubble/"},{"title":"Udemy - 병합 정렬","text":"병합 정렬? 1948년 수학자 조나단 벤자민 뉴이맨이 만든 알고리즘이다.널리 알려져있고, 매우 빠른 속도를 자랑하는 정렬 알고리즘 중 하나이다. 분할점령 접근법을 활용한다.이전에 분할점령(Divide and Conquer)을 활용해본적이 있다. 분할점령은 배열을 쪼개가며 특정 값을 빠르게 찾아나가는 알고리즘이었는데, 병합 정렬 또한 비슷한 접근법을 취한다. 우선, 초기 배열을 이등분하고, 지속적으로 배열이 개별 원소들로 쪼개질 때 까지 n등분한다. 그리고 다시 원소들을 단계별로 병합하며 작은 수부터 정렬해 나가는 것이다. 사실 글로 표현하기엔 다소 어려운 부분이기에 아래의 시각자료를 보면 쉽게 이해할 수 있을 것이다. 병합을 하는 방법 (step1) 분할을 해서 가장 작은 단위로 만들고, 점점 조합(병합)해 나가며 정렬하겠다는 것은 알겠다.그렇다면 그 병합은 어떻게 이루어지는 걸까? 기본 병합 예제 주어진 정렬된 두 배열을 병합하여 완전히 정렬된 배열로 만들기 1234567891011121314151617181920212223242526function merge(arr1, arr2) { let answer = []; let i = 0; let j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr1[i] &lt;= arr2[j]) { answer.push(arr1[i]); i++; } else { answer.push(arr2[j]); j++; } } while (i &lt; arr1.length) { answer.push(arr1[i]); i++; } while (j &lt; arr2.length) { answer.push(arr2[j]); j++; } return answer;}merge([1, 10, 50], [2, 14, 99, 100]);merge([1, 14, 17, 22, 101], [2, 14, 99, 100]); 병합 정렬 알고리즘 구현 (step2) 위의 병합 알고리즘과 재귀 알고리즘을 합치면 병합 정렬 알고리즘을 구현할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637function mergeSort(arr) { // 병합 알고리즘 파트 (비교와 정렬이 일어남) const merge = (arr1, arr2) =&gt; { let answer = []; let i = 0; let j = 0; while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr1[i] &lt;= arr2[j]) { answer.push(arr1[i]); i++; } else { answer.push(arr2[j]); j++; } } while (i &lt; arr1.length) { answer.push(arr1[i]); i++; } while (j &lt; arr2.length) { answer.push(arr2[j]); j++; } return answer; }; // 병합 정렬 재귀 알고리즘 파트 (실질적으로 분할이 일어나는 곳) // 1. endpoint를 지정해준다. if (arr.length &lt;= 1) return arr; // 2. 분할을 위해 중간값, 좌측 배열, 우측 배열을 선언해준다. let mid = Math.floor(arr.length / 2); // 0~mid까지 =&gt; 계속 콜스택에 쌓아 끝까지 분할하기 위해 재귀호출 let left = mergeSort(arr.slice(0, mid)); // mid~끝까지 let right = mergeSort(arr.slice(mid)); // left와 right가 각각 정립되면 merge 함수를 호출해 병합하고 정렬해준 값을 리턴해준다. return merge(left, right);} 시간복잡도와 공간복잡도 시간 복잡도 : O(nlogn) 공간 복잡도 : O(n)","link":"/algorithm/udemy/13.%20Merge/"},{"title":"Udemy - 퀵 정렬","text":"퀵 정렬이란? 병합 정렬과 비슷하게 분할과 재귀함수를 사용하여 정렬한다.하지만 퀵 정렬에서의 분할(피버팅)은 병합에서의 분할과는 조금 다르다. 위에서 보이는 바와 같이 특정 피벗(pivot)숫자를 하나 고르고, 그 숫자를 기준으로 그 숫자보다 작은 수는 자신의 왼쪽으로 무작위로 보내고, 큰 수는 우측으로 무작위로 보낸다. 그리고 좌측 숫자들을 다시 포인터를 내려가며 순회 정렬하고 우측 또한 마찬가지로 정렬하면 된다. 쉽게 생각하면 피벗숫자를 기준으로 배열을 이등분 하고 각 배열들의 숫자들을 차례대로 정렬하는 것이다. 피벗 헬퍼 알고리즘 (step 1) 위에서 설명했듯이, 퀵정렬을 하기 위해선 피벗 헬퍼 함수를 활용해야 한다.우선 특정 숫자 기준 작은 수들은 좌측으로, 큰 수들은 우측으로 옮겨준다. 기본 코드 예시 123456789101112131415161718function pivot(arr, start = 0, end = arr.length - 1) { // 1. 첫 번째 숫자를 pivot 숫자로 삼는다 arr[start]. let swapIdx = start; // 2. 해당 숫자를 기준으로 자신보다 작은 수를 우선 우측에 배치시킨다. for (let i = start + 1; i &lt;= end; i++) { if (arr[start] &gt; arr[i]) { swapIdx++; [arr[swapIdx], arr[i]] = [arr[i], arr[swapIdx]]; } } // 3. 그리고 그 작은 숫자들의 가장 끝 인덱스와 자리를 바꾼다. [arr[swapIdx], arr[start]] = [arr[start], arr[swapIdx]]; // 4. 그러면 이제 좌측에는 자신보다 작은 숫자들만 존재하고, 우측에는 자신보다 큰 숫자들만 존재하게 된다. console.log(arr); return swapIdx;}pivot([4, 8, 2, 1, 5, 7, 6, 3]); 퀵 정렬 구현 (step 2) 이제 pivot helper 함수를 구현해 뒀으니, 퀵 정렬 알고리즘만 구현하면 된다.상당히 재귀 과정이 복잡하고 어렵다… 1234567891011121314151617181920// javascript에서는 함수 매개변수가 undefined(완전 처음 실행 시)일 경우에 default값을 아래와 같이 지정해줄 수 있다.function quickSort(arr, left = 0, right = arr.length - 1) { // 재귀함수의 endpoint는 right가 left에 닿았을 때이다 (arr.length === 1이 될 때) if (left &lt; right) { // 우선 초기 배열을 피버팅 해준다. =&gt; 그러면 첫 배열 pivot값이 정렬 됐을 때의 index값이 리턴된다. let pivotIdx = pivot(arr, left, right); //3 //left // 여기부터 재귀함수가 실행된다. 배열 전체가 보내지지만 left ~ pivotIdx-1 까지만 피버팅이 다시 되도록 한다. // 먼저 pivotIdx를 기준으로 좌측 부분들이 모두 정렬될 때 까지 아래의 함수는 실행되지 않는다. quickSort(arr, left, pivotIdx - 1); //right // 좌측이 모두 정렬되면 이제 쌓여있던 콜스택이 비워지고 이 함수호출이 실행된다. // 계속 재귀함수를 실행하며 우측 또한 마찬가지로 정렬된다. quickSort(arr, pivotIdx + 1, right); } // 그러면 이제 최종적으로 정렬된 arr이 최하단 콜스택에 의해 반환된다. return arr;}quickSort([4, 8, 2, 1, 5, 7, 6, 3]); 퀵 정렬의 시간복잡도 시간 복잡도 : O(nlogn) 하지만, 퀵 정렬은 잘 정렬되어 있는 배열에 대해서는 비효율적일 수 있다","link":"/algorithm/udemy/14.%20Quick/"},{"title":"Udemy - 지수 정렬","text":"지수 정렬이란? 이전까지 공부했던 정렬들은 모두 “비교 정렬” 방식을 기반으로 했다.하지만 지수 정렬은 숫자가 가지는 특성, 즉, 이진법에 의한 자릿수를 기반으로 정렬을 한다. 사실 이렇게만 설명하면 이해가 쉽지 않기 때문에 아래의 시각자료를 보며 이해하면 좋을 것 같다. 10진수 기준 각 자리수의 값(0~9)을 각각 하나의 상자들로 구성해준다고 생각한다. 그리고 가장 첫번째 자리수 부터 검사를 시작하는데, 첫 자리수가 0이면 0에 담고, 8이면 8에 담듯 숫자의 절대적 크기는 고려하지 않은채 각 자리수의 크기로만 배열을 골라낸다. 그렇게 가장 긴 자리수 까지 검사를 완료하면 숫자가 오름차순으로 올바르게 정렬되는 것을 확인할 수 있다. 이는 각 숫자들의 절대적 크기를 비교한 것이 아닌, 각 자리수를 비교하며 정렬을 한 것이기 때문에 이전의 정렬 방식과는 큰 차이점을 보인다고 할 수 있다. getDigit 헬퍼 (step 1) 우리는 자리수 별로 숫자들을 비교해나가야 하기 때문에, 각 숫자들의 n자리수 값이 무엇인지 반환해주는 getDigit() 헬퍼 함수가 필요하다. 1234567function getDigit(num, i) { // (num의 절대값을 10의 i제곱으로 나눈 값) % 10 =&gt; 내림처리 // 만약 i가 2라면, 100의자리수를 구하는 것이기 때문에 10의 2제곱인 100으로 num을 나누게 된다 // 그리고 그 값은 자리수가 얼마나 크건간에 나눗셈에 의해 1의 자리수가 된다. // 이를 10으로 나눈 나머지는 1의자리수만 남게 되기 때문에 해당 자리수를 쉽게 구할 수 있다. return Math.floor(Math.abs(num) / Math.pow(10, i)) % 10;} digitCount 헬퍼 (step 2) 이제 자리수들을 도출하는 헬퍼 함수를 구현했으니, 반복문을 돌리기 위해 각 숫자들의 총 자리수가 몇인지 반환해주는 digitCount() 헬퍼함수를 구현해야 한다. 1234567function digitCount(num, i) { // 0log10의 값은 -Infinity가 나오기 때문에 0의 경우에는 아래와 같이 처리해줘야 한다. if (num === 0) return 1; // 10의 몇 제곱을 해야 num이 나오는지 반환해준다. 1234의 경우 10의 3제곱이 1000이다. // 따라서 3 + 1을 해주면 1000의 자리에 해당하는 4가 올바르게 반환될 수 있다. return Math.floor(Math.log10(Math.abs(num))) + 1;} maxDigit 헬퍼 (step 3) 위에서 각 숫자들의 총 자리수 길이를 구하는 헬퍼함수를 구현했다.따라서 이제 해당 숫자들 중에서 가장 긴 자리수를 반환해주는 maxDigit() 헬퍼 함수만 구현해주면 된다. 12345678function maxDigit(arr) { let maxDigits = 0; for (let i = 0; i &lt; arr.length; i++) { // 여기서 위에서 구현해둔 digitCount 헬퍼함수를 호출해서 사용하면 된다. maxDigits = Math.max(maxDigits, digitCount(arr[i])); } return maxDigits;} 지수 정렬 구현 (step 4) 이제 위의 모든 헬퍼 함수들을 활용해서 지수 정렬을 구현해주기만 하면 된다. Array.from() 전혀 활용하고 있지 못했던 메소드다…. 신세계였어서 한번 정리를 해봤다. 12let testArray = Array.from({ length: 10 }, () =&gt; []);// 이렇게 하면 testArray는 10의 길이를 갖고, 각 요소들이 빈 배열 []로 채워지는 배열이 된다. 지수 정렬 구현12345678910111213141516171819function radixSort(arr) { // 최대 자리수 카운트 반환 let maxDigits = maxDigit(arr); // 최대 자리수를 기준으로 첫 번째 반복문 구성 for (let i = 0; i &lt; maxDigits; i++) { // 체크하는 자리수가 바뀔 때마다 bucket 초기화 let bucket = Array.from({ length: 10 }, () =&gt; []); for (let j = 0; j &lt; arr.length; j++) { let digit = getDigit(arr[j], i); // n번째 자리수가 m인 숫자들을 bucket[n]에 각각 담아줌 bucket[digit].push(arr[j]); } // 그리고 그 자리수별 숫자들을 풀어서 arr의 값을 해당 값들로 바꿔줌 arr = [].concat(...bucket); } return arr;}radixSort([8, 10, 345, 25, 777, 1928, 1994]); 지수 정렬의 시간복잡도 지수 정렬에 대한 시간복잡도는 두 쟁점이 존재한다.하나는 지수정렬이 O(nk)라는 주장과, O(nlogn)이라는 주장이다. 아래 위키피디아에 들어가면 이에 대한 내용이 잘 정리되어 있다. 위키피디아_기수정렬","link":"/algorithm/udemy/15.%20Jisoo/"},{"title":"Udemy - 자료구조","text":"자료구조란? 나는 이전까지 데이터를 담는 도구로써 배열, 오브젝트만을 사용해 왔었다.하지만 배열과 오브젝트는 특정 상황에서 최고의 효율을 보이지 못하기에 다른 자료구조(Data Structure)가 필요하다. 다양한 자료구조의 종류 자료구조를 왜 배워야 하는가? 지도 어플리케이션을 만든다고 가정을 했을 때는 그래프 자료구조가, 양 끝의 데이터를 계속 추가 및 삭제해야하는 경우에는 연결 리스트 등이 가장 효율적이다. 따라서 우리는 앞으로 다양한 알고리즘들을 효율적으로 풀기 위해 여러 대표적인 자료구조들을 배워야 한다. 그렇다면 최고의 자료구조는 무엇일까? 최고의 자료구조란 없다. 따라서 우리는 다양한 대표적 자료구조들을 익히고, 상황에 알맞게 가장 효율적인 자료구조를 골라 사용해야 한다. Javascript에서의 객체지향 프로그래밍 (OOP) 앞으로 배울 자료구조들을 효율적으로 활용하기 위해선 ES6 문법도 잘 알아야 한다.그리고 이를 기반으로 자바스크립트에서 클래스를 통해 인스턴스를 뽑아내는 객체지향 프로그래밍 방식을 반드시 알아야 한다. OOP를 위한 기본지식 클래스 클래스란, 미리 정의한 프로퍼티와 메소드를 기반으로 객체를 만들기 위한 설계도라고 생각하면 된다. 객체 클래스의 인스턴스라고도 불리며, 클래스에 선언된 그대로 생성된 실체다. 인스턴스 클래스로부터 객체를 만드는 과정을 인스턴스화 라고 칭한다.그리고 특정 클래스로부터 생성된 객체를 해당 클래스의 인스턴스라고 한다. 조금 더 자세히 얘기하면, 클래스라는 설계도를 기반으로 구현된 구체적인 실체다. 이렇게 실체화 된 인스턴스는 메모리에 할당된다. 클래스 키워드 클래스의 선언과 기본 123456789101112class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe);// Me {name: &quot;hoonjoo&quot;, gender: &quot;male&quot;, location: &quot;seoul&quot;, constructor: Object} 위와 같이 Me라는 class를 통해 aboutMe라는 인스턴스를 반환 받을 수 있다. class는 하나의 공장 또는 설계도와 같아서 new OOO을 하면 해당 클래스 내에 존재하는 constructor에 의해 그에 알맞은 인스턴스가 반환된다. 인스턴스 메소드 위에서 constructor를 통해 특정 인스턴스의 구조를 만들었다면이제는 해당 구조를 컨트롤 할 수 있는 method에 대해 알아봐야 한다. 12345678910111213141516171819202122class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; this.eat = 0; } // introduce라는 메소드 introduce() { return `my name is ${this.name} and I live in ${this.location}`; } // 내가 먹은 끼니를 더해주고, 총 몇 끼를 먹었는지 반환해주는 메소드 food() { this.eat++; return `저는 오늘 ${this.eat}끼를 먹었습니다.`; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe.introduce()); // my name is hoonjoo and I live in seoulconsole.log(aboutMe.food()); // 저는 오늘 1끼를 먹었습니다. 클래스 메소드 (정적 메소드) 클래스 메소드는 클래스 전체에 대한 메소드를 정의할 수 있게 해준다.쉽게 설명하면 인스턴스가 직접 참조할 수는 없고 클래스 본체를 통해서만 호출할 수 있는 메소드다. 1234567891011121314151617181920class Me { constructor(name, gender, address) { this.name = name; this.gender = gender; this.location = address; this.eat = 0; } // introduce라는 메소드 introduce() { return `my name is ${this.name} and I live in ${this.location}`; } static sayHi() { return '안녕하세요!'; }}let aboutMe = new Me('hoonjoo', 'male', 'seoul');console.log(aboutMe.sayHi()); // 오류가 난다.console.log(Me.sayHi()); // 잘 호출된다.","link":"/algorithm/udemy/16.%20DataStructure/"},{"title":"Udemy - 단일 연결 리스트","text":"단일 연결 리스트란? 단방향성의 인덱스가 없는 배열 형식의 자료구조라고 생각해도 될 것 같다.조금 더 정확하게 설명하면, 연결 리스트란 노드와 노드 간의 연결로 이루어진 자료구조다. 이처럼 인덱스가 없기 때문에 리스트 내에서 특정 자료를 찾기 위해서 list[4]와 같이 인덱싱을 할 수 없고, 순차적으로 하나씩 이동하거나, 헤드 및 테일 등을 활용해 자료를 탐색해야 한다. (헤드와 테일에 대해선 아래에서 설명하도록 하겠다) 도대체 그럼 이걸 언제, 그리고 왜 써야되는걸까? 단일 연결 리스트는 배열에 비해 삽입과 삭제 측면에서 큰 장점을 갖는다. 앞서 설명했듯이, 인덱스가 없기 때문에 배열에서처럼 원래의 인덱스를 재할당하며 밀어내거나 당기고 했던 일련의 작업들이 불필요하다. 그냥 탐색을 하고, 해당 위치의 자료를 삭제하거나 삽입하기만 하면 된다! 하지만, 위의 그림에서 확인할 수 있듯, 배열에서는 중간에 요소를 삽입 또는 삭제하고 싶을 때, 기존 값들의 물리적 주소들을 모두 변경해야 한다. 비유를 들어 설명해보자면, 위의 그림(배열)에서 각 의자들은 자신만의 고유한 번호를 갖는다. 따라서 중간에 어떤 의자가 끼어들게 된다면 밀려난 만큼 자신의 주소값들이 일일이 수정되어야 하는 것이다. 3번 의자는 4번 의자로, 4번 의자는 5번 의자로… 하지만, 연결 리스트에서는 노드와 노드의 “연결”만이 중요하기에, 삽입을 할 때 삽입될 위치의 앞뒤 노드만 기억해주면 된다. 즉, Node.next 를 통해 각 노드들은 자신의 다음번 노드를 기억하며 연결되어 있기 때문에 next를 통한 연결만 갈아끼워주면 되는 것이다. 단일 연결 리스트에서 활용되는 프로퍼티들 그러나, 인덱스가 없는 단일 연결 리스트에도 시작점과 끝점이라는 인덱스(?)는 존재한다. 이러한 출발점과 끝점을 Head와 Tail이라 부른다. 프로퍼티 설명 Head 가장 첫 번째 노드 Tail 가장 마지막 노드 Length 리스트의 길이 (총 노드의 개수) Node 노드 (엘리먼트 or 요소) Node.next 자신과 연결된 다음 노드 단일 연결 리스트의 활용 Array에서와 동일하게, 단일 연결 리스트에서의 push, pop, shift, unshift, insert, remove 등을 구현해보도록 하겠다. 공통 아래 코드 작성 시에 공통적으로 필요한 클래스다. 1234567891011121314151617// 노드 생성을 위한 Classclass Node { constructor(val) { this.val = val; this.next = null; }}// 리스트 생성 및 연결을 위한 Classclass linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; }} push 연결 링크 맨 끝에 요소를 삽입한다. 123456789101112131415161718192021222324class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } push(val) { // Node 클래스를 활용해서 새로운 노드 인스턴스를 만든다. const node = new Node(val); // 헤드가 없다는 것은 리스트가 비어있다는 것이다. if (!this.head) { this.head = node; this.tail = node; } else { // 기존 테일의 next로 node를 연결해준다. this.tail.next = node; // 그리고 그 node를 이제 tail로 삼는다. this.tail = node; } // 길이는 push에서 언제든 늘어난다! this.length++; return this; }} pop 연결 리스트의 가장 마지막 노드를 제거해주면 된다. (push 보단 로직이 조금 복잡하다) 1234567891011121314151617181920212223242526272829class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } pop() { // 마찬가지로, 헤드가 없으면 리스트가 비어있는 것이다. if (!this.head) return null; // 현재 노드와 이전 노드를 두 변수에 각각 담아줘야 한다. let currentNode = this.head; let prevNode = null; // while문을 사용해서 node.next가 null인(next가 null이면 tail) 노드를 찾는다. while (currentNode.next) { prevNode = currentNode; currentNode = currentNode.next; } prevNode.next = null; this.tail = prevNode; this.length--; // length--를 하고 나서의 length가 0이라면, 리스트가 이제 비었다는 것이다. if (this.length === 0) { // 따라서 head와 tail을 null로 줘야 한다. this.head = null; this.tail = null; } return this; }} shift 제일 앞에 있는 노드(head)를 제거해주면 된다. 12345678910111213141516171819class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } shift() { if (!this.head) return null; // currentHead로 헤드를 깊은 복사 해준다. const currentHead = this.head; // 현재의 헤드를 기존 헤드의 next로 변경한다. this.head = currentHead.next; this.length--; if (this.length === 0) { this.tail = null; } return this; }} unshift 새로운 노드를 연결 리스트의 맨 앞에 삽입해주면 된다. (head의 변경) 12345678910111213141516171819202122class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } unshift(val) { const newNode = new Node(val); if (!this.head) { // 이 부분은 위에서 작성했던 push와 동일하다 this.head = newNode; this.tail = newNode; } else { // 1. 만약 헤드가 존재한다면, 해당 헤드를 newNode의 next에 넣어주고, newNode.next = this.head; // 2. 헤드를 newNode로 지정해준다. this.head = newNode; } this.length++; return this; }} get 입력한 인덱스(순번)에 해당하는 node를 리스트에서 찾아준다. 123456789101112131415161718192021class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } get(index) { // 0보다 작거나, 리스트의 범위를 넘어서는 노드는 찾을 수 없다. if (index &lt; 0 || index &gt;= this.length) return null; let count = 0; let currentNode = this.head; // count === index가 될 때 까지 노드를 탐색한다. while (count !== index) { // currentNode.next를 통해 한 다리 건너의 노드를 계속해서 탐색할 수 있다. currentNode = currentNode.next; count++; } // 인덱스에 해당하는 노드인 currentNode를 반환해준다. return currentNode; }} set 기존 노드의 value를 원하는 값으로 수정해준다. 1234567891011121314151617class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } set(index, value) { // 1. 위에서 작성한 get 메소드를 활용하여 찾고자 하는 index에 해당하는 노드를 활용 const targetNode = this.get(index); if (targetNode) { // 2. 찾은 노드의 val을 value(수정 원하는 값)로 수정해준다. targetNode.val = value; return true; } return false; }} insert 원하는 위치(index)에 원하는 노드를 삽입해준다. 1234567891011121314151617181920212223class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } insert(index, value) { if (index &lt; 0 || index &gt;= this.length) return false; // 0번째에 insert 하는 것은 unshift와 같다. if (index === 0) return this.unshift(value); // 끝에 insert 하는 것은 push와 같다. if (index === this.length - 1) return this.push(value); // 1. 위의 gif에서 확인할 수 있듯, 타겟노드의 이전 노드와 새로운 노드를 우선 연결시켜주고, // 2. 새로운 노드와 타겟노드를 연결시켜 주면, 새로운 노드가 정확히 원하는 위치에 삽입된다. const prevTarget = this.get(index - 1); const target = prevTarget.next; const newNode = new Node(value); newNode.next = target; prevTarget.next = newNode; this.length++; return true; }} remove 원하는 인덱스의 노드를 삭제해준다. 12345678910111213141516171819202122class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } remove(index) { if (index &lt; 0 || index &gt;= this.length) return false; // index가 0이면 shift와 같다 (맨 앞의 노드를 삭제) if (index === 0) return this.shift(); // index가 끝이면 pop과 같다 (끝의 노드를 삭제) if (index === this.length - 1) return this.pop(); // 1. 타겟 노드의 이전 노드를 찾아준다. const prevTarget = this.get(index - 1); // 2. 그리고 prevTarget을 통해 타겟노드를 찾고, const target = prevTarget.next; // 3. prevTarget.next를 타겟노드의 next로 할당해주며 연결해준다. prevTarget.next = target.next; this.length--; return true; }} 🔥 심화 : reverse 잘 연결되어 있는 노드를 역순으로 연결해준다. (실제 사용할 일은 거의 없지만 인터뷰에서 종종 출제된다고 한다) 123456789101112131415161718192021222324252627class linkedList { constructor() { this.head = null; this.tail = null; this.length = 0; } reverse() { // 깊은 복사를 통해 현재 헤드를 node(시작점, 디폴트)로 설정해준다. let node = this.head; // 그리고 헤드와 테일을 서로 치환한다. this.head = this.tail; this.tail = node; // nextNode와 prevNode를 각각 생성해준다. let nextNode; let prevNode = null; for (let i = 0; i &lt; this.length; i++) { // 다음에 체크할 노드 = 현재 노드의 next nextNode = node.next; // 그리고 현재 노드의 새로운 next = 이전 노드 node.next = prevNode; // 다음으로 넘어갈 준비 (현재 노드가 다음 번에는 prevNode가 된다) prevNode = node; // 그리고 node(기준점)은 nextNode가 된다. node = nextNode; } }} 단일 연결 리스트의 Big O 단일 연결 리스트의 시간복잡도는 이하와 같다. 메소드 시간 복잡도 push, pop, shift, unshift O(1) insert, remove O(n) get, set O(n) Array에서의 shift, unshift는 O(n)의 시간복잡도를 갖는다. 따라서 개발을 할 때, 삽입과 삭제가 잦은 경우에는 배열보다는 연결 리스트를 사용하는 것이 더 효율적일 수 있다.","link":"/algorithm/udemy/17.SLL/"},{"title":"Udemy - 이중 연결 리스트","text":"이중 연결 리스트란? 단일 연결 리스트가 단방향으로만 연결된 리스트였다면,이중 연결 리스트는 양방향으로 연결된 리스트다. 위의 사진에서 확인할 수 있듯, next와 prev를 통해 노드들이 양방향적으로 연결되어 있다. 이러한 특성 때문에 조금 더 유연하고 효율적으로 연결 리스트를 활용할 수 있다. 하지만, 이중 연결 리스트는 prev라는 프로퍼티가 하나 더 추가되었기 때문에 메모리 차지 비중이 단일 연결 리스트에 비해 크다는 상대적 단점을 갖는다. 따라서 이중 연결 리스트를 활용할 때, 이러한 공간 복잡도를 잘 고려하여 활용해야 한다. 연결 리스트에 대한 기본적인 내용들은 앞선 포스팅에서 다뤘기에, 바로 활용 방법에 대한 설명으로 들어가보도록 하겠다. 활용 방법 주요 메소드는 앞 장에서 설명했던 것과 같다. (push, pop, get, set, insert, remove) 공통 클래스1234567891011121314151617// 노드 생성을 위한 클래스class Node { constructor(val) { this.val = val; this.next = null; this.prev = null; }}// DLL 생성을 위한 클래스 뼈대class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; }} push 단일 연결리스트와 거의 유사하다.next 외에도 prev를 신경 써서 연결해주면 된다! 123456789101112131415161718192021222324class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } push(val) { const newNode = new Node(val); // 헤드가 없으면 (리스트가 비어있으면) -&gt; 삽입될 노드가 헤드와 테일이 된다. if (!this.head) { this.head = newNode; this.tail = newNode; } else { // 기존 테일의 next = push 될 노드 this.tail.next = newNode; // push될 노드의 prev = 기존 tail newNode.prev = this.tail; // push될 노드가 새로운 테일이 됨 this.tail = newNode; } this.length++; return link; }} pop 이 또한 매우 간단하다.다만 주의할 점은, 기존 Tail의 prev를 신경 써서 제거해줘야 한다는 것이다. 123456789101112131415161718192021class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } pop() { // 리스트가 비어있으면 어떠한 것도 pop할 수 없음 if (!this.head) return null; // 기존 tail이 삭제되면 새로운 tail이 될 끝에서 두 번째의 노드 const newTail = this.tail.prev; // 끝에서 두 번째 노드의 next를 삭제 newTail.next = null; // 기존 tail의 prev도 삭제 this.tail.prev = null; // 테일의 최신화 this.tail = newTail; this.length--; return DLL; }} get 이 부분이 단일 연결리스트와 큰 차이점(?)을 보인다.이전에 했던 분할 점령 방식을 활용하여 탐색 효율성을 증진 할 수 있기 때문이다. 12345678910111213141516171819202122232425262728293031323334class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } get(index) { // 인덱스가 0보다 작거나, 리스트의 길이보다 길 수는 없다. if (index &lt; 0 || index &gt;= this.length) return null; // 오름차순으로 탐색을 할 지, 내림차순으로 탐색을 할 지 체크하기 위한 변수 const isDesc = index &gt; this.length / 2; let count; let tempNode; // 오름차순 -&gt; 계속 상향식 탐색을 하며 인덱스와 카운트 수가 동일해질 때 까지 탐색한다. if (!isDesc) { tempNode = this.head; count = 0; while (count !== index) { count++; tempNode = tempNode.next; } } else { // 위와 반대! tempNode = this.tail; count = this.length - 1; while (count !== index) { count--; tempNode = tempNode.prev; } } this.length--; return tempNode; }} set set은 get을 통해 노드에 접근을 한 뒤, 값만 변경해주면 되기 때문에 매우 간단하다. 123456789101112131415161718class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } set(index, val) { // 위에서 활용했던 것과 동일하게 인덱스 가능 범위를 벗어나면 return null if (index &lt; 0 || index &gt;= this.length) return null; // 1. get을 활용하여 타겟 노드를 반환 받는다. const targetNode = this.get(index); // 2. 타겟노드가 존재하지 않는다면 return null if (!targetNode) return null; // 3. 존재한다면 ? -&gt; 매개변수로 받은 val을 노드에 갱신 targetNode.val = val; return targetNode; }} shift 맨 앞의 노드를 제거해준다.head가 변경되어야 하는 것을 주의해야 한다. 123456789101112131415161718192021class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } shift() { if (!this.head) return null; const currentHead = this.head; const newHead = currentHead.next; this.head = newHead; newHead.prev = null; currentHead.next = null; this.length--; if (this.length === 0) { this.head = null; this.tail = null; } return link; }} unshift 맨 앞에 새로운 노드를 추가해준다. 1234567891011121314151617class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } unshift(val) { if (!this.head) return this.push(val); const newNode = new Node(val); const currentHead = this.head; this.head = newNode; newNode.next = currentHead; currentHead.prev = newNode; this.length++; return link; }} insert 원하는 위치에 새로운 노드를 삽입해주면 된다.하지만 주의할 점은, 위에서도 그러하였듯이 prev와 next의 연결을 명확하게 해줘야 한다. 12345678910111213141516171819202122232425class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } insert(index, val) { // 인덱스 범위 밖 X (하지만, 삽입을 원하는 위치가 가장 끝일 수도 있기 때문에 이번에는 index &gt; this.length가 조건) if (index &lt; 0 || index &gt; this.length) return null; // index가 0이면 unshift와 동일하다 (맨 앞에 삽입을 하겠다는 것이기 때문) if (index === 0) return this.unshift(val); // 끝에 삽입하겠다는 것은 push와 동일하다. if (index === this.length) return this.push(val); const newNode = new Node(val); const leftNode = this.get(index - 1); const rightNode = leftNode.next; // 좌우 노드들과 삽입 노드를 연결지어 준다. newNode.next = rightNode; newNode.prev = leftNode; rightNode.prev = newNode; leftNode.next = newNode; this.length++; return link; }} remove 원하는 노드를 삭제해주면 된다.여기서도 동일하게 노드 간의 연결과 기존 연결의 제거를 신경써줘야 한다. 1234567891011121314151617181920212223242526class DLL { constructor() { this.head = null; this.tail = null; this.length = 0; } remove(index, val) { // 없는 노드를 삭제할 수는 없으니까! if (index &lt; 0 || index &gt;= this.length) return null; // 0번을 삭제 ? -&gt; shift() if (index === 0) return this.shift(); // 끝을 삭제 ? -&gt; pop() if (index === this.length - 1) return this.pop(); const targetNode = this.get(index); const leftNode = targetNode.prev; const rightNode = targetNode.next; // 삭제할 노드의 next prev는 제거해준다. targetNode.next = null; targetNode.prev = null; // 그리고 left와 right 노드를 서로 연결해준다. leftNode.next = rightNode; rightNode.prev = leftNode; this.length--; return link; }} 이중 연결 리스트의 시간 복잡도 메소드 시간 복잡도 Insertion (삽입) O(1) Removal (삭제) O(1) Search (탐색) O(N) Access (접근) O(N) 단일 연결 리스트에서의 Insertion과 removal은 모두 O(N)의 시간복잡도를 가졌다. 하지만, 이중 연결 리스트에서는 두 메소드 모두 **O(1)**이라는 굉장히 효율적인 시간복잡도를 갖는다. 따라서, 삽입과 삭제가 잦은 경우에는 단일 연결 리스트보다 이중 연결 리스트를 활용하는 것이 효율적일 것이다.반면, 이중 연결 리스트는 위에서도 설명했듯, 메모리 효율성이 단일 연결 리스트보다는 떨어지기에 이를 잘 고려하여 두 자료구조 중 하나를 선택하여 활용하는 것이 좋다.","link":"/algorithm/udemy/18.DLL/"},{"title":"Udemy - 스택&amp;큐","text":"스택(Stack) 후입선출법을 따르는 LIFO(Last In, First Out) 자료구조다.⇒ 나중에 들어온 것이 먼저 나간다는 뜻이다. LIFO와 FIFO의 차이 필자도 처음엔 조금 헷갈렸는데, 편의점 알바생을 기준으로 생각을 해보니 이해하기가 쉬웠다. 대부분의 편의점 알바생들은 음료 냉장고 뒤로 가서 음료수를 채워 넣는다. 이런 방식으로 음료수를 채워 넣으면 먼저 넣은 음료수일수록 (들어간 순서가 빠른) 가장 먼저 손님들에게 팔리게 된다. 반대로, LIFO의 경우는 냉장고 뒤가 아닌 앞에서 음료를 채워 넣는 알바생을 떠올리면 된다. 이럴 경우 가장 마지막에 넣은 음료가 냉장고에서 가장 앞에 진열되게 된다. 따라서 이럴 때에는 늦게 넣은 음료수일수록 손님들에게 빨리 팔리게 되는 것이다. 다시, 스택은 LIFO 자료구조다 즉, 스택은 냉장고 앞에서 음료수를 집어넣는 방식을 따르는 자료구조라고 할 수 있다. 단일 연결 리스트로 예를 들면, 위의 예시와 같이 나중에 삽입된 노드가 먼저 탐색 또는 제거되는 경우라고 보면 될 것이다. 이를 배열로 예를 다시 들면, shift()와 unshift()만을 활용하여 배열 요소의 삽입과 제거를 하는 것 또한 스택을 배열로 구현한 것이라고 볼 수 있을 것이다. 스택 자료구조는 어떻게 만들고 활용할까 스택은 undo/redo, 라우팅 등에 사용되며, 트리 또는 그래프 등에 활용된다.연결 리스트 또는 배열로 만들어 활용할 수 있다. 단일 연결 리스트로 만들어본 stack 123456class Node { constructor(val) { this.val = val; this.next = null; }} 12345678910111213141516171819202122232425262728293031class Stack { constructor() { this.head = null; this.tail = null; this.length = 0; } push(val) { const newNode = new Node(val); if (!this.head) { this.head = newNode; this.tail = newNode; } else { newNode.next = this.head; this.head = newNode; } return ++this.length; } pop() { if (!this.head) return null; // 만약 하나의 노드만 남아있는 상황이라면? if (this.head === this.tail) { // 우선 tail을 제거해준다. this.tail = null; } // 그리고 head를 변경해주는데, // 만약 위의 조건식에 해당하지 않는다면 앞에서 두 번째 노드가 새로운 헤드가 된다. // 하지만, 위 조건식에 해당한다면, head 또한 null이 된다. (노드가 하나일 때는 next가 null일 것이기 때문) this.head = this.head.next; return --this.length; }} 이렇게 단일 연결 리스트로 스택을 구현해 보았는데, 이 때에는 push와 pop이 마치 shift와 unshift처럼 동작하게 된다. stack의 시간 복잡도 메소드 시간 복잡도 push(insert) O(1) pop(remove) O(1) 탐색 및 접근 O(N) stack은 배열과 비교했을 때, shift와 unshift가 O(1)의 시간복잡도를 갖기에,만약 리스트의 맨 앞의 요소들을 추가 및 삭제할 일이 많다면 스택을 활용하는 것이 효율적일 것이다. 큐(Queue) 큐는 스택과 반대로 **선입선출법(FIFO)**을 따르는 자료구조이다. 위의 편의점 냉장고 예시에서 더 나아가, 정말 쉽게 FIFO를 직관적으로 이해할 수 있는 방법이 있다. 바로 “줄 서기“이다. 위의 그림에서 볼 수 있듯이, 우리의 일상은 대부분이 FIFO로 이루어진다. 먼저 줄을 선 사람이 먼저 계산을 하고, 우선순위를 갖는 것 처럼 말이다. 그리고 이는 컴퓨터 또한 익숙해 하는 방식이다. 만약 학교 도서관에서 공용 프린터기를 사용하는데, 먼저 프린트를 요청한 사람보다 나중에 프린트를 요청한 사람의 프린트가 먼저 된다면 옳은 것일까? 이처럼 FIFO는 어쩌면 우리에게 더 친숙한 방식일 지 모른다. 큐(Queue)는 어떻게 활용되는가?12345678910111213141516171819202122232425262728class Queue { constructor() { this.head = null; this.tail = null; this.length = 0; } // enque는 단일 연결 리스트에서 작성했던 push와 동일하다 enque(val) { const newNode = new Node(val); if (!this.head) { this.head = newNode; this.tail = newNode; } else { this.tail.next = newNode; this.tail = newNode; } return ++this.length; } // deque는 unshift와 같은 기능을 하기 때문에 위의 스택에서의 pop과 동일하다. deque() { if (!this.head) return null; if (this.head === this.tail) { this.tail = null; } this.head = this.head.next; return --this.length; }} 큐의 시간복잡도 stack과 동일하다!","link":"/algorithm/udemy/19.stackQue/"},{"title":"Udemy - 배열과 오브젝트의 성능 평가","text":"💡 BigO(빅오)의 관점에서 자바스크립트의 배열과 객체는 어떻게 작동하는가? 객체 (Object) 객체란, 순서가 배정되지 않은 “키-값” 구조로 저장된 데이터 구조다. 12345let family = { Dad: 'Kim', Mom: 'Lee', Son: 'Kim.JR',}; 특징 순서가 없다는 특징 때문에 접근 및 삽입/제거가 빠르다. O(1) 객체 탐색의 경우는 O(N)으로, 이 또한 속도가 빠른 편이다. 배열 (Array) 순서가 존재하는 데이터 구조. 1const dogs = ['jake', 'ppoya', 'apple']; 시간 복잡도 배열의 첫 번째 인덱스에 삽입이나 제거 등의 동작이 일어날 때, 효율성에 문제가 생길 수 있다.( 그 뒤의 아이템들이 밀리거나 당겨지며 인덱스가 변하기 때문) 접근 : O(1) 끝부분 삽입 : O(1) 앞부분 삽입 : O(N) 앞부분 제거 : O(N) 이동 : O(N)","link":"/algorithm/udemy/2.%20Arr_Obj/"},{"title":"Udemy - 이진 검색 트리(Tree)","text":"20.생성일: 2022년 3월 9일 오후 7:28 이진 검색 트리 이진 검색 트리는 하나의 루트 노드에서 두 개의 엣지(브랜치)로 파생된 노드들이 줄기처럼 상하 구조로 구성된 자료구조다. 사실 글로만 봐서는 한 눈에 이해하기 모호하기 때문에 바로 그림으로 설명해보도록 하겠다. 이와 같이, 루트 노드를 기준으로 노드들이 상하관계로 구성된 자료구조인 것이다. 물론 이진 검색 트리가 되기 위한 조건들이 몇 개 존재한다. 이와 같은 조건들을 만족해야지만 이진 검색 트리가 될 수 있다. 이진 검색 트리를 활용하면 데이터를 정렬할 때 훨씬 더 효율적으로 정렬을 수행할 수 있다. 애초에 루트 노드에서부터 좌우로 숫자들이 갈라지기 때문에, 이전에 학습했던 분할 점령 탐색 방식과 동일하게 경우의 수를 계속 줄여 나가며 데이터를 탐색 및 정렬할 수 있기 때문이다. 활용 방법 그렇다면 이러한 이진 검색 트리를 어떻게 구현하고 활용할 수 있을까? insert 우선, 특정 숫자를 트리 내에서 적절한 위치(대수 비교)에 insert하는 방식은 이하와 같다. 1234567class Node { constructor(val) { this.val = val; this.left = null; this.right = null; }} 12345678910111213141516171819202122232425262728293031323334class BST { constructor() { this.root = null; } insert(val) { const newNode = new Node(val); // 루트가 없을 때는 root에 새로운 노드를 할당 if (!this.root) { this.root = newNode; return this; } // 만약 루트 노드가 존재한다면? -&gt; tempNode를 루트노드로 설정 let tempNode = this.root; while (true) { // 같은 값은 처리하지 않는다. if (val === tempNode.val) return undefined; // 만약 입력된 값이 tempNode의 값보다 크다면? if (val &gt; tempNode.val) { // 그리고 만약 tempnode의 우측 노드가 비어있다면? -&gt; right가 newNode의 자리가 된다. if (!tempNode.right) { tempNode.right = newNode; return this; } tempNode = tempNode.right; } else { if (!tempNode.left) { tempNode.left = newNode; return this; } tempNode = tempNode.left; } } }} find 그리고 특정 숫자를 검색하는 find 메소드 또한 이하와 같이 구현할 수 있다. 123456789101112131415161718192021class BST { constructor() { this.root = null; } find(value) { if (this.root === null) return false; let currentNode = this.root; let found = false; while (currentNode &amp;&amp; !found) { if (value &lt; currentNode.value) { currentNode = currentNode.left; } else if (value &gt; currentNode.value) { currentNode = currentNode.right; } else { found = true; } } if (!found) return undefined; return currentNode; }} 이진 검색 트리의 시간 복잡도 메소드 시간 복잡도 insertion O(nlogn) searching O(nlogn) 이진 검색 트리는 굉장히 훌륭한 시간 복잡도를 갖는다!","link":"/algorithm/udemy/20.BST/"},{"title":"Udemy - 트리 순회(BFS&#x2F;DFS)","text":"트리 순회 이전 포스팅에서 이진 검색 트리(BST)를 학습하며 트리란 무엇인지, 그리고 트리의 기본적인 알고리즘적 활용법 등을 다뤘다. 따라서 트리의 개념 학습에서 그치는 것이 아니라, 이번 포스팅에서는 DFS와 BFS라는 트리 “탐색 기법”에 대해 정리해보고자 한다. BFS DFS 깊이 우선 탐색으로, Depth-First-Search의 약자다. 너비 우선 탐색으로, Breadth-First-Search의 약자다. 당연히 위의 개괄적인 설명만 읽고서는 DFS와 BFS를 이해할 수 없다. 따라서 각 탐색 기법을 기본 예제와 함께 더 자세히 설명해보도록 하겠다. 너비 우선 탐색(BFS) 위 gif에서 확인할 수 있듯, 너비 우선 탐색은 루트 노드에서 시작해 각 층별 노드들을 모두 훑으며 아래로 내려가며 탐색하는 순회법이다. 기본적으로 각 층에서 좌 → 우 방향으로 탐색을 하며, 각 층에 대한 노드 탐색이 끝나면 아래 층으로 향하는 것이 특징이다. 어떤 방향성을 갖고 탐색을 하는지는 이해했으니 바로 본론(코드)으로 넘어가보도록 하겠다! BST를 활용한 BFS 구현 이진 검색 트리를 활용하여 BFS를 구현해보자. 위 사진의 이진 트리를 BFS를 활용하여 탐색하면, 결과가 [10, 7, 19, 3, 9, 25]가 될 것이다. 12345678// 우선 위와 동일한 트리를 구성하기 위하여 앞선 포스팅에서 작성했던 BST insert 메소드를 활용했다.const bst = new BST();bst.insert(10);bst.insert(7);bst.insert(19);bst.insert(3);bst.insert(9);bst.insert(25); 자, 이제 본격적으로 BFS를 통해 노드 탐색 결과를 배열로써 반환 받아보도록 하자. 12345678910111213141516171819202122// ...이전에 작성했던 BST 클래스는 생략BFS() { let node = this.root; // queue는 탐색될 노드들의 대기열이라고 생각하면 된다. let queue = []; // result는 탐색된 노드들이 담길 최종 배열이다. let result = []; // 우선 초기 queue는 루트이기 때문에 기본적으로 root를 push해준다. queue.push(node); // 큐가 빌 때까지 반복한다. while (queue.length) { // Array.shift()는 제거된 요소를 반환해준다. 따라서 여기서의 node는 queue의 맨 앞 요소다. node = queue.shift(); // 그리고 해당 요소를 result에 push해준다. (탐색이 됐으니까) result.push(node.val); // 그리고 해당 node의 left 또는 right값이 존재하면 각각 &quot;차례대로&quot; queue에 담아준다. if (node.left) queue.push(node.left); if (node.right) queue.push(node.right); } return result;} queue에 대한 push를 left → right 순으로 해줬기 때문에 queue에는 left가 먼저, 그리고 그 다음에 right가 담기게 된다. 이는 선입선출법을 따른 것이므로, 우리가 의도했던 바와 같이 result 배열에는 각 층의 노드들이 왼쪽에서 오른쪽 순으로 담기게 되는 것이다. 위의 예제 BFS가 실행되는 과정은 위와 같다. (queue의 맨 앞 요소가 result에 담기고, result에 담긴 따끈한 요소의 left, right가 각각 queue에 차례대로 push 되는 것!) 깊이 우선 탐색(DFS) 이번에는 재귀를 사용해야 한다.BFS와 반대로, 우선 최대한 깊게 노드들을 탐색한 뒤 우측 노드들을 탐색하는 방식이다. 탐색할 트리는 BFS에서 활용했던 트리와 동일하다. 123456789101112131415DFS() { // 탐색 결과를 담을 result 배열 let result = []; // 헬퍼 함수! function traverse(node) { // 1. 우선 타겟 노드를 result에 담는다. result.push(node.val); // 2. 그리고 해당 노드의 left가 존재한다면 traverse에 해당 노드의 left를 담아 재실행한다.(재귀) if (node.left) traverse(node.left); // 3. 위 left에 대한 작업들이 모두 끝나면 right에 대한 탐색이 실행된다. if (node.right) traverse(node.right); } traverse(this.root); return result; } 이렇게 작성한 DFS를 실행하면 [10, 7, 3, 9, 19, 25]이 반환되어야 한다. DFS와 BFS는 언제 사용하는가? 항상 나오는 진부한 결론일 수 있지만.. 정답은 없다.때에 따라 두 방법이 낼 수 있는 효율성이 달라지기 때문이다. 그리고 시간 복잡도는 두 방식 모두 동일하다. 노드 전체를 하나 하나 탐색해야하는 것은 같기 때문이다. 따라서 중요한 것은 공간 복잡도다. DFS와 BFS는 공간 복잡도 측면에서 어떤 차이점을 보일까? 트리가 넓으면 DFS를, 깊으면 BFS를…!! 성급한 일반화일 수도 있지만, 대개 이런 공식을 따르게 될 것 같다. 노드가 굉장히 많고 넓게 펼쳐진 트리를 상상해보자(좌측 트리). 이 때 우리가 BFS를 사용하면 큐에 이 수많은 노드들을 다 담아줘야 한다. 그렇게 처리한다면 공간 복잡도가 굉장히 높아질 것이기에, 이러한 경우에는 재귀와 콜스택을 사용하는 DFS를 활용하는 것이 효율적일 것이다. 하지만 반대로, (이런 경우는 거의 없지만) 한 쪽으로만 치우쳐진 거의 배열과 다름없는 트리(우측 트리)에 대해서는 BFS가 유리하다. 한 방향으로만 탐색을 하면 되기 때문에 shift와 push에 의해 큐가 메모리를 거의 차지하지 않기 때문이다. 그러나 DFS를 이러한 형태의 트리에 사용하게 되면, 매 노드마다 콜스택이 점유되기 때문에 BFS에 비해 효율성이 떨어지게 될 것이다. 따라서, 다시 정리하자면!! 좌우로 넓고 노드가 많은 트리에서는 DFS를, 한 쪽으로 깊게 치우친 트리에 대해서는 BFS를 활용하는 것이 공간복잡도 측면에서 효율적이다.","link":"/algorithm/udemy/21.dfsbfs/"},{"title":"Udemy - 그래프(Graph)","text":"그래프 그래프는 트리에서 한 단계 더 나아가, 같은 계층 간의 노드끼리도 연결될 수 있는 하나의 자료구조다. (물론 트리도 그래프의 한 종류라고 볼 수 있다) 지도, SNS, 라우팅, 연관 데이터 추천 등등 그래프 자료구조는 정~~말 많은 곳에서 활용된다. 그래프에서 사용되는 용어 정점 (Vertex) ⇒ 하나의 독립적 노드들을 의미한다. 간선 (Edge) ⇒ 노드 사이의 연결을 의미한다. 그래프의 종류 무방향 그래프 ⇒ 특정한 방향성 없이, 모든 노드들이 서로 양방향으로 연결된 그래프다. 방향 그래프 ⇒ 방향성이 존재한다. 따라서 모든 노드들이 상호 연결되어있는 것이 아니라 한 노드가 특정 노드를 일방적으로 연결하고 있는 그래프다. 가중 그래프 ⇒ 간선(Edge)에 특정한 값 또는 의미가 부여된 그래프를 의미한다. (지도가 대표적이다. 각 노드(목적지) 간에 거리라는 특정값이 존재하기 때문이다) 비가중 그래프 ⇒ 위와 반대로 기본적인 간선을 기반으로 하는 그래프다. 간선에 특정 값이 부여 및 할당되어 있지 않다. 그래프의 활용 이제 본격적으로 그래프를 코드로써 어떻게 활용할 수 있는지에 대해 정리해보도록 하겠다. 인접 행렬 기본적으로 행과 열에 맞춰 정보를 저장하는 방식이다. 위에 제시된 그래프가 인접행렬로 표현된다면 바로 위 표와 같은 형태가 된다. 각 정점들 간의 연결을 1,0 또는 true or false를 통해 표현한 것이다. 인접 리스트 우리가 흔히 사용하던 배열을 활용한 방법이다. 위의 사진과 같이 각 정점별 직접적으로 연결 되어있는 정점(노드)들을 배열 또는 해시테이블로써 표현한 것이다. 만약 모든 정점들의 값이 숫자라면 그냥 배열과 배열의 인덱스를 통해 그래프를 표현할 수 있지만, 정점의 값이 숫자가 아닌 경우에는 index로 각 배열이 가리키는 정점값을 표현할 수 없기에, 주로 해시테이블을 사용한다. 두 그래프 표현 방식의 차이점은 뭘까? |V| : 정점의 개수 |E| : 엣지의 개수 이를 정리하자면.. 인접 행렬 인접 리스트 공간을 많이 차지한다 공간을 적게 차지한다 모든 간선을 탐색하는데 느리다 모든 간선을 탐색하는데 빠르다 특정 간선을 탐색하는 것은 빠르다 특정 간선을 탐색하는 것은 느리다 이러한 이유에 따라, 우리는 대부분 인접 리스트를 활용하게 된다.앞으로 알고리즘 문제를 풀 때에도 우리는 인접 리스트를 거의 대부분 사용하게 될 것이다. 인접 리스트를 활용한 Add 특정 정점(vertex)을 추가하는 Add 메소드 코드를 작성해보도록 하겠다. 123456789class Graph { constructor() { this.list = {}; } addVertex(v) { // 매우 간단하다. 해당 해시테이블에 v 키가 없으면 빈 배열을 밸류로 주며 만들어주면 된다. if (!this.list[v]) this.list[v] = []; }} 이번엔 무방향 그래프에서 간선(Edge)를 추가하는 Add 메소드다. 123456789class Graph { constructor() { this.list = {}; } addEdge(v1, v2) { this.list[v1] = v2; this.list[v2] = v1; }} 인접 리스트를 활용한 Remove 특정 정점(Vertex)과 간선(Edge)를 삭제하는 Remove 메소드다. 12345678910111213141516class Graph { constructor() { this.list = {}; } removeEdge(v1, v2) { this.list[v1] = this.list[v1].filter((v) =&gt; v !== v2); this.list[v2] = this.list[v2].filter((v) =&gt; v !== v1); } removeVertex(v) { while (this.list[v].length) { const tempVertex = this.list[v].pop; this.removeEdge(v, tempVertex); } delete this.list[v]; }}","link":"/algorithm/udemy/22.graph/"},{"title":"Udemy - 그래프 순회(DFS&#x2F;DFS)","text":"그래프 순회 그래프 순회는 우리의 일상 생활에서 굉장히 많이 활용될 수 있는 알고리즘 중 하나다. 대표적인 예로, 길 찾기가 있다. 특정 노드(시작점)에서 목적지로 갈 수 있는 최단거리 등을 계산하는데 활용될 수 있기 때문이다. 뿐만 아니라, 페이스북이나 인스타그램에서 처럼, 친구/팔로우 관계 등을 관리하는데 사용될 수도 있다. (연관 데이터 추천도 굉장히 많이 활용됨) 이러한 그래프 순회 방식에는 크게 두 가지의 방식이 존재한다. BFS와 DFS다. 이는 이전 트리 순회 포스팅에서 다뤘던 내용이기도 하고, 기본적인 핵심 개념은 거의 같다. DFS (깊이 우선 탐색) 재귀 방식 순회123456789101112131415161718192021222324252627class Graph { constructor() { this.list = {}; } DFS(start) { // 방문한 노드가 담길 result const result = []; // 방문한 노드의 값이 true or false로 저장됨 const visited = {}; // dfs()는 내부함수이기 때문에 아래와 같이 this를 명시해줘야 함 const list = this.list; function dfs(v) { // 존재하지 않는 값이 들어오면 null처리 if (!v) return null; // 방문 기록을 아래와 같이 기록 result.push(v); visited[v] = true; // 현재 Vertex의 배열을 forEach로 각각 접근 -&gt; 아직 그 안의 요소들이 탐색되기 전이라면? list[v].forEach((li) =&gt; { // 재귀 시작 if (!visited[li]) return dfs(li); }); } dfs(start); return result; }} 반복적 방식 순회 (배열 사용)12345678910111213141516171819202122232425262728class Graph { constructor() { this.list = {}; } DFS(start) { // 반복문을 사용한 DFS에서는 stack이 사용된다. const stack = [start]; const result = []; const visited = {}; // 첫 vertex에 대해서 true를 적용해준다. visited[start] = true; let currentVertex; while (stack.length) { // currentVertex는 stack의 끝 vertex currentVertex = stack.pop(); // 해당 vertex를 result에 push result.push(currentVertex); // 그리고 그 vertex의 인접 vertex들을 순회한다! this.list[currentVertex].forEach((v) =&gt; { if (!visited[v]) { visited[v] = true; stack.push(v); } }); } return result; }} BFS (너비 우선 탐색) 반복문 활용 방식을 사용했다.사실 위의 DFS 반복문 활용 방식과 거의 동일하나, queue를 사용한다는 차이점이 있다. 1234567891011121314151617181920212223class Graph { constructor() { this.list = {}; } BFS(start) { const queue = [start]; const visited = {}; const result = []; visited[start] = true; let currentVertex; while (queue.length) { currentVertex = queue.shift(); result.push(currentVertex); this.list[currentVertex].forEach((li) =&gt; { if (!visited[li]) { queue.push(li); visited[li] = true; } }); } return result; }}","link":"/algorithm/udemy/23.graphTraverse/"},{"title":"Udemy - 문제 해결 접근법","text":"정말 못 풀겠는 문제가 나왔을 때 우리는 어떻게 접근해야 하는가? 알고리즘이란?5%E1%86%B8%200f73cc9e30234d4b88395850f07235ab/Untitled.png) 특정한 기능이나 업무를 하기 위해 수행해야 하는 과정이나 단계들의 집합! 💡 알고리즘 실력을 늘릴 수 있는 방법 ? 💡 문제를 해결하기 위한 계획을 세운다. 일반적인 문제풀이 패턴을 마스터 한다. 🍪 문제 해결 전략 문제를 완벽히 이해한다. 구체적 예시를 꼼꼼히 탐색한다. 문제를 쪼갠다 문제를 풀고 → 단순화 한다 복기 &amp; 리팩토링 1️⃣ 문제를 완벽히 이해하기 해당 문제를 나만의 표현으로 바꿔서 설명할 수 있는가? 입력값은 무엇인가? 출력값은 무엇인가? 출력값을 얻는데 오로지 입력값만이 활용되는가? (정보의 충분성) 데이터에 어떤 이름을 붙여줘야 하는가? 예시 123456789// 두 인풋값을 받아 그 합을 출력하는 함수를 작성하시오function add(a, b) { // 1. 나만의 표현 : 입력값 두개의 합을 반환하는 함수를 제작한다. // 2. 입력값은 ? : a와 b 둘 다 정수 // 3. 출력값은 ? : 하나의 정수 (a와 b의 합) // 4. 정보의 충분성 : a와 b만 있으면 되므로 충분하다. // 5. 데이터 네이밍 : sum이 필요할 것 같다.} 2️⃣ 구체적 예시를 꼼꼼하게 탐색하기 문제를 이해하는데 큰 도움을 줄 수 있고 + 조금 더 뚜렷한 청사진을 그릴 수 있으며 + 더 다양한 추론을 이끌어낼 수 있다. 두 세가지 간단한 예시들을 그 입력값 &amp; 출력값과 함께 같이 적어 내려간다. 조금 더 복잡한 예시로 넘어간다. 유효하지 않은 입력값을 고려한다. (null, undefined, 유효하지 않은 타입 등등) ⇒ 즉, 다양한 변수들을 고려해야 한다. 3️⃣ 문제 단계별로 세분화 하기 주석을 활용해 문제를 풀 때 단계별로 필요한 로직과 코드를 차례대로 작성한다. 문제가 이해 됐어도 무작정 코드를 작성하지 않는다. 차례대로 가장 먼저 해야 할 것과 가장 나중에 해야 할 것을 정리하며문제 해결 과정을 차례대로 써 내려간다. 설령 시간이 부족해 코드를 반밖에 짜지 못했어도, 접근 방식 자체가 면접관에게 플러스 요인이 될 수 있다.Ex) “아 주석을 보니, 얘는 시간만 있으면 충분히 풀 수 있었겠구나” 4️⃣ 문제풀이 &amp; 단순화 단순화란 ?⇒ 풀 수 없는 것은 두고, 내가 풀 수 있는 것들만 먼저 해결하는 것 (부분점수 취하기 전략) 문제해결에 있어 가장 어려운 부분을 찾아낸다. 그 어려운 부분을 일단 무시한다. 간단한 솔루션들을 우선 도출한다. (풀 수 있는 단계들만 우선적으로 해결) 어려운 부분을 추후에 구현하여 통합한다. 5️⃣ 복기와 리팩토링 더 나은 개발자가 되기 위해선, 솔루션을 낸 후에도 코드를 복기 및 리팩토링 하는 습관을 들여야 한다.즉, 더 효율적인 코드가 될 수 있도록 자신의 코드를 더 발전시켜야 한다는 것이다. 체크리스트 다른 방식의 결과도 도출이 가능한가? 한 눈에 이해하기 쉬운가? 다른 문제에도 이 알고리즘과 솔루션을 적용할 수 있는가? 성능과 효율성을 더 개선할 여지가 존재하는가? 다른 사람들은 어떻게 풀었을까?","link":"/algorithm/udemy/3.%20Approach/"},{"title":"Udemy - 문제 해결 패턴","text":"일반적인 문제풀이 패턴에 대해서 정리해보았다. 1️⃣ 빈도수 세기 패턴 🎯 2중으로 중첩된 반복문 보다는, 단일 반복문 두 개를 사용하는 것이 훨씬 좋다. 빈도수 세기 알고리즘 패턴 (전체 코드) 12345678910111213141516171819202122function same(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } let frequencyCounter1 = {}; let frequencyCounter2 = {}; for (let val of arr1) { frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1; } for (let val of arr2) { frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1; } for (let key in frequencyCounter1) { if (!(key ** 2 in frequencyCounter2)) { return false; } if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) { return false; } } return true;} 패턴 분석 (단계별) 두 배열의 길이 비교 만약 두 배열의 길이가 다르다면? → 중복된 값이 있거나, 생략된 값이 있는 것을 의미한다. 1234// 두 배열의 길이가 같지 않다면, false를 반환하고 함수를 종료한다.if (arr1.length !== arr2.length) { return false;} 객체 생성 for문을 활용하여 대상객체와 도구객체 하나씩을 만든다. “그리고 위에서도 설명했듯, 중첩 반복문 보다는 단일 반복문 여러개가 더 낫다.” 123456789101112let frequencyCounter1 = {};let frequencyCounter2 = {};for (let val of arr1) { // 아래의 코드는 이러한 결과를 도출한다 =&gt; { val : (val or 0) + 1 } // 즉, 해당 값이 존재하면 그 값 +1을 해주고, 없으면 0+1을 해준다. frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1;}for (let val of arr2) { frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1;}// 이렇게 하면, 두 개의 도구대상 객체가 생성된다. 반복문 내에서 도구/대상 비교하기 객체에 대한 반복문에서는 반환값이 value가 아닌, key가 반환된다. 123456789101112for (let key in frequencyCounter1) { // {key:1} -&gt; {key^2:1}의 구조에서, // key^2의 값이 fC2의 키값에 존재하는지 체크하는 조건문 if (!(key ** 2 in frequencyCounter2)) { return false; } // {key^2 : n}에서 n값이 fC1의 {key: n}에서의 n값과 같은지 같지 않은지 체크 if (frequencyCounter2[key ** 2] !== frequencyCounter1[key]) { return false; }}// 이 모든 조건문을 통과하면 =&gt; true를 리턴한다. for ... in vs for ... of for ... in : 객체에서도 사용 가능하다. for ... of : 객체에서 사용 불가능하다 (문자열, 배열, Set 등등) ✏️ 예제 ( 애너그램 함수 ) 위의 빈도수 체크 알고리즘을 활용해 두 문자열을 비교하는 함수를 만들어보자. (소문자만 고려) 객체 만들기 1234567891011121314function validAnagram(a, b) { if (a.length !== b.length) { return false; } let aObj = {}; let bObj = {}; for (let val of a) { aObj[val] = (aObj[val] || 0) + 1; } for (let val of b) { bObj[val] = (bObj[val] || 0) + 1; } console.log(aObj, bObj);} 객체의 key와 value 일치여부 각각 체크하기 12345678for (let key in aObj) { if (!(key in bObj)) { return false; } if (aObj[key] !== bObj[key]) { return false; }} 💡 최종 솔루션 (1) 12345678910111213141516171819202122function validAnagram(a, b) { if (a.length !== b.length) { return false; } let aObj = {}; let bObj = {}; for (let val of a) { aObj[val] = (aObj[val] || 0) + 1; } for (let val of b) { bObj[val] = (bObj[val] || 0) + 1; } for (let key in aObj) { if (!(key in bObj)) { return false; } if (aObj[key] !== bObj[key]) { return false; } } return true;} 💡 이외의 솔루션 (2) 123456789101112131415161718192021222324function validAnagram(first, second) { if (first.length !== second.length) { return false; } const lookup = {}; for (let i = 0; i &lt; first.length; i++) { let letter = first[i]; lookup[letter] ? (lookup[letter] += 1) : (lookup[letter] = 1); } for (let i = 0; i &lt; second.length; i++) { let letter = second[i]; // 만약 a를 예로 들면, {a : 0}이어도, 객체에선 이를 존재하지 않는다고 계산한다. if (!lookup[letter]) { return false; } else { lookup[letter] -= 1; } // value가 0이면 false로 인식하기 때문에, 굳이 마지막에 모든 key의 value들이 0인지 더블체킹 할 필요는 없다. } return true;} 2️⃣ 다중 포인터 패턴 다중 포인터 패턴이란, 배열 또는 문자열 등의 index를 가리키는 포인터가 두 개 이상 활용되는 알고리즘 패턴을 의미한다. 🏋️ 서로의 합이 0이 되는 숫자 조합 찾기 내가 평소에 사용하던 중첩 for문 : O($n^2$)123456789function pointer(arr) { for (let i = 0; i &lt; arr.length; i++) { for (let j = i + 1; j &lt; arr.length; j++) { if (arr[i] + arr[j] === 0) { return [arr[i], arr[j]]; } } }} O(N) 버전12345678910111213141516171819// arr이 정렬되어 있음을 가정한다.// [-4,-3,-2,-1,0,1,2,3,10]function pointer2(arr) { let start = 0; let end = arr.length - 1; while (start &lt; end) { let sum = arr[start] + arr[end]; if (sum === 0) { return [arr[start], arr[right]]; } else if (sum &gt; 0) { // end가 상대적으로 더 크다는 뜻이고, 일단 start에 맞는 값이 있는지 없는지 체크해야 되기 때문에 end--를 한다. end--; } else { // sum &lt; 0이 되어버리면 이전 start에 맞는 end값이 존재하지 않는다는 뜻이다. // 따라서 start++ 해준다. start++; } }} 고유 숫자 세기 (Count Unique Nums) 시간 복잡도 O(N)1234567891011121314151617181920function countUniqueValues(arr) { // arr이 텅 빈 배열이라면 그냥 0을 반환 if (arr.length === 0) { return 0; } let first = 0; let second = first + 1; while (second &lt; arr.length) { // 두 값이 같으면 두번째 포인터를 한 칸 우측으로 이동 if (arr[first] === arr[second]) { second++; } else { // 두 값이 같지 않으면 ? =&gt; 두 포인터를 모두 한 칸 우측으로 옮기고, 두 번째 포인터가 가리켰던 값을 first의 다음 자리에 원래값과 치환시킨다. second++; first++; arr[first] = arr[second - 1]; } } return first + 1;} for문 활용 ( 더 간결한 코드 )1234567891011function countUniqueValues(arr) { if (arr.length === 0) return 0; let i = 0; for (let j = 1; j &lt; arr.length; j++) { if (arr[i] !== arr[j]) { i++; arr[i] = arr[j]; } } return i + 1;} 3️⃣ 기준점 이동 배열 패턴 ( Sliding Window ) 평소에 자주 접했던, 배열을 한 묶음씩 묶어서 체크하는 반복문을 활용한 알고리즘 패턴이다. 🤔 배열 내에서 N개로 묶은 묶음의 합 중 가장 큰 값을 구하시오 시간복잡도 : O($n^2$) 1234567891011121314151617181920function maxSubarraySum(arr, num) { if (num &gt; arr.length) { return null; } let max = -Infinity; for (let i = 0; i &lt; arr.length - num + 1; i++) { sum = 0; for (let j = 0; j &lt; num; j++) { // num 묶음의 서브 배열의 총합을 구한다. sum += arr[i + j]; } if (sum &gt; max) { // 만약 그 총합의 값이 max보다 크면, 해당 값을 max에 대입하여 갱신한다. max = sum; } } return max;}maxSubarraySum([2, 6, 9, 2, 1, 8, 5, 6, 3], 3); 시간복잡도 : O(n) → Sliding Window 1234567891011121314151617181920212223function maxSubarraySum(arr, num) { let maxSum = 0; // tempSum은 일시적 합을 의미한다. let tempSum = 0; // num의 값(묶음의 단위)이 배열의 길이보다 크다면 그냥 null을 반환한다. if (arr.length &lt; num) return null; // 우선 maxSum의 초기값을 첫 묶음의 총합으로 설정한다. for (let i = 0; i &lt; num; i++) { maxSum += arr[i]; } // 일시적 합인 tempSum의 초기값도 이와 일치시켜준다. tempSum = maxSum; for (let i = num; i &lt; arr.length; i++) { // 일시적 합 = 기존값 - 기존 묶음에서의 가장 첫번째 요소의 값 + 새로운 그 다음 값 tempSum = tempSum - arr[i - num] + arr[i]; // 두 수 중에 더 큰 값이 maxSum이 된다 maxSum = Math.max(maxSum, tempSum); } return maxSum;}maxSubarraySum([2, 6, 9, 2, 1, 8, 5, 6, 3], 3); 4️⃣ 분할 점령 ( Divide and Conquer ) 퀵 정렬과 합병 정렬 등에도 사용될 만큼, 활용도가 높은 알고리즘 패턴이다.이름 그대로, 데이터를 분할해서 → 점령(활용)한다.ex) 큰 배열을 더 작은 단위로 쪼개서 다음 단계로의 이동을 더욱 효율적으로 가져간다. 이진탐색(Binary Search)에서의 활용 : O($log_n$) 1234567// arr에 11이 포함되는지 찾기let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];// arr의 중간값 도출 -&gt; 중간값보다 찾는 값이 큰지 작은지 체크// 작으면 arr = 0~중간값;// 크면 arr = 중간값~arr.length-1// 이런 과정을 계속 반복하면서 효율적으로 원하는 값을 탐색한다.","link":"/algorithm/udemy/4.%20Solution_Pattern/"},{"title":"Udemy - 포인터 기본 예제","text":"1️⃣ 빈도수 체크 (같은 빈도수 찾기) 두 개의 정수의 자릿수들이 서로 빈도수가 일치하는지 체크 ! 12345678910111213141516171819202122function sameFrequency(a, b) { // 나 같은 경우엔 두 정수들을 toString해서 문자열로 바꾼 뒤 풀이했다. let aStr = a.toString(); let bStr = b.toString(); // 당연히 두 인풋의 길이가 다르면 각 빈도수도 절대 같을 수 없다. if (aStr.length !== bStr.length) { return false; } let checker = {}; // a의 각 자리수가 몇개씩 들어있는지 오브젝트로 만든다. for (let i = 0; i &lt; aStr.length; i++) { checker[aStr[i]] ? (checker[aStr[i]] += 1) : (checker[aStr[i]] = 1); } for (let i = 0; i &lt; bStr.length; i++) { if (!checker[bStr[i]]) { return false; } else { checker[bStr[i]]--; } } return true;} 2️⃣ 빈도수 체크 (다중 포인터 사용) 주어진 입력값들 중에 중복값이 있는지 체크하는 다중포인터 함수 짜기 나의 풀이12345678910function areThereDuplicates(...input) { let list = {}; input.map((item) =&gt; (list[item] ? (list[item] += 1) : (list[item] = 1))); for (let val in list) { if (list[val] &gt; 1) { return true; } } return false;} 다중포인터 풀이법1234567891011121314function areThereDuplicates(...args) { // 아.. sort를 사용해도 되는지 몰랐다 ㅜ (시간복잡도에 어떤 영향을 줄지 몰랐음) args.sort((a, b) =&gt; a &gt; b); let start = 0; let next = 1; while (next &lt; args.length) { if (args[start] === args[next]) { return true; } start++; next++; } return false;} O$$(nlog_n)$$ 풀이방법🤔 Set()이란?⇒ Set은 하나의 객체로, 자료형에 관계 없이 유일한 값만을 저장할 수 있다. 즉, Set()오브젝트에 담기게 되면 중복된 값이 제거된다.⇒ object.has(), object.size 등을 통해 특정 값의 포함 여부와 객체의 길이를 측정할 수 있다.1234function areThereDuplicates(...args) { // 중복이 제거된 배열 -&gt; 객체화 -&gt; 사이즈가 기존 배열의 길이와 다르면 중복값이 존재한다는 뜻이다. return new Set(args).size !== args.length;} 3️⃣ 다중 포인터 ( 평균값 묶음 찾기 ) 주어진 입력 정수 리스트 중에, 주어진 평균값이 도출될 수 있는 묶음이 있는지 여부를 반환하는 함수 작성! 나의 풀이123456789101112131415161718192021222324252627282930313233343536373839404142function averagePair(arr, target) { // 배열이 빈 배열이면 무조건 false if (arr.length === 0) { return false; } // 다중 포인터에서 앞 부분의 포인터는 start, 뒤의 포인터는 end로 선언했다. let start = 0; let end = start + 1; // i는 두 포인터 사이의 간격이다. let i = 0; // 아래에서 사용될 arr[start]~arr[end]까지의 합을 구하기 위한 함수다. const sumMaker = (input) =&gt; { return input.reduce((prev, cur) =&gt; prev + cur); }; // 두 포인터의 간격은 배열의 길이 -2까지만 허용된다. // 따라서, arr.length - 1보다 작을 때 까지만 반복문이 실행되어야 한다. while (i &lt; arr.length - 1) { // 만약 end 포인터가 배열의 끝에 닿으면 간격을 늘리고 다시 처음 묶음부터 체킹해야 된다. if (end &gt; arr.length - 1) { // 간격을 늘리고 i++; // 두 포인터의 위치 또한 초기화 시킨다. start = 0; end = start + i + 1; } // 배열을 두 포인터까지로 잘라낸다. let sliced = arr.slice(start, end + 1); // 합을 구하고, 이를 통해 평균을 구한다. let sum = sumMaker(sliced); let avg = sum / sliced.length; // 만약 구한 평균값과 target값이 같으면 true를 반환한다. if (avg === target) { return true; } else { // 그게 아니라면, 두 포인터를 한칸씩 이동시킨다. start++; end++; } } // 반복문을 마쳤는데도 true가 안나왔으면 false인거다. return false;} 4️⃣ 다중 포인터 ( 부분 문자열 찾기 ) 첫 째 입력값(String)의 character들이 두 번째 입력값(String)에 모두 포함되는지 체크하는 함수를 작성단, 첫 째 입력값의 순서가 뒤바뀌어서는 안된다. 나의 솔루션 코드 ( 애 좀 먹었다… )123456789101112131415161718192021222324252627282930313233343536373839function isSubsequence(a, b) { // a 문자열의 길이가 더 길면 정답일 수가 없다. if (a.length &gt; b.length) { return false; } // 추출 결과가 담길 test 배열을 만든다. let test = []; // a,b 두 문자열을 모두 배열에 담는다. let aArr = [...a]; let bArr = [...b]; // 포인터 두 개 만들기 let i = 0; let j = 0; while (i &lt; aArr.length) { // i는 a를, j는 b를 순회하며 체크한다. // 만약 두 배열의 요소 값이 같아지는 경우가 발생하면 해당 값의 첫 번쨰 index값을 test에 담는다. if (bArr[j] === aArr[i]) { test.push(bArr.indexOf(bArr[j])); // a는 이제 다음 요소를 체크해도 되므로 i++해준다. // j는 다시 0으로 초기화 시킨다. i++; j = 0; } else { // 같지 않으면 j++ 시키며 계속 순회하도록 한다. j++; } // 하지만 j가 끝에 닿으면 0으로 초기화 시키고, i또한 다음으로 넘긴다. if (j === bArr.length) { j = 0; i++; } // 이미 요소들이 다 담겼는데 끝까지 반복문을 돌릴 필요는 없다. if (test.length === aArr.length) { break; } } // 만약 test에 담긴 각 요소들의 index값이 오름차순이 아니면 이는 false를 출력할 것이다. return test.reduce((prev, cur) =&gt; prev &lt; cur);} 반복문 풀이법 (현타… 온다…)1234567891011function isSubsequence(str1, str2) { var i = 0; var j = 0; if (!str1) return true; while (j &lt; str2.length) { if (str2[j] === str1[i]) i++; if (i === str1.length) return true; j++; } return false;} O(1) 풀이법 (하….) 재귀함수를 사용했는데, 굉장히 획기적인 풀이 방법인 것 같다. 123456function isSubsequence(str1, str2) { if (str1.length === 0) return true; if (str2.length === 0) return false; if (str2[0] === str1[0]) return isSubsequence(str1.slice(1), str2.slice(1)); return isSubsequence(str1, str2.slice(1));} 5️⃣ Sliding Window ( 최대값 찾기 ) 주어진 숫자의 묶음 중에서 최대값을 찾는 알고리즘을 작성단, 묶음은 연속된 요소로만 구성된다. 나의 솔루션 코드 : O(N)1234567891011121314151617181920function maxSubarraySum(arr, num) { if (arr.length &lt; num) { return null; } // 일시적 합을 담을 temp, 최대값을 담을 max let temp = 0; let max = 0; // 우선 0~num까지의 합을 temp와 max에 담아줌 for (let i = 0; i &lt; num; i++) { temp += arr[i]; } max = temp; // temp에서 이전 첫째값을 빼고, 그 다음 값을 더해주고 max와 비교 // 더 큰 값이 max에 담긴다. for (let i = num; i &lt; arr.length; i++) { temp = temp - arr[i - num] + arr[i]; max = Math.max(temp, max); } return max;} 6️⃣ Sliding Window ( 최소 길이 찾기 ) 각 요소의 값의 합이 num이 되는 조합 중, 가장 짧은 길이를 갖는 조합의 length를 출력하는 알고리즘 작성 나의 솔루션 코드 : O(N)12345678910111213141516171819202122function minSubArrayLen(arr, num) { let sum = 0; let start = 0; let end = 0; let minLen = Infinity; while (start &lt; arr.length) { if (sum &lt; num &amp;&amp; end &lt; arr.length) { sum += arr[end]; end++; } else if (sum &gt;= num) { minLen = start === 0 ? Math.min(minLen, end - start + 1) : Math.min(minLen, end - start); sum -= arr[start]; start++; } else { break; } } return minLen === Infinity ? 0 : minLen;} 7️⃣ Sliding Window ( 가장 긴 독립 문자열 찾기 ) 주어진 문자열에서 중복되지 않는 Character가 어디까지 이어지는지 그 길이를 출력하는 알고리즘을 작성 나의 솔루션 코드1234567891011121314151617181920212223242526272829function findLongestSubstring(input) { if (input.length === 0) { return 0; } // 초기 최대값 가장 작은 값으로 설정 let max = -Infinity; // 독립적 문자들을 담을 checker 객체를 생성 let checker = {}; let i = 0; let j = i; while (i &lt; input.length) { // j포인터가 끝에 닿았거나, 해당 글자가 checker 오브젝트에 존재한다면? if (j === input.length || checker[input[j]]) { // max값 갱신 max = Math.max(max, j - i); // checker는 다시 초기화 checker = {}; // i++ -&gt; 가장 처음값 담음 i++; checker[input[i]] = 1; // j는 i의 다음값부터 체크하면 되므로 i+1로 초기화 j = i + 1; } else { checker[input[j]] = 1; j++; } } return max;}","link":"/algorithm/udemy/5.%20Questions/"},{"title":"Udemy - 재귀","text":"백준 알고리즘을 풀 때도 가장 어렵게 느껴졌고, 잘 와닿지 않았던 알고리즘 유형이다.재귀란 말 그대로, 다시 돌아온다는 뜻이다.쉽게 말해, 함수가 사전에 정의된 엔드포인트에 도달할 때 까지 계속 재실행되며 반복되는 것이다. 🤔 재귀함수를 사용하는 이유 정말 많이 활용되는 알고리즘 패턴이다. ex) JSON.parse, JSON.stringify, getElementById 등등 트리나 그래프 형태의 복잡한 데이터 구조를 탐색하거나 순회해야 할 때 필요하다 📦 콜스택 (Call Stack) 콜스택은 LIFO(Last In, First Out) 방식을 따르며, 콜스택에 함수가 차례대로 쌓인다.가장 위에 있는 함수부터 return값이 반환되며 종료될 때마다 스택(함수)이 지워진다. 즉, 재귀함수에서는 같은 함수가 endpoint에 닿을 때 까지 콜스택에 지속적으로 쌓인다. 일반적으로 발생하는 재귀에서의 문제들 엔드포인트가 명시되지 않은 경우 ⇒ 콜 스택이 오버플로우 되며 오류를 발생시킨다. 실수로 재귀 함수의 입력값을 고정시킬 경우에도 위와 같은 문제점이 발생할 수 있다. 즉, 재귀함수를 활용할 때는 스택 오버플로우를 반드시 방지해야 한다. 헬퍼 메소드 재귀 함수 안에 또 다른 재귀함수가 존재하는 경우를 통칭한다. 12345678910111213141516171819function collectOddValues(arr) { let result = []; // 이와 같은 헬퍼 재귀함수가 내장되어 있다. function helper(helperInput) { // 앞부분이 계속 slice되다 보면 input의 길이가 0인 지점에 다다른다. if (helperInput.length === 0) { return; } if (helperInput[0] % 2 !== 0) { result.push(helperInput[0]); } // 계속 배열의 앞 부분을 잘라 나가며 함수를 재귀 호출 한다. helper(helperInput.slice(1)); } helper(arr); return result;}collectOddValues([1, 2, 3, 4, 5, 6, 7, 8, 9]); 일반 재귀 헬퍼 메소드 함수를 사용하지 않은, 순수한 단독 재귀함수다. 🍯 꿀팁 배열 사용 시 : slice와 spread operator 활용을 고려 문자열 사용 시 : slice, substr, substring 등을 활용 객체 사용 시 : Object.assign 또는 spread operator 활용 1234567891011121314151617function collectOddValues(arr) { let newArr = []; // 배열의 길이가 0에 다다르면 newArr 반환하며 함수 종료 if (arr.length === 0) { return newArr; } // 만약 배열 맨 앞의 요소가 홀수라면 ? -&gt; newArr에 push if (arr[0] % 2 !== 0) { newArr.push(arr[0]); } // 앞에서 정의된 newArr와 맨 앞이 잘린 arr을 합친다. // newArr = [...newArr, ...collectOddValues(arr.slice(1))] newArr = newArr.concat(collectOddValues(arr.slice(1))); return newArr;}collectOddValues([1, 2, 3, 4, 5]);","link":"/algorithm/udemy/6.%20Recursion/"},{"title":"Udemy - 재귀 예제","text":"1️⃣ Power 첫번째 인풋의 두번째 인풋 제곱값을 구하는 재귀함수 알고리즘을 작성 🙂 12345678function power(a, b) { // b가 1보다 작으면 1을 반환하는 endpoint를 설정 if (b &lt; 1) { return 1; } // 아래와 같은 재귀 함수가 반복되며 b가 0에 닿을 때 까지 a*(b-1)이 쌓인다. return a * power(a, b - 1);} 2️⃣ 팩토리얼 말 그대로 팩토리얼(내림차순 곱)을 구현하는 재귀함수 알고리즘을 작성하면 된다. 12345678function factorial(num) { // endpoint가 0이면 안되는 이유는, n*0 = 항상 0이 되기 때문이다. if (num &lt; 1) { return 1; } // 재귀함수 호출 return num * factorial(num - 1);} 3️⃣ 배열의 모든 수 곱하기 주어진 배열의 모든 요소들을 곱한 값을 반환하는 재귀함수 알고리즘을 작성하시오 12345678function productOfArray(arr) { // arr의 길이는 매 재귀호출마다 slice에 의해 1씩 줄어든다. // 따라서 arr의 길이가 0에 닿았을 때 곱셈에 영향을 주지 않는 1을 return한다. (그냥 return만 해도 됨) if (arr.length &lt; 1) { return 1; } return arr[0] * productOfArray(arr.slice(1));} 4️⃣ 1씩 증가하는 등차수열의 합 0~N까지의 합을 계산하여 반환하는 재귀함수 알고리즘을 작성하시오 123456789function recursiveRange(num) { // 이 문제는 합을 구하는 문제이기 때문에, 덧셈에 영향을 주지 않는 0을 return하는 것이 안전하다. if (num &lt; 1) { return 0; } // 꼭 증가하는 등차수열이라고 해서 값을 더해 나갈 필요는 없다. // N~0까지의 합을 구해도 됨 return num + recursiveRange(num - 1);} 5️⃣ 피보나치 수열의 index 찾기 입력 받은 숫자가 피보나치 수열 내에서 몇번 째의 숫자인지 반환하는 재귀함수 알고리즘을 작성하시오 123456function fib(num) { if (num &lt;= 2) { return 1; } return fib(num - 1) + fib(num - 2);}","link":"/algorithm/udemy/7.%20Recursion_Q/"},{"title":"Udemy - 재귀 심화문제","text":"허허….😅 1️⃣ reverse ( 거꾸로 출력하기 ) 입력된 String을 거꾸로 출력하는 재귀함수 알고리즘을 작성! 123456789function reverse(input) { // 1. Endpoint 조건 작성 // input의 length가 1에 닿으면 -&gt; 그 하나 남은 값을 출력하면 된다. if (input.length &lt; 2) { return input[input.length - 1]; } // 2. input의 가장 끝 값을 잘라나가면서 String에 붙여준다. return input[input.length - 1] + reverse(input.slice(0, -1));} 2️⃣ isPalindrome ( 앞뒤가 똑같은 단어 찾기 ) 주어진 String 입력값이 앞뒤로 반전을 해도 같은 단어라면 true를, 아니라면 false를 출력하는 재귀 함수 작성 1234567891011121314function isPalindrome(input) { // 1. Endpoint 작성 // 1-1. input.length가 짝수인 경우 마지막 단계에서 두 개의 char가 남는다. if (input.length === 2) { return input[0] === input[1]; // 하지만, 홀수인 경우 마지막에 하나의 char만 남으므로, 이는 뒤집어도 가운데에 위치하기에 true를 반환해주면 된다. } else if (input.length === 1) { return true; } // 2. 재귀함수 실행 (&amp;&amp;을 사용하면 하나라도 false일 시에, false가 반환됨) return ( input[0] === input[input.length - 1] &amp;&amp; isPalindrome(input.slice(1, -1)) );} 3️⃣ someRecursive ( 하나라도 만족하는가? ) 주어진 배열 입력값 중에, 주어진 조건을 하나라도 충족하면 true를, 아니면 false를 출력하는 재귀함수 알고리즘을 작성하시오 123456789101112function someRecursive(arr, callback) { // 만약 arr.length가 0이 될 때까지 true가 반환되지 않았다면, false를 반환해주면 된다. if (arr.length === 0) { return false; } // callback(arr[0])의 값이 true면 true를 반환한다. if (callback(arr[0])) { return true; } // 위 두 조건을 모두 만족시키지 못한다면 배열을 잘라나가며 재귀함수를 실행시킨다. return someRecursive(arr.slice(1), callback);} 4️⃣ flatten ( 중첩 배열 풀어내기 ) [ [ ], [ [ ] ]] 와 같은 중첩 배열들을 하나의 배열로 풀어서 반환하는 재귀함수 알고리즘을 작성하시오 나의 솔루션1234567891011// 뭐가 문제인지는 모르겠으나... 나의 솔루션은 계속 알 수 없는 오류가 난다.function flatten(arr) { // 새로운 배열을 반환해야 한다고 했으니 일단 newArr에 담아준다. let newArr = arr; // 만약 모든 요소 중 어떤 것도 배열이 아니라면? =&gt; 해당 newArr 반환 if (!newArr.some((el) =&gt; Array.isArray(el))) { return newArr; } // 위의 조건 통과하지 못하면 -&gt; newArr를 flat해서 다시 재귀 return flatten(newArr.flat());} 제시된 솔루션12345678910111213function flatten(oldArr) { let newArr = []; for (let i = 0; i &lt; oldArr.length; i++) { if (Array.isArray(oldArr[i])) { // 여기서는 concat을 사용했다. // concat 안에서 재귀가 이뤄진다. newArr = newArr.concat(flatten(oldArr[i])); } else { newArr.push(oldArr[i]); } } return newArr;} 5️⃣ capitalizeFirst ( 첫 글자 대문자로 바꾸기 ) 주어진 배열 내의 String들의 첫 글자를 대문자로 바꾸는 재귀함수 알고리즘을 작성하시오 아스키 코드 (10진수) A-Z : 65~90 a-z : 97~122 123456789101112function capitalizeFirst(arr) { // 만약 arr.length가 1에 닿으면 -&gt; 첫 글자 대문자로 치환 + 나머지 글자 합친 것 return if (arr.length === 1) { return [arr[0][0].toUpperCase() + arr[0].slice(1)]; } // 위 조건 충족하지 못하면 // 첫 글자 대문자로 치환 + 뒷 글자들 붙임, 뒤의 나머지 배열 요소들 또한 재귀를 통해 첫글자 대문자화 return [ arr[0][0].toUpperCase() + arr[0].slice(1), ...capitalizeFirst(arr.slice(1)), ];} 6️⃣ nestedEvenSum nested 오브젝트 내에 존재하는 모든 짝수 value들의 합을 구하는 재귀함수 알고리즘을 작성하시오 주어진 object 1과 2 12345678910111213141516// typeOf Object를 활용하면 될 것 같다.function nestedEvenSum(obj, sum = 0) { // for ... in 반복문을 통해 오브젝트의 key값들을 활용 for (let key in obj) { // key = 오브젝트의 key // 만약 key의 value의 타입이 object라면 재귀 대상 if (typeof obj[key] === 'object') { // 이렇게 해당 오브젝트가 함수에의해 다시 들어가면 for문에 의해 계속 벗겨질 것 sum += nestedEvenSum(obj[key]); // 만약 해당 key의 value가 숫자이고, 짝수라면? -&gt; sum에 그 값을 더해주기 } else if (typeof obj[key] === 'number' &amp;&amp; obj[key] % 2 === 0) { sum += obj[key]; } } return sum;} 7️⃣ capitalizeWords (모든 문자 대문자화) 배열에 담긴 모든 문자열들을 대문자로 치환하는 재귀함수 알고리즘을 작성하시오 123456function capitalizeWords(arr) { if (arr.length === 1) { return [arr[0].toUpperCase()]; } return [arr[0].toUpperCase(), ...capitalizeWords(arr.slice(1))];} 8️⃣ stringifyNumbers nestedObject의 values들 중에 ‘숫자’인 값들을 찾아서 모두 stringify하여 반환하는 재귀함수 알고리즘을 작성하시오 💡 Array를 typeof를 통해 검사하면 ‘object’가 반환된다는 것을 처음 알았다…. 123456789101112131415161718// 처음엔 그냥 기존 obj를 수정하는 방식으로 했는데, TDD에서 원본 오브젝트는 건들지 말란다...// 그래서 newObj={}라는 입력값을 추가했음function stringifyNumbers(obj, newObj = {}) { // obj에 대한 for문을 돌린다. for (let key in obj) { // 만약 해당 value가 오브젝트이고, 배열이 아니라면 -&gt; 재귀 대상 if (typeof obj[key] === 'object' &amp;&amp; !Array.isArray(obj[key])) { // newObj의 해당 key값의 value는 수정된 object가 된다. newObj[key] = stringifyNumbers(obj[key]); } else if (typeof obj[key] === 'number') { newObj[key] = obj[key].toString(); } else { // 여기는 value가 오브젝트도 아니고, 숫자도 아닐 경우 -&gt; 그냥 그대로 newObj에 넣음 newObj[key] = obj[key]; } } return newObj;} 9️⃣ collectStrings ( String만 모으기 ) 주어진 nestedObject 안에서 String Value값들만을 한 배열에 모아서 반환하는재귀함수 알고리즘을 작성하시오 1234567891011121314// 최종 리턴할 배열을 arr=[]와 같이 입력해줬다.function collectStrings(object, arr = []) { for (let key in object) { // object면? -&gt; 스프레드 연산하여 arr에 담아준다 // 재귀가 되며 지속적으로 object 속을 탐색한다. if (typeof object[key] === 'object') { arr.push(...collectStrings(object[key])); // value가 string인 것이 발견되면 arr에 푸시한다 } else if (typeof object[key] === 'string') { arr.push(object[key]); } } return arr;}","link":"/algorithm/udemy/8.%20Recursion_HQ/"},{"title":"Udemy - 탐색 알고리즘","text":"탐색(검색) 알고리즘이란?쉽게 설명하자면, 특정한 배열, 또는 객체 등에 존재하는 특정값을 찾아내는 알고리즘이다. 탐색 알고리즘의 종류 선형 탐색 이진 탐색 순수 탐색 KMP String 탐색 📏 선형 탐색 (Linear Search) 배열 내에 존재하는 값들을 하나씩 체크하며 검색해 나가는 방식의 탐색 알고리즘이다. Array.indexOf() 시간복잡도는 O(N)으로, 반복문 안에서 사용에 주의해야 한다. 해당 값이 존재하면 해당 값의 가장 선두에 있는 index값을 반환해준다. 해당 값이 존재하지 않으면 -1을 반환한다. Array.includes() 시간복잡도 : O(N) 특정 값이 존재하면 true를, 존재하지 않으면 False를 반환 Set.has() 시간복잡도 : O(1) Array.includes()와 비슷하지만, 이는 배열이 아닌 set에서 사용하는 함수다. const OOO = new Set() 을 통해 Set을 생성할 수 있고, set에는 중복값을 담을 수 없다. 기본 예제 주어진 숫자의 index값을 찾는 탐색 알고리즘을 작성하시오 : O(N) 12345678function linearSearch(arr, target) { for (let i = 0; i &lt; arr.length; i++) { if (arr[i] === target) { return i; } } return -1;} 선형 탐색의 BIG O O(1) : 베스트 👍 O(N) : 평균 or 워스트 👎⇒ 배열의 길이가 1만개라면, 1만번의 탐색을 수행해야 함, 하지만 일반적인 경우에는 그리 최악은 아님 📖 이진 탐색 (Binary Search) 선형 탐색보다 훨~~씬 빠른 탐색 알고리즘이다.이전에 잠깐 맛만 봤던 “분할 점령 패턴”의 실질적인 활용 예라고 보면 된다. ⚠️ 배열이 정렬되어 있는 경우에만 사용 가능하다.. 기본 로직 배열을 절반으로 쪼갠다⇒ 진짜 배열을 slice하는건 아니고, 이중 포인터를 사용한다 중간값을 기준으로 좌측을 잘라낼지, 우측을 잘라낼지 결정하도록 한다. 기본 예제 코드 이진 탐색 방식으로 주어진 숫자의 index값을 반환하는 알고리즘을 작성하시오. 12345678910111213function binarySearch(arr, target) { // left와 right 포인터를 선언 let left = 0; let right = arr.length - 1; // 초기 값에 대한 중간값(middle) 선언 let middle = Math.floor((left + right) / 2); // 중간값이 target과 같아지거나, left가 right보다 커지면 반복문 종료 while (arr[middle] !== target &amp;&amp; left &lt;= right) { target &lt; arr[middle] ? (right = middle - 1) : (left = middle + 1); middle = Math.floor((left + right) / 2); } return arr[middle] === target ? middle : -1;} 이진 탐색의 BIG O O(1) : 베스트 👍 O(logn) : 기본 ☺️ 🍼 순수 탐색 (Naive String Search) 어떤 String에 특정한 subString이 포함되는지 탐색하는 알고리즘ex) “my name is hoonjoo”에 “hoon”이 포함되는가? 💡 원래는 String.includes() 를 사용하면 되지만, 순수 탐색 방법을 활용하면 첫 글자를 비교 → 같으면 두 번쨰 글자를 비교 / 다르면 비교대상의 첫 글자 인덱스를 우측으로 이동 기본 예제 코드 주어진 target String이 기준 String에서 몇 번 나타나는지 반환하는 순수 탐색 알고리즘 코드를 작성하시오. 12345678910function naiveSearch(base, target){ let count = 0; for(let i = 0; i &lt; base.length; i++){ for(let j = 0; j &lt; target.length; j++){ target[j] !== base[i+j] &amp;&amp; break; j === target.length - 1 &amp;&amp; count++; } } return count;}","link":"/algorithm/udemy/9.%20Search/"},{"title":"DNS란 무엇인가?","text":"DNS란? Domain Name Server로, 도메인에 대응하는 IP주소를 반환해주는 하나의 서버다. 우리가 흔히 사용하는 www.naver.com에서 “naver”가 도메인에 해당한다. 이러한 도메인 주소를 호스트명과 합친 것을 FQDN이라 하는데, 이 FQDN(이하 도메인)을 DNS 서버에 질의하면, DNS서버가 해당 도메인에 대응하는 IP주소를 반환해주는 것이다. 이렇게 DNS로부터 응답 받은 IP주소를 통해 우리는 서버에 요청을 송신할 수 있다. 도메인? 호스트? 근데 도메인과 호스트의 차이점은 뭘까? 도메인 : 특정 네트워크에 접근하기 위한 주소이자 이름이다. 호스트 : 네트워크 내에서 특정 장치(디바이스)에 접근하기 위해 필요한 이름이다. 우리는 도메인명을 통해 특정 네트워크 그룹에 찾아갈 수 있고, 네트워크 내에서 호스트명을 통해 종착점의 주소로 접근할 수 있는 것이다. 이를 위의 사진에 비유해 설명하자면, 우리는 우편물(서버 요청)을 보낼 때 상대방의 주소를 정확하게 적어서 보낸다. 그리고 해당 주소에 대응하는 우체국(도메인명)으로 나의 우편물이 들어가고, 우체국에서 내가 작성한 최종 도착지 주소(호스트명)로 우편물을 전달해준다. 이러한 일련의 과정들이 네트워크 내에서도 비슷하게 일어나고 있는 것이다! (참고로 comic.naver.com에서의 comic 또한 도메인명이다) DNS는 어떻게 동작할까? 뭐 이제 도메인과 IP의 관계, 그리고 의미에 대해서는 이해한 것 같다.그럼 우리가 브라우저 상단에 도메인을 입력한 뒤, 엔터를 눌렀을 때 도메인이 어떻게 IP로 변환되는 것일까? 우선, 아주 개괄적인 DNS로의 질의 방식 + 호스팅 서버로의 데이터 요청 과정은 이하와 같다. 굉장히…. B급 감성이지만.. 그래도 전체적인 프로세스는 위와 같다고 할 수 있다. 브라우저에서 도메인을 DNS로 보내고, DNS에서 해당 도메인에 알맞는 IP주소를 반환해준다. 그리고 그 응답 받은 IP주소로 요청을 보내는 것이다! 물론.. 이건 굉장히 축약된 프로세스이고, 그 안에서 DNS가 도메인 네임을 IP주소로 반환 해주는 과정은 좀 더 복잡하다. DNS 서버는 하나가 아니다! DNS 서버가 하나라면 위의 간단한 방식으로 모든 IP주소 반환이 이루어질 수 있겠지만 현실은 그렇지 않다… 당연히 다양한 DNS 서버가 존재하고, 이러한 DNS 간의 유기적 연결과 질의를 통해 우리는 최종적으로 IP주소를 알아낼 수 있는 것이다. 아래 표와 그림을 통해 각 DNS 서버의 종류와 전체적인 흐름을 익혀보도록 하자. 이름 설명 로컬 DNS 가장 먼저 질의를 하는 DNS 서버다. 주로 통신사 또는 브라우저, 퍼블릭 서버가 있다. 루트 DNS (Root) 국제인터넷주소관리기구(ICANN)에서 관리하는 국제적 서버다. 루트 DNS에서 TLD DNS 서버 IP를 반환해준다. TLD DNS (Top-Level-Domain) 책임 DNS 서버의 주소를 저장 해두고 질의가 오면 연결해준다. Authoritative DNS (책임 DNS) 실제 IP주소들이 저장되어 있는 서버다. 우리가 자주 사용하는 가비아가 이 책임 DNS에 속한다고 볼 수 있다. 자.. 이제 그럼 위의 그림과 표를 통해 하나 하나 짚고 넘어가보자. 우선, 브라우저는 로컬 DNS에 질의를 보낸다. 캐시에 해당 도메인에 대응되는 IP주소가 저장돼있으면 바로 응답을 보내준다 (Yes) 캐시에 대응되는 IP가 없으면 Root DNS로 질의를 연결해 보내준다. (NO) Root DNS가 도메인에 붙은 탑레벨 도메인(.com, .net, .kr 등)을 통해 그에 대응하는 TLD DNS 서버 IP주소를 알려준다. TLD DNS에서 해당 도메인 (naver.com)에 해당하는 책임 DNS 서버의 주소를 알려준다. 최종적으로 책임 DNS에서 도메인에 대응되는 IP주소를 받아낸다. 이렇게 응답 받은 IP를 통해 브라우저는 호스팅 서버에 요청을 정확히 보내는 것이다. 여기서 가장 핵심적인 것은 로컬 DNS에서 효율성을 위해 이전에 응답 받았던 도메인의 IP를 일정기간 저장해둔다는 것이다. 이를 통해 우리는 굳이 예전에 방문한적 있던 도메인의 IP주소에 대해서는 루트 → TLD → 책임DNS로의 여정을 반복하지 않아도 되는 효율성을 실현할 수 있다. (로컬 DNS는 책임 DNS로부터 받은 응답을 캐싱한다는 것이 골자…!!) 즉, 크게 나눴을 때 DNS 프로세스는 두 개로 나뉠 수 있다. 로컬 DNS에 해당 도메인이 캐싱되어 있으면 바로 응답 받음 로컬 DNS에 캐싱된 게 없으면 Root → TLD → 책임DNS로의 여정을 떠남 여기까지가 DNS로부터 IP주소를 반환 받는 과정의 거의 전부라고 할 수 있다..! 정리 및 요약DNS란 호스트와 도메인의 조합인 FQDN을 브라우저로부터 전달 받아, 해당 도메인에 대응하는 IP주소를 반환해주는 서버다. 이러한 DNS에는 여러 종류가 존재한다. 우선, 로컬 DNS는 통신사 또는 브라우저 등에서 관리하는 서버로 우리의 요청이 가장 먼저 전달되는 서버다. 이 로컬 DNS는 IP주소들을 캐싱해두는데, 도메인에 대응되는 캐싱된 IP가 없다면 루트 DNS로 재질의를 한다. 루트 DNS는 .com과 같은 탑레벨 도메인을 관장하는 TLD DNS로의 연결을 담당해주고, TLD DNS는 해당 도메인에 해당하는 최종 책임 DNS로의 연결을 담당한다. 그렇게 최종적으로 책임 DNS가 질의 받은 도메인에 대응하는 IP 주소를 반환해주는 것이다. 그리고 그렇게 반환 받은 도메인과 IP 주소를 로컬 DNS는 캐싱한다. 그렇게 반환 받은 IP주소를 통해 호스팅 서버로 요청이 전달된다. 참조 자료DNS란 뭐고, 네임서버란 뭔지 개념정리 DNS(도메인네임,호스트네임 등등)","link":"/cs/network/DNS/"},{"title":"1. 네트워크의 기본","text":"네트워크란 무엇인가? 네트워크란, 한 마디로 “연결”을 의미한다.학교도 선생님과 학생들을 이어주는 네트워크, 회사도, 집도 모두 네트워크의 일환이다. 컴퓨터 네트워크 ⇒ 하지만 컴퓨터 네트워크는 “데이터를 주고 받기 위한 네트워크”를 의미한다. 카톡 메시지를 주고 받는 것, 인터넷에서 정보를 검색하거나 작성하는 것 모두 데이터의 전달 과정이 그 기반이 된다. 사설 네트워크 (인트라넷) 사설 네트워크는 사용자의 제한을 두는 제한적인 네트워크다. ⇒ 인트라넷, LAN 등이 이에 포함될 수 있다. 인터넷 누구나 접속이 가능한 네트워크다 ⇒ 해커, 옆집 강아지(?), 할아버지 할머니 등등 브라우저를 통해 누구든지 인터넷에 접속할 수 있다. LAN과 WAN LAN과 WAN은 사설 네트워크(인트라넷 등)에 사용되는 네트워크다. LAN (Local Area Network) ⇒ 가까운 범위 내의 기기들을 라우터 등을 통해 연결시키고, 기기 간의 데이터 통신 등이 가능하도록 네트워크를 구성한다. 즉, 가까운 거리에 있는 기계와 기계를 연결시킨다! WAN (Wide Area Network) ⇒ 위의 LAN을 다른 거점의 LAN과 연결시킬 수 있도록 연결해주는 역할을 한다.즉, LAN과 LAN의 연결을 돕는 징검다리라고 생각하면 편하다. 인터넷 그렇다면 근거리 기기간의 통신이 아닌, 각기 떨어져 있는 세상의 모든 사람들과 통신할 수 있는 방법은 뭘까? → 바로 인터넷이다. AS와 ISP AS : 자율 시스템(Autonomous System)⇒ 전세계의 다양한 조직들이 운영하는 네트워크조직 등을 구성하는 네트워크 생태계 ISP : Internet Service Provider⇒ 쉽게 설명하자면, 네트워크 서비스를 제공해주는 기업을 의미한다. 1티어 ISP로는 SKT, KT, LG U+ 등이 있다. 하위 티어의 영세 ISP도 많은데, 이들의 통신은 어쩔 수 없이 1티어 ISP를 경유할 수밖에 없다즉, 우리는 인터넷을 이용하고자 한다면… 1티어 ISP를 반드시 사용하게 된다. 서버와 클라이언트, 그리고 애플리케이션 인터넷을 통해 데이터를 주고받는다는 것은 알겠다.그렇다면 그 데이터가 도대체 어떻게 저장되고 어디에 저장되는 것인가? 서버와 클라이언트 클라이언트 서버 일반적인 우리들의 컴퓨터 굉장히 좋은 컴퓨터 주로 서버에 데이터를 “요청(Reuest)” 클라이언트로 부터 요청을 처리 (Response) ⇒ 클라이언트(우리)는 서버에 어떠한 특정 요청을 보내고 → 서버는 이러한 요청을 처리한 뒤 응답(Response)를 보내준다. 고객이 레스토랑에서 웨이터에게 주문을 하는 것과 같다고 보면 된다. 이러한 이유 때문에 서버의 컴퓨터 성능은 고성능이 요구된다. 애플리케이션 서버에서 데이터를 받아 처리하는 역할을 하는 것이 애플리케이션이다.클라이언트 사이드에서 반환된 데이터를 받아내는 것 또한 클라이언트의 애플리케이션이다. 네트워크 아키텍처와 프로토콜 그럼 어떤 방식으로 데이터를 주고 받을까?⇒ 네트워크를 통한 올바른 데이터 송수신을 위해선 규칙과 규약 등이 필요하다. 프로토콜 ⇒ 우리가 한국어를 사용할 때 막 사용하는 것이 아니듯이, 네트워크 또한 통신을 할 때 자기가 원하는 대로 규칙없이 대화를 하지는 않는다. 한국어에도 문법, 훈민정음, 발음, 상황에 따른 용법 등 다양한 규칙과 기준이 존재하듯, 네트워크 통신에도 이러한 다양한 규칙(프로토콜)들이 존재한다. 즉, 프로토콜은 네트워크 통신을 위한 규약이자 규칙들의 단편들이다. 네트워크 아키텍처 ⇒ 위의 프로토콜들이 종합된 것이 네트워크 아키텍처다.한국어, 영어와 같이 하나의 언어라고 생각하면 된다. TCP/IP 전세계적으로 영어가 공용어로 통하듯이, 대부분 통용되는 네트워크 아키텍처의 표준은 TCP/IP다. 이러한 네트워크 아키텍처를 효율적으로 운용하기 위해 아키텍처는 프로토콜들을 단순히 집약해놓은 것이 아니라, 계층화 하여 기능별로 구분해 둔다. TCP/IP의 계층 애플리케이션 계층 트랜스포트 계층 인터넷층 네트워크 인터페이스층 클라우드 네트워크 전통적인 방식은 회사 등이 자체적으로 서버를 구축하여 운용하고 관리하는 것이었다.하지만 시대가 변함에 따라, 인터넷만 통해서 가상의 (물리적으로 떨어져있는) 서버를 구축할 수 있게 되었고, 우리는 이를 클라우드 서비스라고 부른다. 클라우드 서비스의 종류 Iaas : 하드웨어만 사용 가능 Paas : 하드웨어와 OS, Middleware등의 시스템 플랫폼을 활용 가능하다. Saas : 하드웨어와 플랫폼 뿐만 아니라, 애플리케이션 기능까지 모두 사용 가능하다⇒ 대표적인 예로 AWS를 들 수 있다.","link":"/cs/network/Network_Basic/"},{"title":"2. 네트워크의 구성","text":"네트워크를 구성하는 기기 네트워크 연결을 위해서는 기기와 기기 간의 연결이 필요하다.이러한 연결을 돕는 데에 가장 주요한 세 개의 기기가 존재한다. 라우터 레이어2 스위치 레이어3 스위치 데이터 전송처리 절차 네트워크 기기는 물리적 신호를 전달 받아 디지털 신호(0,1)로 변환하여 다른 기기로 다시 전송해준다. 데이터 수신 ⇒ 물리적 신호로 변환된 데이터를 받아서 디지털 신호로 변환한다. 데이터를 보낼 곳 결정 ⇒ 데이터에는 부가적인 제어 정보도 함께 담겨서 온다. 이를 활용해 네트워크 기기는 데이터 전송 대상을 설정한다. 데이터 전송 ⇒ 다시 디지털 신호(0,1)을 물리적 신호로 변환하여 송신 대상에게 데이터를 전송한다. 네트워크의 구체적 구성 네트워크 연결을 위해 우리는 일반적으로 인터페이스(포트)를 통해 각 기기를 연결한다. 이더넷 포트 ? LAN 포트? ⇒ 모두 이더넷 인터페이스를 통칭하는 말이다. 이더넷 인터페이스란, 현재 가장 널리 통용되는 인터페이스다. 💡 우리는 이 인터페이스를 통해 물리적 신호와 디지털 신호 등이 전송될 수 있도록 현관문의 역할을 해준다. LAN을 구축하는 방법 LAN은 근거리 네트워크를 의미한다.그렇다면 기기와 기기를 연결해서 어떻게 인터넷 네트워크를 구현한다는 것일까? LAN에도 당연히 라우터, 레이어2 스위치와 같은 네트워크 기기가 필요하다. ⇒ 그리고 PC 또는 노트북에 네트워크 연결을 위한 인터페이스가 존재해야 한다. 사용자 PC의 인터페이스(포트)에 LAN선을 연결하고, 이 선을 또 네트워크 기기의 인터페이스에 연결해준다. 그러면 이제 네트워크 기기를 통해 데이터를 주고 받을 수 있다.","link":"/cs/network/Network_Composition/"},{"title":"3. TCP&#x2F;IP","text":"TCP/IP란? 네트워크 아키텍처란, 하나의 언어이자 약속의 집합이다. 이러한 언어 중에서도 통용되는 언어가 있는데 그게 바로 TCP/IP다. TCP/IP의 계층구조 (OSI 4계층) 네트워크 아키텍처는 프로토콜들(규약)의 집합이다. 효율적 통신을 위해 이러한 프로토콜들을 계층화 하는데, 가장 널리 쓰이는 계층화 구조는 4계층 구조이다. (물론 OSI 7계층도 존재한다) 네트워크 인터페이스층 ⇒ 같은 네트워크 안에서의 데이터를 전송하는 역할 인터넷층 ⇒ 서로 다른 네트워크 간에 데이터를 전송하는 역할 (중개자) 트랜스포트층 ⇒ TCP or UDP를 통한 데이터의 배분 (to 특정한 복수의 애플리케이션) 애플리케이션층 ⇒ 애플리케이션의 기능을 실행하기 위해, 그에 맞는 데이터의 형식과 처리 방법 등을 결정하는 역할(HTTP, SMTP, POP3, DHCP, DNS 등의 프로토콜이 존재) 데이터의 송수신 규칙 (feat. 헤더) 위에서 설명했듯이, 프로토콜들은 계층화 되어 있다.따라서 애플리케이션이 정상적으로 데이터를 주고받기 위해선 이러한 프로토콜들을 조합해야 한다. 캡슐화와 역캡슐화 헤더에는 데이터의 출발지 주소, 그리고 목적지 주소가 담긴다. 그리고 이러한 헤더는 다음 프로토콜에 송신되어, 또 다시 새로운 헤더로 포장된다. 즉, 계층별 출발지와 목적지 정보가 차근차근 입력되며 쌓이는 것이다. 클라이언트(브라우저)에서 서버로 데이터를 전송하는 과정 위의 그림과 같이 브라우저~이더넷을 거치며 각 헤더들이 캡슐화되어 쌓인다.그리고 마지막으로 이더넷에서 물리적 신호로 변환하여 전송 매체로 데이터를 보낸다. 데이터를 수신하는 입장인 서버는 이러한 헤더를 받아 이더넷에서 쌓인 FCS와 이더넷 헤더를 읽고 자신한테 전달된 데이터가 맞는지 확인한다. 이후 역순으로 IP - TCP - HTTP 헤더들을 차례대로 벗겨내며 읽어나간다. 데이터별 명칭 HTTP(애플리케이션층) : HTTP메시지 TCP(트랜스포트층) : TCP 세그먼트 IP(인터넷층) : IP 패킷 이더넷(네트워크 인터페이스층) : 이더넷 프레임 IP (Internet Protocol) IP의 역할은 ‘엔드투엔드 통신’을 하는 것이다.즉, 특정 PC에서 다른 PC로 데이터를 전송하는 것이다. 보내고자 하는 데이터를 IP 패킷으로 포장한다. IP헤더에는 출발지 IP주소와 목적지 IP주소가 담긴다. 이를 참조하여 데이터는 다른 목적지 IP를 가진 컴퓨터로 전송되는 것이다. 하지만 만약 해당 목적지 주소가 다른 네트워크에 존재한다면, 라우터를 통해 다른 네트워크로 데이터가 전송된다. 이를 라우팅이라 한다. IP는 어떻게 구성될까 도트형으로 10진 표기된다. (ex. 192.168.0.1) 위에서는 컴퓨터(호스트) 자체의 주소를 IP라고 설명했다. 하지만 사실 IP는 호스트의 인터페이스를 식별하는 것이다. 따라서, 한 호스트가 여러 인터페이스를 보유하고 있을 경우 (유선 인터페이스, 무선LAN 인터페이스 등등) 인터페이스마다 IP주소를 설정할 수 있다. IP의 목적지 유니캐스트, 브로드캐스트, 멀티캐스트 유니캐스트 : 단 하나의 주소로 데이터를 전송 할 때(가장 일반적) 브로드캐스트 : 같은 네트워크 안에 있는 모든 호스트에게 똑같은 데이터를 전송할 때 멀티캐스트 : 특정 그룹을 지정하여 똑같은 데이터를 전송할 때 IP주소의 구성 IP주소는 네트워크부 + 호스트부로 구성된다. (고정되지 않고 가변적임) 네트워크부는 말 그대로 네트워크 자체를 식별한다 (이 네트워크로 보내줘!)⇒ 서브넷 마스크를 통해 IP주소 안에서 어디까지가 네트워크부인지 식별할 수 있다. 호스트부는 네트워크 안에서의 호스트를 식별한다. (이 호스트에게 보내줘!) 네트워크 접속 네트워크 접속에는 두 단계가 존재한다.물리적 접속 → 논리적 접속 물리적 접속 네트워크 인터페이스 층에서 이루어지며, 말 그대로 물리적인 신호를 주고받을 수 있도록 하는 것이다. 예를 들어 LAN선을 기기에 연결시키거나, 와이파이 연결을 위해 무선LAN 엑세스 포인트에 접속하는 것이다. 논리적 접속 위에서 설명했던 것 처럼, 네트워크 연결을 위해서는 인터페이스에 IP주소가 반드시 필요하다. 이러한 IP를 설정하는 것이 논리적 접속의 단계다. 물론 IP주소를 직접 설정하는 것은 전문가가 아니라면 어렵기 때문에 DHCP라는 기술을 통해 자동으로 IP주소를 설정할 수 있다. IP의 역할과 활동 공인 IP주소 : 인터넷에서 사용!사설 IP주소 : 특정 네트워크 안에서만 사용! (다른 네트워크에서의 사설 IP와 중복 가능) 그럼 사설 IP주소로 인터넷에 접속하면 어떻게 될까? 우선.. 전송 자체는 상관 없는데… 결국 IP패킷이 폐기되어 아무 것도 전달되지 않는다.따라서 NAT을 통해 사설 IP를 공인 IP로 변환하여 인터넷과 통신해야 한다. 근데 그러면… IP에 담긴 데이터가 잘 전달 됐는지 어떻게 확인할까? **ICMP(Internet Control Message Protocol)**를 사용하면 된다. ICMP의 주요기능 에러 리포트 : 우선, ICMP를 통해 IP패킷이 폐기되면 도달불능 메시지가 메아리 처럼 다시 출발지로 전달된다.진단기능(Ping) : ping커맨드를 통해 지정한 IP주소와 통신할 수 있는지 확인할 수 있다. MAC주소로의 변환 : ARP 위에서는 IP를 통해 네트워크 간 데이터를 전송한다고 했었다.근데… 갑자기 MAC주소로 데이터가 전송된다고 하니 참 헷갈린다… IP주소는 결국 MAC주소를 포함한다고 볼 수 있다. IP주소가 MAC주소 (컴퓨터의 물리적 주소)로 변환되어 해당 목적지까지 전달될 수 있는 것이다. 따라서 IP통신 내부에 MAC주소 통신이 포함되어 있는 것이고, 쉽게 말하면 IP통신은 MAC통신의 연속적 과정의 합이라고 볼 수 있다. IP주소가 MAC주소로 변환되는 것 : ARP ARP는 쉽게 말하면 번역가다.ARP를 통해 우리는 목적지 IP에 대응하는 목적지 MAC주소를 얻어내고(주소 해석), 이를 ARP 캐시에 저장한다. 알맞은 목적지 기기에 데이터가 도달했다면 ? 포트번호(PORT)를 통해 애플리케이션을 식별하고 → 알맞은 애플리케이션으로 데이터를 전송한다.포트번호는 TCP 또는 UDP 헤더에 저장된다. TCP와 UDP TCP : 신뢰성이 보장된 애플리케이션 간의 데이터 송수신을 위한 프로토콜(수신확인 가능)UDP : 서버에 도착한 데이터를 애플리케이션에 “배분”만 해주는 프로토콜 TCP의 작동 프로세스 -우선, 애플리케이션 간에 신뢰성 보장을 위해 TCP커넥션을 맺는다. -그리고 데이터를 서로 주고받은 뒤 (TCP헤더와 애플리케이션 데이터 헤더가 추가됨) ACK(수신확인)를 한다. (시퀀스번호를 통해 전송하는 데이터의 순서를 담기도 한다) -마지막으로 TCP커넥션을 끊는다. UDP UDP는 위에서도 설명했듯이, 데이터의 배분만을 담당한다. 따라서 데이터가 올바르게 도착했는지에 대한 확인이나, 데이터의 분할 등의 기능은 하지 못한다. 주로 IP음성통화 등에 활용되고. 여분처리 과정이 없기 때문에 데이터 전송 효율이 상대적으로 좋다는 장점도 있다. DNS 근데 생각해보니 IP도 알겠고, MAC도 알겠는데….우리는 어떻게 상대방의 IP를 알아서 이를 MAC주소로 변환시키고 네트워크 통신을 하는걸까? 사실 우리는 호스트명만 알고 있을 뿐, IP주소는 DNS에 담겨있다. 우리가 www.naver.com(호스트명)을 입력하면 자동으로 네트워크의 전화번호부라고 할 수 있는 DNS서버에 IP주소 질의를 한다 (DNS 리졸버). 그러면 DNS에서 해당 호스트명에 대응하는 IP주소를 반환해준다(이름해석). 그러면 이를 통해 우리는 해당 IP주소를 통해 네트워크 통신을 하는 것이다. 그렇다면 나의 IP주소는 어떻게 설정되는걸까…? 위에서 잠깐 언급했던 DHCP를 통해 자동으로 우리의 IP가 설정된다. 우선 우리의 컴퓨터는 대개 DHCP클라이언트로 설정되어 있다. 이 설정이 되어있다면 DHCP클라이언트(내 컴퓨터)는 DHCP서버에 사용할 수 있는 TCP/IP 설정정보를 질의하고, 응답을 받은 뒤 해당 IP주소를 점유한다. 이렇게 우리의 IP주소는 자동으로 설정되는 것이다.","link":"/cs/network/TCP:IP/"},{"title":"4. 웹사이트의 동작원리","text":"그동안 아무 의심이나 궁금증 조차도 없이, 인터넷과 웹 브라우저를 사용해왔던 것 같다.우리의 일상이 된 웹 브라우저는 어떻게 동작할까? 웹사이트는 문서다 처음에는 잘 와닿지 않았다. HTML, CSS, Javascript를 코딩하는 것 모두 브라우저가 읽을 수 있는 문서를 작성하는 것이다. 뭔가 굉장히 공학적이고 트렌디하다고 생각했던 프론트엔드 단에서의 코딩도 결국 문서 작성이었다니… 뭔가 기분이 새로웠다. 이러한 문서는 HTTP 통신을 통해 송수신된다. 웹브라우저 (클라이언트)는 웹서버에 데이터(HTML) 요청을 보낸다. → 그리고 웹서버는 그에 맞는 데이터를 반환해준다 → 그리고 우리는 전달받은 HTML 파일을 웹브라우저 상에 띄운다. 결국 이게 핵심이다. 우리는 HTTP(Hyper Text Transfer Protocol) 통신을 통해 데이터를 주고받는 것이다. 이러한 웹사이트 HTTP통신에서의 프로토콜은 아래와 같다. 웹사이트 접속에서의 프로토콜 HTTP TCP IP 이더넷 등 URL ? URI? &lt;스킴&gt;:// &lt;호스트명&gt;/&lt;경로명&gt;http://hoonjoo-park.github.io/about Uniform Resource Locator vs Uniform Resource Indentifier의 약자들이다. 하지만 URI가 정식 명칭이지만, 모두 같이 통용되어 불려지고 있다. 위의 예에서 스킴은, 웹브라우저가 웹서버의 데이터에 접속하기 위한 하나의 프로토콜이다. 대표적으로 http, https, ftp 등이 있다. 그리고 호스트명은 IP주소가 DNS서버에 의해 호스트명으로 변환된 것으로, 실제로는 IP주소를 의미한다. 마지막으로 경로명은, 쉽게 말해 파일의 위치를 나타내는 경로다. /about이면 about에 대한 HTML파일이 그 경로에 존재하는 것이다. HTTP Request 우리가 가장 자주 사용하는 Request요청에는 GET과 POST 등이 있다.이러한 리퀘스트는 리퀘스트 라인, 메시지 헤더, 엔티티 바디 세 가지로 분류될 수 있다. 리퀘스트 라인 HTTP 리퀘스트의 첫 째 라인으로, method, URI, 버전 등에 대한 정보가 담긴다. 메시지 헤더 웹브라우저의 종류와 버전, 그리고 대응하는 데이터 형식 등이 기술되어 있다. 엔티티 바디 POST method를 사용할 때 사용된다. ✋ HTTP통신 전에 웹브라우저와 웹서버는 서로 TCP 커넥션을 맺는다. 그리고 HTTP통신을 통해 데이터를 주고 받는 것이다. ✋ HTTP Response Request와 비슷하게 Response 또한 리스폰스 라인, 메시지 헤더, 엔티티 바디로 구성된다. 리스폰스 라인 버전, 상태코드, 설명문으로 구성되어 있다. 상태코드는 우리가 흔히 아는 1xx, 2xx, 3xx, 4xx등으로 이루어져 있고 각 코드마다 특정한 의미가 존재한다. (1xx : 추가 정보가 있음, 2xx: 서버가 요청을 성공적으로 처리했음 등등) 메시지 헤더 간단하게 데이터 형식이나 갱신 날짜 등이 기술된다. 엔티티 바디 웹브라우저에 돌려보낼 데이터가 담긴다. (주로 HTML파일) ✋ HTTP통신에는 Request와 Response만 달랑 존재하는게 아니다. DNS를 통해서 이름해석도 해야되고, ARP를 통해 MAC주소를 반환받기도 해야하는데, 이는 웹브라우저가 알아서 해준다! ✋ 쿠키 쿠키는 하나의 저장 데이터라고 생각하면 된다.웹서버 애플리케이션이 웹브라우저에 쿠키를 보내고, 웹 브라우저가 이를 허용하면 이후의 request에는 쿠키가 담겨져서 전송된다. 쿠키를 통해 세션 정보를 주고 받으며 웹페이지 내에서의 인증정보를 관리하고 활용할 수도 있고, 웹서버가 사용자의 로그인 정보나 웹페이지 열람 이력 등을 관리하며 이를 활용할 수도 있다. (지난 번에 검색했던 상품 기반으로 관련된 상품을 추천해준다던지..?)","link":"/cs/network/Website/"},{"title":"CORS 제대로 짚고 넘어가기","text":"CORS란? Cross-Origin Resource Sharing의 준말로, “교차된 출처에서 리소스가 공유 중”이라는 뜻이다. 조금 더 쉽게 풀어서 설명하면, “서로 다른 출처(Origin)에서 리소스(데이터)를 공유 중이다”를 의미한다고 볼 수 있다. 우리가 개발을 할 때, API 데이터를 받아오는 과정에서 가끔(?) 이러한 빨간 에러메시지가 뜨는 경우가 있는데, 이는 우리가 API 데이터를 불러오는 과정에서 CORS 정책을 위반했기 때문이다. 즉, 서로 다른 출처에서 리소스를 공유하는 오류를 범했다는 것이다. 뭐… 일단은 그렇다 치고…. 도대체 서로 다른 출처란 무슨 의미일까? 출처(Origin) 출처란, 리소스 및 어플리케이션 통신을 하는 주체의 주소다. 우리는 주로 브라우저를 통해 특정 사이트(url)에서 어떠한 서버에 데이터 요청을 보내고, 해당 서버로부터 데이터를 전달 받는다. 이 때에는 요청을 ‘보내는’ 클라이언트의 주소와, 요청을 ‘받는’ 서버의 주소가 필요한데, 이러한 주소들을 우리는 넓은 의미에서의 출처라고 부를 수 있을 것이다. 조금 더 직관적인 예를 들자면, 내가 누군가에게 전화를 걸 때에는 반드시 “나의 전화번호”와 “상대방의 전화번호”가 필요한 것과 같다. 만약 본인의 현재 출처가 궁금하다면, 아래와 같이 콘솔창에 location.origin을 입력하면 내 현재의 origin(출처)를 쉽게 알아낼 수 있다. 하지만, 정확하게 짚고 넘어가자면, CORS에서 출처란 프로토콜 + 호스트 + 포트 까지를 의미한다. 위의 사진에서 볼 수 있듯이, 프로토콜(스킴) + 호스트(도메인) + 포트 까지가 하나의 출처다. 포트는 주로 생략되는 경우가 많은데, 프로토콜에 기본적인 포트 번호가 고정되어 있기 때문이라고 한다. 즉, 프로토콜에 포트번호가 담겨있는 것이다. 다시 본론으로 돌아와서, 이제 C-O-R-S에서 “O”는 뭔지 알겠다. 근데… 솔직히 여전히 감이 잡히질 않는다. “왜 서로 다른 출처(Origin)에서는 리소스를 공유하면 안되는 것일까?” 이에 대해 짚고 넘어가려면 SOP에 대한 학습이 선제되어야 한다. SOP란? Same-Origin Policy, 동일 출처 정책이다. 즉, 동일한 출처에서만 리소스가 공유될 수 있다는 정책인 것이다. 이는 2011년 RFC 6454에서 처음 등장한 보안 정책으로, 해당 문서에서는 아래와 같이 설명한다. (RFC는 국제 인터넷 표준화 기구(IETF)에서 관리하는 문서다) RFC 6454,[3.5 Conclusion] 1234567The same-origin policy uses URIs to designate trust relationships.URIs are grouped together into origins, which represent protection domains.Some resources in an origin (e.g., active content) are granted the origin's full authority, whereas other resources in the origin (e.g., passive content) are not granted the origin's authority.Content that carries its origin's authority is granted access to objects and network resources within its own origin.This content is also granted limited access to objects and network resources of other origins,but **these cross-origin privileges must be designed carefully to avoid security vulnerabilities.** 요약하자면, 동일 출처를 갖는 경우 출처 간의 신뢰관계가 형성되어 리소스 접근에 대한 권한이 부여된다. 하지만 이러한 교차 출처에 대한 권한은 보안을 위해 신중하게 설계되어야 한다. 이렇듯, SOP에 의해 기본적으로 동일 출처에 한해서만 리소스가 공유될 수 있기 때문에, 다른 출처 간의 리소스 공유를 위해서는 최소한 CORS 정책을 따라야 한다. (보안 또 보안) 우리가 보통 개발을 할 때에는, localhost:3000 등에서 API 서버에 요청을 보낸다. 하지만 위의 사진처럼, 우리가 요청을 보내는 클라이언트의 출처와, 요청을 받는 서버의 출처는 다르다. 이 때문에 CORS 정책 위반 문제가 나타나며 데이터가 서버로부터 정상적으로 받아와지지 않는 것이다. 좋다. 우리는 이제 CORS에서 출처란 무엇이고, 왜 서로 다른 출처에서 리소스가 공유되면 안되는지에 대해서 다뤄보았다. 그럼 이제, CORS의 프로세스(동작 원리)에 대해 알아보도록 하자. CORS는 어떻게 작동할까? CORS 정책을 위반했는지 안했는지의 여부는 어떤 프로세스를 통해 도출되는 것일까?이에는 세 가지 시나리오가 존재한다. 1️⃣ Preflight Request 방식 Preflight Request는 예비 요청이다. (가장 보편적인 방식) 핵심만 요약하여 설명하자면, 우선 브라우저가 본 요청 전에 예비 요청을 서버에 보낸다. 그리고 이 예비요청에 OPTIONS 메소드를 사용하여 “내 Origin은 이거고~, 난 본 요청에 이런이런 정보를 담아서 보낼거야!”와 같은 개괄적 정보들을 서버에 보내준다. 그러면 서버는 해당 예비 요청을 받고, Access-Control-Allow-Origin 이라는 액세스가 허용될 수 있는 출처가 무엇인지 해당 출처 정보를 응답으로 보내준다. 그러면 브라우저는 해당 응답 헤더의 정보를 통해 “나의 출처(Origin)가 Access-Control-Allow-Origin에 포함이 되는가?”를 체크하며 CORS 정책 위반 여부를 판단한다. 진짜 조금 더 쉽게 설명하자면…!! 뭐 이런 과정이 예비 요청(preflight request)이라고 할 수 있는 것이다. 그리고 그 뒤에 브라우저가 자신의 출처(Origin)와 Access-Control-Allow-Origin의 출처들을 비교한 뒤, 자신의 출처가 이에 포함된다면 본요청을 보내는 것이다. 본 요청은 아래와 같다. 2️⃣ Simple Request 방식 simple request 방식은 예비요청 없이 본요청을 바로 날려버리는 방식이라고 보면 된다. 간단히만 설명하도록 하겠다. 본 요청을 보내버리고 → 응답 헤더에 Access-Control-Allow-Origin가 담겨져 오면 → 비교 후 CORS 정책 위반 여부를 판별한다. 그게 끝이다. 하지만 단순 요청 방식을 보내기 위해서는 아래와 같은 조건들을 모두 충족시켜야 하기 때문에 굉장히 까다롭다고 한다. [출처]CORS:Simple vs Preflight Request 123456789#1 GET/HEAD/POSTIf we manually set headers like#2 Accept, Accept Language, Content-Language, Content-Type(refer below for more conditions )If we set only the following Content Type#3 application/x-www-form-urlencoded or multipart/form-data or text/plainThe above specifies the major conditions for a simple request, For more details please refer to the CORS articles or w3c CORS specification. 3️⃣ Credential Request 방식 서로 다른 출처 간의 데이터 통신에서 조금 더 보안에 신경을 쓰고싶을 때 사용하는 방식이다. 만약 내가 요청에 쿠키 또는 인증 정보 등을 담아서 서버에 요청을 보내주고 싶을 때? ⇒ 이 credentials 옵션을 사용하면 된다! 즉, fetch()를 사용할 때, 요청 주소 뒤에 credentials 옵션을 준 뒤, 쿠키 또는 인증 정보 등을 담아서 보낼 때, CORS 검사 조건을 조금 더 강화하는 것이라고 생각하면 될 것 같다. 기본적인 Credential Rquest 방식은 이하와 같다. (쿠키 또는 인증 정보가 들어가 있으면 보안이 더 강화되어야 하는 것은 당연하다) same-origin (default) : 동일한 출처 간의 요청에만 인증 정보를 담아 보낼 수 있다. include : 모든 요청에 인증 정보를 담아 보낼 수 있다. ⇒ 이 옵션을 설정한 경우, Access-Control-Allow-Origin : * 은 불가능하다. (origin 주소 값이 직접적으로 적혀 있어야 한다) ⇒ 응답 헤더에 Access-Control-Allow-Credentials: true가 있어야 한다. omit : 어떠한 요청에도 인증 정보를 담지 않는다. 이처럼, 서로 다른 출처에서 리소스를 공유하려고 하는데, 요청 정보에 쿠키 및 인증 정보와 같은 보안성이 필요한 정보가 담겨있다면? ⇒ 이 때 브라우저는 CORS 정책 위반 여부를 조금 더 꼼꼼하고 깐깐하게 판별하는 것이다..! CORS 해결 방법 대망의 CORS 해결 방법이다. 사실… 프론트엔드 개발자가 CORS 문제를 해결하는 것은 월권이라고 본다. 위에서도 확인했듯이, 결국 서버측에서 응답 헤더에 Access-Control-Allow-Origin 을 CORS 문제가 나지 않도록 잘 담아서 보내주면 되는 일이기 때문이다. 하지만, 그럼에도 CORS에 대해 확실히 짚고 넘어가보고자 해결 방법을 정리해보려 한다. 크게 세 가지의 해결 방식이 존재한다. 서버에서 Access-Control-Allow-Origin 응답헤더 추가 Proxy Server 사용 Chrome Extension 사용 (근본적 해결책 X) Access-Control-Allow-Origin 응답헤더 추가물론 Access-Control-Allow-Origin:*을 해주면 정말 쉽게 CORS 문제를 해결할 수 있을 것이다. 이는() 모~~~든 출처에 대한 액세스를 허용하겠다는 뜻이기 때문이다. 하지만, 대충 내용만 봤을 때도 이는 굉장히 보안에 취약한 방식일 것이라고 직감할 수 있다. 따라서, 뭐 개인적인 클론코딩 프로젝트, 테스팅 사이트 등이 아니라면… Access-Control-Allow-Origin:* 와 같은 전역 허용이 아닌, 출처 주소를 직접 명시하여 설정해주는 것이 바람직할 것이다. Proxy Server 사용만약 본인이 CRA를 통해 개발을 하고 있다면, 굉장히 해결 방법이 간단하다. CRA는 기본적으로 package.json에 proxy 설정이 되어 있기 때문에, webpack-dev-server proxy 기능 활성화되어 있다. 따라서 아래와 같이 package.json에 proxy를 추가해주면 된다. 1234{ (생략...), &quot;proxy&quot;: &quot;https://API Origin&quot; // ex) https://play.google.com} 이렇게 입력을 해주면, 이제 우리는 로컬 환경에서 fetch 또는 axios를 통해 GET요청을 보낼 때, https://localhost:3000/api와 같이 요청이 보내지는 것이 아닌, proxy에서 설정한 baseUrl을 출처 삼아 요청을 보내게 된다. 위의 작성 예시를 예로 들면, fetch(’/api’)를 했을 때 → https://localhost:3000/api가 아닌 → https://play.google.com/api로 요청이 가는 것이다! 하지만 만약 CRA를 통해 개발하고 있지 않다면 webpack-dev-server를 사용해줘야 한다. 설치 1npm i webpack-dev-server -D webpack config파일 수정 12345678910111213// webpack.config.jsmodule.exports = { devServer: { proxy: { '/api': { target: 'https://원하는 baseUrl', changeOrigin: true, pathRewrite: { '^/api': '' }, }, }, },}; 이렇게 하면 위의 CRA 경우와 같이, 웹팩이 프록싱을 해주며 CORS 문제를 해결해줄 수 있다! 크롬 익스텐션 사용 뭐… 이렇게 크롬 확장프로그램 웹스토어에 가서 원하는 것을 다운받아 설치해주면 된다. 하지만 이는 근본적인 해결책이 될 수 없는게, 나의 브라우저에서만 일시적으로 CORS가 허용되는 것이기 때문이다. 결론 및 정리 출처는 프로토콜(스킴) + 도메인(호스트) + 포트다. 요청 출처와 응답 출처가 서로 다르면 SOP를 위반한 것이다. 따라서 CORS 정책을 따라야지만 다른 출처에서도 데이터 요청 및 응답을 정상적으로 받을 수 있다. CORS 작동 프로세스에는, preflight, simple, credential 세 가지의 요청 방식이 존재한다. 핵심!! ⇒ 요청 Origin과 Access-Control-Allow-Origin이 같아야 한다. 참조한 자료CORS는 왜 이렇게 우리를 힘들게 하는걸까? RFC 6454 - The Web Origin Concept CORS : Simple vs Preflight request","link":"/cs/browser/CORS/"},{"title":"콜백과 프로미스 (Callback &amp; Promise)","text":"콜백 함수 (Callback Function) 비동기 처리 방식의 문제점을 해결하기 위해, 특정 로직 수행이 완료됐을 때 원하는 동작을 실행시킬 수 있도록 하는 함수! 레스토랑 예약을 예시로 들 수 있다. 우리는 레스토랑 예약을 통해 우리가 원하는 시간대에 웨이팅 없이 식사를 편하게 즐길 수 있고, 웨이팅을 하는 대신 그 시간을 자유롭게 활용할 수 있다. 즉, 예약한 시간대**(로직 수행이 완료됐을 때)에 우리는 식당에 가서 먹기로 했던 메뉴를 시켜먹으면 되는 것이다(동작)**. 😈 콜백 지옥 우리는 가끔, 비동기 처리를 위해 콜백함수를 중첩하여 사용하는 경우를 맞이하는데…이를 콜백 지옥(Callback Hell)이라고 부른다.이렇게 콜백 함수가 꼬리에 꼬리를 무는 형식은 가독성도 떨어지고 변경 및 유지보수가 어렵다. ⇒ 이러한 콜백 지옥 문제를 해결하기 위해 필요한 것이 Promise와 Async다. 🤙 프로미스란? “A promise is an object that may produce a single value some time in the future” =&gt; 자바스크립트 비동기 처리에 사용되는 객체로, 미래에 특정한 value를 생성해낸다.“미래에 하나의 value를 생성해낼 것이라는 약속!” 콜백 함수와 프로미스의 차이점? 콜백 함수와 프로미스 모두 비동기적 처리 방식의 문제점을 해결하기 위한 함수라는 점에서는 동일하다.하지만 Promise는 이러한 콜백함수들이 한 객체로써 뭉쳐서 중첩되어있지 않고분리된 객체로써 논리적으로 상호 연결될 수 있도록 하는 하나의 절차적 함수라고 보면 된다. 프로미스의 구조 new Promise() resolve() then() 프로미스의 상태(state) Pending(대기) : 비동기처리 로직이 아직 미완료된 상태 123new Promise(function (resolve, reject) { // ...}); Fullfilled(이행) : 비동기 처리가 완료 → 프로미스가 결과값을 반환 123456789101112//resolve가 됐고, 이제 then을 활용해 처리 결과값을 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { const data = 100; resolve(data); });}// resolve()의 결과 값 data를 resolvedData로 받음getData().then(function (resolvedData) { console.log(resolvedData); // 100}); Rejected(실패) : 비동기 처리의 오류/실패 12345678910111213//이렇게 리젝트에 대한 결과값(실패 이유)을 아래의 catch()를 통해 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { reject(new Error('Request is failed')); });}// reject()의 결과 값 Error를 err에 받음getData() .then() .catch(function (err) { console.log(err); // Error: Request is failed }); Iterator &amp; Iterable *이터레이터 : 반복자이터러블 : 반복 가능한* 자바스크립트에서는 “반복 가능한(Iterable)” 요소들만 순회 또는 반복될 수 있다. ex) 배열 이터레이터는 next, done, value의 구성을 갖는다!done : 이터레이터가 아직 루프중인지 확인value : 루프중일 때 해당하는 값을 반환 이터레이터와 배열의 차이? 이터레이터는 next 메서드만 기능할 수 있기 때문에, 배열의 기능적 부분집합이라고 볼 수 있다. 하지만… 일반적으로 배열이 이터레이터보다 무겁고 배열이 이터레이터보다 메모리 효율성이 떨어진다. 이터레이터는 다음 값 호출을 받았을 때, 그 때 필요한 값만 계산하는 것이 가능하기 때문이다. (next) 제너레이터 (Generator) 이터레이터를 사용할 수 있도록 해주는 함수 == 제너레이터이터레이터 + 이터러블의 조합 == 제너레이터 기본 문법 1234567function* gen() { yield 1; yield 2; yield 3;}var g = gen(); // &quot;Generator { }&quot; 사용 예시 (무한 반복자) 1234567891011function* idMaker() { var index = 0; while (true) yield index++;}var gen = idMaker(); // &quot;Generator { }&quot;console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// ...","link":"/javascript/base/Callback_Promise/"},{"title":"브라우저의 동작 원리","text":"당연한 건 없다.필자는 그동안 아무런 궁금증도 갖지 않은채 인터넷과 브라우저를 사용해왔다. 네이버와 구글에 접속하는 것이 너무나도 당연했고, 그냥 물을 마시면 갈증이 해소되는 것과 같이, 이를 하나의 상식이자 명제처럼 당연시 해왔다. 하지만 웹 개발을 시작하며, 내가 개발한 웹사이트가 어떻게 사용자들의 브라우저에 렌더링 되어 보여지는지 궁금해지기 시작했고, 이에 대해 확실히 이해해보고 싶었다. 그렇다면 브라우저 주소창에 https://www.naver.com을 입력했을 때, 어떤 과정을 거쳐서 네이버 페이지가 렌더링 되는걸까? 이 질문에 대답하기 위해선 브라우저, url, 렌더링에 대한 이해가 우선되어야 한다고 생각한다. 결국 질문에 담긴 핵심은 이 세 개념들이기 때문이다.(브라우저 주소창에 url을 입력하면 페이지가 어떻게 렌더링 되는가?) 따라서 차례대로, 브라우저란 무엇이며 어떤 기능을 하는지, url이란 무엇인지, 그리고 마지막으로 렌더링 과정은 어떻게 되는지에 대해 짚고 넘어가보고자 한다. 브라우저란? 웹 브라우저는 웹 서버와의 통신을 통해 HTML, 미디어파일 등을 수신 받아 사용자에게 웹페이지를 렌더링해주는 하나의 응용 소프트웨어다. 조금 더 쉽게 풀어서 설명을 하면, 브라우저가 서버에 데이터를 요청하고 → 서버는 요청받은 데이터를 응답하며 → 브라우저는 응답받은 데이터를 처리하여 사용자에게 웹페이지로써 렌더링 해주는 것이다. 브라우저의 기본 구조 그렇다면 브라우저는 어떤 구성요소들로 구성되어 있으며, 각 요소들은 어떤 기능을 담당할까? 구성요소 설명 유저 인터페이스 (UI) URL 검색창, 뒤로가기 앞으로 가기 버튼, 홈 버튼, 새로고침 버튼 등 브라우저 엔진 중간에서 유저 인터페이스와 렌더링 엔진 사이의 작업과 동작을 제어한다. 렌더링 엔진 HTML과 CSS 등을 파싱하여 콘텐츠들을 화면에 표시하는 역할을 한다. 통신 HTTP 요청과 같은 네트워크 호출에 사용 JS 해석기 자바스크립트 코드를 해석하여 실행하는 역할을 한다. UI 백엔드 OS 사용자 인터페이스를 기반으로 기본적인 위젯 및 툴을 표시한다. 자료 저장소 쿠키, 로컬스토리지, 세션스토리지와 같이 브라우저 자체의 저장소를 의미한다. 즉, UI는 기본적인 브라우저의 틀을 구성하고, 렌더링 엔진이 HTTP 통신을 통해 응답받은 데이터를 파싱하여 화면에 표시해주는 것이 기본적인 브라우저 동작 원리의 골자인 것이다. 언뜻 봐도 위 구성요소들 중에 렌더링 엔진이 굉장히 큰 역할을 담당하고 있는 것 같다. 렌더링 엔진 렌더링 엔진은 응답 받은 HTML 문서를 파싱하여 브라우저 상에 페이지를 표시해준다. 참고로 렌더링 엔진의 동작과정을 설명하며 어려운 단어들이 속출될 예정이다. 파싱, DOM 트리, 렌더트리 등등… 모든 용어들을 알기 쉽게 설명하며 자세히 짚고 넘어갈 것이니 너무 겁먹지 말고 차근히 읽어 내려가길 바란다. 렌더링 엔진의 동작 프로세스 우선 여기서 “**잠깐!**”이라는 말을 하고싶다. 필자 또한 해당 내용을 공부하면서 딱 이 때부터 글을 읽기가 싫어졌었다. 도통 모르는 단어들 뿐인지라 이해가 되질 않았다… 따라서 위에서도 언급했듯, 하나하나 차근히 모든 개념들을 짚어가며 설명을 해보도록 하겠다. DOM 트리 DOM트리 === DOM이라고 생각해도 된다. DOM은 Document Object Model로, 쉽게 말해 HTML 코드(태그)들이 트리형태로 계층화 + 구조화 된 하나의 문서 또는 객체다. 파싱 브라우저가 코드를 읽고 활용할 수 있도록 데이터를 구조화 하는 것 파싱은 구문 분석으로 정의된다. 이를 풀어 설명하면, 데이터를 분석 및 정제하여 원하는 형태로 가공하는 것이다. 따라서, 위에서 설명했듯, HTML문서(코드)를 DOM 형태로 구조화 또는 가공해야 하는데 이를 “파싱한다”라고 표현한 것이다. 렌더트리 진짜 마지막이다! 일단, 렌더트리는 CSSOM + DOM의 결과물이다. CSSOM이란 CSS Object Model로, CSS 코드가 DOM과 같이 파싱되어 구조화 된 것이라고 생각하면 된다. 따라서, 렌더트리란 HTML이 구조화된 DOM과 CSS가 구조화된 CSSOM이 합쳐진 결과물인 것이다. 자, 이제 DOM 트리가 생성되기 위해 HTML이 파싱되고, CSS코드 또한 파싱되어 CSSOM이 되며, 두 트리가 합쳐져 렌더트리가 된다는 것 까지는 이해했다. 이렇게 렌더 트리의 생성이 끝나면, 각 노드들(렌더트리의 각 요소들)의 배치가 시작된다. 즉, 포지셔닝이 된다는 것이다. 그리고 노드들의 배치가 완료되면 UI 백엔드가 각 노드들의 형상을 그려낸다. 이러한 일련의 과정들을 거치며 우리가 작성한 HTML 및 CSS 코드들이 웹상에 표현되는 것이다. 정리 지금까지 설명한 렌더링 엔진의 동작 과정은 위 그림과 같다. HTML 및 CSS 코드들이 파싱되어 각자 트리 형태(오브젝트 모델)로 변환되고 → 두 트리가 합쳐져 렌더 트리가 된다 → 그리고 트리의 노드들이 각각 배치되고 그려지며 내가 작성한 코드들이 브라우저에 그려지는 것이다. 이제 마지막으로 URL이 무엇인지, 그리고 그 URL을 통해 서버에 어떻게 요청이 보내지는지에 대해서만 이해한다면, “_특정 URL을 브라우저에 입력했을 때 해당 페이지가 어떻게 렌더링 되는가?_”에 대한 대답을 해낼 수 있을 것이다. URL이란? url의 구성 요소는 위 사진처럼 스킴 + 호스트 + (패스) + (쿼리)로 이루어져있다. 원래는 포트번호 또한 url의 구성요소이기는 하지만, 스킴에 기본적으로 할당되어 있는 고유 포트번호가 있기 때문에 생략되는 경우가 많다. 스킴 (프로토콜) 한국어에도 문법, 훈민정음, 발음, 상황에 따른 용법 등 다양한 규칙과 기준이 존재하듯, 네트워크 통신에도 이러한 다양한 규칙(프로토콜)들이 존재한다. 즉, 프로토콜은 네트워크 통신을 위한 규약이자 규칙들의 단편들이다. “_나는 이런 규칙을 따르며 통신할거야!_” 도메인 도메인은 컴퓨터의 주소라고 할 수 있는 IP주소가 기억되기 쉽게 변환된 것이다. 192.16X.X.X등을 외우기는 쉽지 않기 때문에, 이러한 IP주소를 외우고 구분하기 쉽도록 www.naver.com과 같은 형태로 변환한 것이 도메인이다. Path Path는 조금 더 세분화된 경로이자 파일의 위치라고 할 수 있다. 즉, 내가 찾는 데이터가 웹서버에 저장된 위치다. 특정 디렉토리 또는 파일의 위치를 찾는 것과 동일하다고 볼 수 있다. 쿼리 (Query) 만약 위의 정보들로는 부족하고, 조금 더 상세한 조건이나 데이터를 담아서 보내주고싶을 때 쿼리를 사용한다. 예를 들어 www.naver.com/place?location=seoul이라고 했을 때, 이는 그냥 place를 통틀어 찾고싶은 것이 아닌 seoul이라는 특정 위치에 대해서만 검색을 하고싶을 때 사용됐을 것이다. URL을 통해 웹서버에 데이터 요청이 일어나는 과정 그럼 이제 URL이 뭔지에 대해서는 개괄적으로 이해가 됐는데, 이러한 URL을 통해 어떻게 웹 서버에 데이터 요청이 일어나는 걸까? 개괄적인 웹서버에 요청을 보내는 과정은 위의 그림과 같다. 이를 조금 더 명료하게 정리를 해보자면 아래와 같이 정리할 수 있을 것이다. 도메인을 IP주소로 변경 DNS 서버에 요청하여 요청 도메인에 대응하는 IP주소를 반환 받는다 (DNS 리졸버) DNS는 네트워크의 전화번호부 역할을 하는 서버라고 할 수 있다. 따라서 우리는 DNS 서버에 나의 도메인에 대응하는 IP주소를 반환받을 수 있는 것이다. ARP 프로토콜을 통해 MAC주소 반환 이제 IP 주소를 얻었으니, 서버 또는 컴퓨터의 정확한 물리적 주소를 의미하는 MAC 주소를 알아내야 한다. IP주소는 하나의 네트워크(계층)에 대한 주소이므로, 정확한 컴퓨터에 요청이 도달하도록 하기 위해서는 MAC주소가 필요하다. 따라서 우리는 ARP 프로토콜을 통해 IP주소에 대응하는 MAC 주소를 반환 받아야 한다. IP와 MAC주소를 통해 서버로 요청 전달 이제 IP주소를 통해 특정 네트워크에 접근하고, MAC주소를 통해 정확한 컴퓨터에 접근한다. 즉, 네트워크라는 큰 범위 또는 계층에 IP 주소를 통해 접근하고, 해당 네트워크에서 MAC 주소라는 물리적 주소를 통해 특정한 컴퓨터에 접근할 수 있는 것이다. 이를 통해 우리는 특정 웹 서버에 요청을 보낼 수 있는 것이다. 이를 하나의 문장으로 다시 정리하자면, 도메인(www.naver.com)을 통해 IP 주소를 얻어내고, 해당 IP 주소로 내가 원하는 웹서버의 네트워크까지 도달한 후, MAC 주소를 통해 정확한 웹서버의 컴퓨터에 액세스하는 것이다. 사실 이렇게 간단히 요약될 수 있는 부분이 아니긴 하지만, 이번 포스팅에서는 이정도의 설명만으로도 충분할 것이라 감히 생각해본다. 여기서 OSI 7계층, 4계층에 따른 분류와 ARP 프로토콜, DNS 리졸버 등에 대해 다루면 글이 끝도없이 길어질 것이다. 따라서 해당 내용들은 다음 포스팅에서 다뤄보도록 하겠다. 정리 및 요약 자, 이제 하나의 요약된 글로써 https://www.naver.com을 입력했을 때 어떻게 해당 페이지가 렌더링 되는지 설명해보도록 하겠다. 브라우저에 해당 url을 입력하면 렌더링 엔진의 통신 기능을 통해 해당 웹 서버로 GET 요청을 보낸다. 해당 GET 요청이 가는 과정은 DNS 서버에 요청을 보내 URL의 도메인에 대응하는 IP 주소를 반환 받고, ARP 프로토콜을 통해 MAC 주소까지 반환받아 웹서버에 요청을 전달하는 것이다. 이렇게 해당 웹서버로 GET요청이 전달되면, 웹서버는 해당 URL에 대응하는 데이터를 응답으로써 반환해준다. 브라우저는 이 때 반환된 데이터를 파싱하여 DOM트리와 CSSOM을 생성하고, 이를 합쳐 렌더 트리를 생성한다. 그리고 생성된 렌더 트리를 통해 각 노드들을 배치 및 형성하여 페이지가 렌더링 되는 것이다. 추가적으로, HTML의 헤드 부분에 script를 넣지 않는 이유는 DOM이 생성되는 과정에서 JS파일이 실행되거나 너무 큰 JS파일의 크기로 인해 로딩 시간이 길어질 수 있음을 방지하기 위함이라고 한다. 만약 그럼에도 불구하고 헤더 부분에 script를 추가하고싶다면 &lt;script defer src=''&gt; 또는 &lt;script async src=''&gt;와 같이 비동기 처리를 해줘야 한다! 참조 자료NAVER D2 Javascript Environment | PoiemaWeb 렌더링 트리 생성, 레이아웃 및 페인트 | Web | Google Developers","link":"/cs/browser/howBrowserWorks/"},{"title":"자바스크립트에서의 비동기 처리","text":"동기와 비동기 “동기와 비동기”… 개발을 하며 자주 들어봤을 단어들이다.정확히 개발에서 사용되는 동기와 비동기의 의미는 뭘까? 우선 단어의 의미만 놓고 본다면, 동기와 비동기는 아래와 같은 뜻을 가진다. 동기 (synchronous) 비동기(asynchronous) 동시에 일어나다 동시에 일어나지 않다 물론, 이런 단어적 의미만 봐서는 프로그래밍에서의 동기와 비동기가 무엇을 의미하는지 명확히 파악하기가 어렵다. 그럼 프로그래밍적 측면에서 동기와 비동기는 뭘 의미할까? 동기 코드가 한 줄, 한 줄 차례대로 실행되는 것이 동기 프로그래밍의 특징이다. 위 사진에 나타나 있듯이, 코드들이 순서대로 대기를 하고 있다가, 자신의 차례가 오면 실행된다. 즉, 나보다 앞에 있는 코드들의 실행이 모두 끝날 때 까지 기다려야 내가 실행될 차례가 온다는 뜻이다. 알다시피 자바스크립트는 동기적 프로그래밍 언어다. 이 때문에 아래와 같이 코드가 순차적으로 실행되는 것이다. 더 나아가, 동기와 비동기를 예를 들어 설명해보도록 하겠다. 만약 오늘 엄마가 설거지, 빨래, 재활용 버리기 심부름을 시키셨다고 가정해보자. 필자는 설거지를 하고, 세탁기를 돌려놓은 뒤에 재활용을 버리고 돌아올 것이다. 이러한 방식이 바로 비동기적 행위다. 하지만 만약… 세탁기가 다 돌아가기 전까지 앞에서 기다리고 있다가, 빨래가 끝나고 그제서야 재활용을 버리러 간다면 이는 동기적 행위다. 이러한 방식은 프로그래밍적 측면에서 봤을 때 굉장히 단순하고 설계하기가 쉽지만, 때로는 심각한 비효율성을 초래할 수 있기 때문에, 동기와 비동기의 적재적소에의 활용이 필요하다. 비동기 코드가 각자 멀티태스킹과 같이 독립적으로 실행되는 것이 비동기 프로그래밍의 특징이다.즉, 굳이 기다려주지 않는다! 비동기 프로그래밍이란, 각 코드들이 다른 코드들의 실행 완료 여부에 종속되지 않고 독립적이고 자율적으로 실행될 수 있는 형식을 뜻한다. 내가 중간에 위치한 코드라고 하더라도, 앞의 코드들이 종료될 때까지 기다리지 않아도 된다는 뜻이다. 상술했듯, 굳이 세탁기가 다 돌아갈 때 까지 앞에서 멀뚱멀뚱 기다리고 있지 않아도 된다는 것이다. 개념은 와닿을 수 있어도, 프로그래밍적으로 어떤 의미인지 헷갈릴 수도 있기에 코드로 이를 설명해보도록 하겠다. 위 코드에서 필자는 setTimeout을 통해 비동기적 실행을 구현했다. 이를 풀어 설명해보자면, 설거지를 끝내고 → 세탁기를 돌린 뒤 → 재활용을 버리러 간 것이다. 그리고 20분 뒤에 “세탁 완료”가 된다. (1200000ms = 20분). 이처럼, 우리는 동기적 프로그래밍 일변도의 코드 뿐만이 아닌, 비동기와 동기 모두의 적절한 조화를 구현할 수 있다. 하지만, 이러한 비동기성에 의해 발생할 수 있는 문제점들 또한 존재한다.아래 예시를 봐보도록 하자. 이처럼 setTimeout을 통해 비동기적 실행을 해야 할 경우가 있다고 가정할 때, 비동기적 실행 때문에 console.log(step2)가 undefined로 출력되는 문제가 발생할 수 있다. 이런 비동기 처리에 의해 발생하는 문제점을 어떻게 해결할 수 있을까? 여기서 처음 등장한 것이 콜백 함수다. 콜백 함수 콜백함수는 다른 함수의 인자로써 활용되는 함수, 또는 어떤 이벤트나 메소드에 의해 호출되는 함수라고 할 수 있다. 즉, 내부함수이자 피동적인 성격을 갖는 함수라고 볼 수 있는 것이다. 바로 코드를 통해 설명해보도록 하겠다. 우선 콜백함수의 생김새부터 살펴보자. 12345// 여기서 handleClick은 콜백 함수다 (addEventListener라는 함수에 의해 호출되어지기 때문)document.querySelector('div').addEventListener('click', handleClick);// 아래의 화살표 함수 또한 콜백함수라고 할 수 있다. setTimeout에 의해 호출되어지기 때문이다.setTimeout(() =&gt; {}, 1000); 또는, 아래와 같이 즉각적으로 실행되는 콜백 함수 또한 좋은 예시가 될 수 있다. 123456789101112// sayHello의 인자로써 사용된 callback()이라는 함수도 콜백 함수다.function sayHello(callback) { console.log('안녕하세요 반갑습니다.'); // #2 콜백이 실행된다. callback();}// #1 sayHello 안에 console.log(&quot;저보 반갑습니다.&quot;)를 실행시키는 콜백함수를 담아 보낸다.sayHello(() =&gt; { console.log('저도 반갑습니다.');}); 그리고 아래와 같은 동기적 대응을 위한 콜백함수의 활용법 또한 존재한다. 12345678910111213141516171819function Ramyun(callback) { let percentage = 0; // setInterval은 비동기적으로 실행된다. const boil = setInterval(() =&gt; { percentage += 25; if (percentage === 100) { console.log(`물이 ${percentage}% 완전히 끓었습니다`); clearInterval(boil); // 콜백함수를 비동기 함수인 setInterval이 클리어링 될 때 실행시킨다. callback(); return; } console.log(`물이 ${percentage}% 끓었습니다`); }, 1000);}Ramyun(() =&gt; { console.log('면이랑 스프 넣기'); console.log('맛있게 먹기');}); ⇒ 이처럼, 콜백함수를 사용하면 비동기적 특성에 의해 발생하는 문제점을 해결할 수 있다. 하지만, 딱 봐도 알 수 있듯이 굉장히 가독성이 떨어진다…그리고 결정적으로 “콜백 지옥“이라는 문제가 발생될 수 있다. 콜백지옥이란, 위 사진과 같이 콜백 함수가 겹겹이 쌓여 있는 경우를 의미한다. (최악의 가독성이다…) 123456789101112// 에러 핸들링이 어려운 이유 (예시 코드)try { // throw new Error가 1초 뒤에 콜백으로써 실행된다. // 하지만, setTimeout은 비동기로 동작하기에 호출 스택에서 즉시 제거된다. // 따라서 아래의 콜백 함수는 테스트 큐에서 대기 후 -&gt; 호출 스택으로 이동되어 실행되지만, 호출자인 setTimeout은 이미 제거된 뒤이기에 에러를 캐치하지 못한다. setTimeout(() =&gt; { throw new Error('에러 발생!'); }, 1000);} catch (e) { console.log('위와 같은 이유로 에러를 캐치하지 못한다..'); console.log(e);} 이처럼… 콜백은 굉장히 가독성이 떨어지고 유지보수성 또한 저하되며, 위와 같이 에러 핸들링이 굉장히 제한적이다. 따라서 우리는 콜백 함수에서 더 나아가 “**프로미스(Promise)**”라는 대안을 활용할 수 있다. 프로미스 프로미스 또한 비동기 처리를 위한 하나의 객체다.new Promise()를 통해 인스턴스화 된다. (IE 지원 X) 주요 형태는 아래와 같다. 123456789// Promise 객체를 생성 (인스턴스화)const promise = new Promise((resolve, reject) =&gt; { if (/* 비동기 작업 성공적으로 완료 */) { resolve('result'); } else { /* 비동기 작업 실패 */ reject('failure reason'); }}); 위에서 유추할 수 있듯, 프로미스에는 세 가지의 주요 상태값이 존재한다. 상태 설명 pending 비동기 처리가 아직 실행되지 않음 fulfilled 비동기 처리가 성공적으로 수행 완료 (resolve함수가 호출됨) rejected 비동기 처리의 수행의 실패 (reject 함수가 호출됨) 다시, 라면 주문하기의 예를 통해 프로미스가 어떻게 활용되는지 확인해보도록 하자. 1234567891011121314151617181920212223242526272829303132// 김밥천국에 준비된 라면 재고들const Ramyuns = ['신라면', '진라면', '불닭'];function getRamyun() { // 프로미스 객체를 반환하겠다는 뜻 return new Promise((resolve, reject) =&gt; { // 비동기 setTimeout의 실행 setTimeout(() =&gt; { // 라면의 재고가 있으면? resolve if (Ramyuns.length) { resolve(Ramyuns[0]); } else { // 없으면 reject를 반환 reject('라면이 다 떨어졌습니다 죄송합니다...'); } }, 1000); });}const whichRamyun = getRamyun();// 만약 fulfilled라면, resolve에 의해 promise object가 반환됐을 것이다.// 이를 result라 임의로 이름 짓고, console.log()를 통해 찍어낸 것!const onFulfilled = (result) =&gt; { console.log(`${result} 잘 먹겠습니다 :)`);};const onRejected = (error) =&gt; { console.log(error);};// whichRamyun이 fulfilled던, rejected던 getRamyun의 실행이 완료되어 값이 할당 됐을 때,// then을 통해 기다렸다가 동기적으로 둘 중 하나를 실행한다.whichRamyun.then(onFulfilled, onRejected); 아니면 에러 처리 및 후처리를 catch와 finally를 활용해 구현하는 것 또한 가능하다. 123456789101112// 이번에는 라면이 없는 경우를 가정했다.const Ramyuns = [];function getRamyun() {(...생략)}const whichRamyun = getRamyun();whichRamyun .then((result) =&gt; console.log(result)) // 에러를 캐치한다! .catch((error) =&gt; console.log(error)) // 프로미스가 fulfilled던, rejected던, 프로미스 반환 후 최종적으로 실행시키고싶은 함수가 있을 때 사용한다. // 라면을 잘 먹었던, 없어서 나가야되던, 인사는 해야하니까... .finally(() =&gt; console.log(&quot;안녕히 계세요!&quot;)); 에러 처리의 효율성은 catch가 더 좋다고 한다! 만약 catch를 사용하지 않은 첫 번째 에러처리 예시의 경우, resolve가 됐더라도, fulfilled에 대한 콜백에서 오류가 난다면 이를 제대로 잡아내지 못하기 때문이다. (Uncaught Error). 12345whichRamyun.then((result) =&gt; { console.log(result); // 이 경우의 에러를 잡아내지 못함... throw new Error('then에서의 에러가 발생했습니다!');}); async/await 마지막으로… async/await는 ES8에 추가된 신상 문법이다.비동기 핸들링 코드 작성을 하는 데 있어 코드의 가독성이 굉~장히 좋다는 특징을 갖는다. 가독성이 좋은 만큼, 사용법도 굉장히 심플하고 간편하다. 1234567891011// 일반 함수에서의 사용async function something() { const ramyun = await getRamyun(); return ramyun;}// 화살표 함수에서의 사용const something = async () =&gt; { const ramyun = await getRamyun(); return ramyun;}; 이를 다시 라면 주문하기의 예시로 설명해보겠다. 1234567891011121314151617const Ramyuns = [&quot;신라면&quot;];function getRamyun() {(/* ...생략 */)}(async function ramyun() { // then()과 흐름은 동일하다. try { // 직관적으로 알 수 있듯, await! 기다리라는 뜻이다. const ramyunName = await getRamyun(); // 그러면 위의 getRamyun의 실행이 종료될 때까지 기다린다. console.log(`${ramyunName} 잘 먹겠습니다 :)`); } catch (error) { // 에러와 finally도 동일! console.log(error); } finally { console.log(&quot;안녕히 계세요!&quot;); }})() // 즉시 실행시키기 위해 괄호로 감싸준 모습 대충 봐도 알겠지만, 프로미스의 장점에 더해 (에러처리, 비동기 처리의 효율성) 가독성까지 겸비한 모습이다. 따라서 요즘 대부분의 비동기 핸들링에는 async/await가 사용된다. 정리 및 요약자바스크립트는 동기적 실행을 기반으로 하는 언어이기 때문에, 코드들이 순차적이고 직렬적으로 실행된다. 하지만 web API에 의해 setTimeout, setInterval 등의 병렬 및 비동기 처리가 가능해졌고, 이러한 비동기 프로세스를 핸들링 하기 위해 사용되는 것이 callback(), Promise, async/await다. 콜백은 특정 함수 안에서 호출되어지는 또 다른 함수로 요약할 수 있는데, 특정 함수가 실행된 뒤 원하는 후속 함수가 실행되도록 코딩을 하는 방법을 따른다. 하지만, 이러한 콜백 함수는 가독성이 굉장히 떨어지고 에러 핸들링에 치명적 단점을 갖고 있기에, Promise를 대안으로 사용하기 시작했다. 프로미스는 then() 을 사용하며 조금 더 가독성이 좋아졌고, catch를 활용할 수 있게되며 에러 핸들링 또한 콜백에 비해 더 나아졌다. 하지만 ES8에서 async/await라는 신문법이 나왔고, 훨씬 더 가독성이 좋고 보일러 플레이트가 간소화된 비동기 핸들링이 가능해졌다. 세 줄 요약 자바스크립트는 기본적으로 동기적 언어인데, 종종 비동기적으로 작동하는 코드 때문에 오류가 발생하는 경우가 생긴다. (setTimeout, fetch, setInterval 등등) 이런 비동기 핸들링을 위해 callback, Promise, async/await가 사용된다. 하지만 에러 핸들링과 가독성 측면 등 모든 부분에서 async/await가 우월하기에 이를 가장 많이 활용한다. 참조한 자료JavaScript Promises 자바스크립트 async와 await Promise | PoiemaWeb","link":"/javascript/base/asyncawait/"},{"title":"Javascript는 어떻게 작동하는가?","text":"💡 사전 지식 Parse : 컴퓨터가 이해할 수 있도록 프로그래밍 언어가 데이터를 가공하고 읽기 위해 일정한 포맷으로 변환하는 것. (쉽게 말하면, 사람의 언어 구조 → 컴퓨터의 언어 구조로 변환되는 것이라 봐도 될 것 같다) Thread : 프로그램 내에서의 작업 또는 프로세스의 경로 자바스크립트 개요 JS는 컴파일이 필요 없는 Interpreter 언어이다. JS는 변수를 설정할 때 특정 문자열타입을 지정하지 않고 let과 const에 구분없이 담을 수 있다. (동적 타입) 이러한 타입 시스템의 부재로 정적타입 언어인 C, C++에 비해 자바스크립트는 효율성이 떨어지고 느리다. 그렇다면 이렇게 비효율적이고 느린 언어를 계속 사용하는가? 이를 이해하기 위해선, 자바스크립트의 역사에 대해 간략히 짚고 넘어가야 한다. JS의 역사 1990년대의 웹 브라우저들은 매우 정적이고 비상호적인 페이지들을 띄우는 역할만을 담당했었다. 하지만 이후 웹 브라우저에서의 상호작용성을 더하기 위해 1995년 Netscape의 브랜든 아이크(Brendan Eich)에 의해 10일만에 개발된 Javascript가 세상에 공개되었고, 이는 혁신을 일으켰다. 하지만 여러 경쟁사들이 이러한 동적이고 상호적인 브라우저 언어의 개발에 뛰어들었고, 브라우저마다 언어가 달랐기에 호환성 등의 문제가 발발했다. 이에 따라 ECMA Script라는 브라우저 언어에 대한 약속이자 문법을 담은 문서가 개발된 것이다. 그렇게 표준화 되어가는 것 처럼 보이던 ECMA Script에 의한 브라우저 언어의 안정성과 호환성은 마이크로소프트 사의 ECMA 참여 거부로 점점 불안정해지기 시작한다. 그러나, Jesse James라는 개발자가 AJAX를 제안했고, 2008년 생태계 교란종이라고 할 수 있는 강력한 Chrome의 등장으로 위기를 느낀 다른 브라우저들의 협력을 통해 ES5, ES6 등의 문서들이 이후 작성되었다. 드디어 JS는 성숙하고 안정된 언어로 자리잡을 수 있게 된 것이다. 이제 JS가 브라우저에서 어떻게 “실행(Implemented)”되어야 하는지는 ES에 의해 정의됐다.그렇다면 “어떻게” 작동되어야 하는지는 무엇이 결정하는가? ⇒ JS엔진에 대한 이해가 필요하다. 자바스크립트 엔진 모든 브라우저는 JS코드를 실행하기 위한 JS 엔진을 탑재하고 있다 (Netscape는 SpiderMonkey라는 엔진을, Chrome은 V8엔진을 사용한다). 가장 기초적인 엔진구조(SpiderMonkey)는 JS소스코드를 컴파일 하여 Bytecode로 만드는 baseline compiler → 그리고 이 Bytecode를 머신코드(Binary Code)로 변환하여 최종적으로 CPU에서 실행되게 하는 Interpreter가 존재한다. 하지만 이러한 기초적 엔진구조는 컴파일 시간의 단축에만 집중할 뿐, 코드의 최적화에는 목적을 두지 않는다. 따라서 위와 같은 기초적 엔진구조는 아주 동적이고 인터렉티브한 웹 어플리케이션을 구동하는데 무리가 있다. 이러한 문제점들을 해결하기 위해 구글(Google)은 V8엔진을 사용한다. V8은 Baseline Compiler로써 Full-Codegen을 사용하고, 최적화를 위한 Crankshaft를 사용한다. 기존과 같이 Full-Codegen은 최적화를 신경쓰지 않고 최대한 빨리 Binary Code를 반환한다. 하지만 이러한 과정 중에 소스코드의 최적화를 진행해 최적화된 코드를 Full-Codegen이 반환한 코드의 일부와 대체한다. 즉, 빠른 컴파일과 최적화를 행한다는 것이다. 어떻게 작동되는지에 대한 프로세스는 이제 알겠다. 그렇다면 그 “최적화”라는 것은 어떻게 이루어지는가? 자바스크립트의 최적화 위에서 설명했듯, JS는 타입 시스템이 없고, 더 나아가 프로파일링 데이터(Profiling Data)를 수집하며 느리게 실행되는 코드를 감별하느라 CPU에 부담을 준다. 이에 따라 2017년에 새로 개발된 것이 새로운 V8엔진이다. 새로운 버전의 V8 엔진에는 Ignition이라는 파이프라인이 추가됐다. 이는 **베이스라인의 기능( JS 소스코드 → 바이트 코드로 변환) + 인터프리터의 기능(바이너리 코드로의 변환)**이 이루어지는 파이프라인이다. 그리고 Turbo Fan은 Ignition으로 부터 프로파일링 데이터를 넘겨받아 Hot코드 (CPU에 부담을 주는 코드)를 최적화 할 지, 말 지를 결정한다. 런타임에서의 JS 자바스크립트는 single-threaded 언어다. 즉, 자바스크립트는 코드가 실행될 때 모든 코드가 한 덩어리로써 한번에 실행된다는 것이다. 이러한 싱글 스레드 방식의 문제점은, 실행시간이 오래걸리는 코드가 중간에 껴있으면, 그 후의 코드 실행에 악영향을 미친다는 것이다. 따라서 이러한 블락(또는 무한루프) 문제점이 발생하면 브라우저의 모든 기능들은 중단된다는 문제점을 갖는다. 하지만 다행히도, 이제는 대부분의 브라우저들이 멀티탭 기능들을 탑재하고 있기에, 브라우저별 스레드가 아닌 탭(Tab)별 스레드가 적용되기 때문에 하나의 탭에만 싱글 스레드 문제점이 적용된다. 이렇듯 자바스크립트는 싱글 스레디드 언어이기 때문에 하나의 힙 메모리와 하나의 스택을 갖는다. 스택에서의 코드 실행 방식과 pop 방식은 아래와 같이 LIFO(후입선출)를 따른다. 이와 같은 싱글 스레드 방식만을 따르면, 브라우저는 HTTP 요청을 보내거나 받는 동안 다른 모든 핵심 기능들을 (캐싱, 데이터베이스 스토리지, DOM 이벤트 리스닝 등등) 사용하지 못할 것이다. 이를 해결하기 위해 자바스크립트만의 스레드는 독립적으로 두되, 브라우저 자체 내에서 다른 스레드를 구성하여 DOM 이벤트 리스닝, 캐싱, 데이터베이스 스토리지 등을 자바스크립트와는 독립적으로 기능할 수 있도록 하는 것이다. 이러한 독립적 스레드를 사용하는 브라우저 기능 중에는 Web API 요청을 위한 fetch() 가 있다. 이 fetch()는 자바스크립트 엔진 내의 스레드를 사용하지 않기 때문에 비동기적으로 작동하고, 이러한 비동기 방식 때문에 우리는 fetch()를 사용할 때 콜백함수를 사용하고, async await과 같은 비동기 처리 방식들을 사용하는 것이다. 1234567891011121314151617function printHello() { console.log('Hello from baz');}function three() { setTimeout(printHello, 3000);}function two() { three();}function one() { two();}one(); Event Loop : 콜스택과 콜백 큐를 주시하며, 콜스택이 비어있고, 콜백 큐에 처리해야 할 스택이 존재한다면 해당 스택을 콜스택으로 옮겨 쌓아 올리는 역할을 한다. 이와 비슷하게 setTimeout() 또한, 콜스택과 메시지큐, 이벤트루프에 의한 독립적 스레드에 의해 효율적으로 작동된다. 먼저 위의 코드를 보면 one() → two() → three() 순으로 코드가 실행될 것이다. 하지만 three()의 setTimeout()내의 콜백함수인 printHello()는 자바스크립트에 의해 webAPI로 보내질 것이고 자바스크립트 엔진 자체에서 3초를 기다리는 것이 아닌, 자바스크립트 자체는 이후 바로 다음 라인의 코드로 넘어간다. 하지만 다음 라인의 코드가 없기에 자바스크립트는 콜스택에서 three two one을 순서대로 pop할 것이다. 하지만 3초 뒤 콜백함수(printHello)는 webAPI에 의해 메시지큐에 담길 것이고, 이벤트루프가 이 콜백함수를 다시 콜스택 위에 올릴 것이다. 그렇게 setTimeout과 그 안의 콜백함수가 실행되는 것이다.","link":"/javascript/base/javascript-howItWorks/"},{"title":"Javascript와 This","text":"this는 바닐라 자바스크립트를 통한 개발을 할 때에는 자주 사용했었지만,리액트로 개발을 하며(함수형) 최근에는 사용할 일이 없었다. 하지만, 최근 DFS/BFS와 같은 트리 순회 알고리즘을 공부하며 클래스를 자주 사용하게 됐는데, 이에 따라 this와 부딪힐 일이 많아졌다. 예전에는 그냥 this가 단순히 모호한 의미에서 “나 자신(myself)”이라고만 생각하고 날림식으로 개발을 했었다. 하지만 계속 사용하다 보니, 사용할거면 제대로 알고 사용해야겠다는 생각이 들었다. this? 그렇다면 this란 무엇을 의미하는걸까?결론부터 얘기하자면, this란 함수 호출을 한 객체를 가리킨다. (”_누가 날 불렀어?_”) 그리고 반드시 짚고 넘어가야 하는 부분 중 하나는, 자바스크립트에서의 this는 호출 방식에 따라 동적으로 결정된다는 점이다. 말이 어렵게 느껴질 수 있는데, 쉽게 얘기하면 “누가 날 불렀는지에 따라 this가 결정된다”는 것이다. 위의 그림의 예시처럼, 같은 “아들“이지만, 아들을 호출한 사람이 누구냐에 따라 불려진 아들이 누군지 달라지는 것과 같은 맥락이라고 볼 수 있다. 함수에서의 this 코드로 한 번 예시를 들어보도록 하겠다.우선 빈 허공(?)에 this를 찍어서 호출해보자. 그러면 위와 같이 window 객체가 반환되는 것을 확인할 수 있다. 이 뜻은 this를 호출한 것이 window라는 뜻이다. 이는 어찌 보면 굉장히 당연한 얘기다. 그냥 어떠한 것도 지정하지 않은채 window라는 글로벌 영역 위에서 this를 호출했기 때문이다. 이 때 우리는 “**this가 window에 바인딩 됐다**”라고 표현한다. 하지만, 이는 자바스크립트의 모드가 strict mode(use strict)가 아닐 때의 얘기고, 만약 strict mode가 적용된 상태라면 this는 undefined가 된다. (디폴트 바인딩이 존재하지 않기 때문) 일반 함수그렇다면 아래의 경우는 어떨까? 1234function sayThis() { console.log(this);}sayThis(); ⇒ 이 경우도 동일하게 strict mode일 때는 undefined가, 그렇지 않을 때는 window 객체가 반환된다. 그럼 이 경우는? 123456789function outer() { console.log(this); // window function inner() { console.log(this); // window } inner();}outer(); 위의 예시 또한 동일하다. 필자도 처음에는 “어..? inner함수가 outer에서 호출 됐으니 outer가 바인딩 되어야 하는 것 아닌가?”라는 생각을 하며 헷갈렸던 부분이다. 하지만 자바스크립트에서 내부함수는 일반함수, 콜백함수, 메소드 어디에서 선언되어도 전역객체를 바인딩 한다는 것을 명심해야 한다. 다시, 내부함수는 일반함수던, 콜백함수던, 메소드 함수던, “내부”에서 호출되었으면 전역객체를 디폴트로 바인딩 한다. 내부함수를 바인딩하는 방법 apply, call, bind를 활용해서 메소드나 콜백함수의 내부함수를 명시적으로 바인딩 해줄 수 있다. 1234567891011121314151617const aboutMe = { name: 'hoonjoo', introduce: function () { console.log('this is ', this); // aboutMe console.log('my name is ', this.name); // hoonjoo // 내부함수 function inner() { console.log('inner this: ', this); console.log('inner name is ', this.name); } inner.apply(aboutMe); // 방법1: apply 사용 inner.call(aboutMe); // 방법2: call 사용 inner.bind(aboutMe)(); // 방법3: bind 사용 (bind는 즉시 실행이 아닌, 새로운 함수를 리턴해줌) },};aboutMe.introduce(); 메소드에서의 this 위에서 약간의 스포일러가 있었지만, 다시 한 번 설명하자면함수가 메소드 내에서 특정 프로퍼티의 값이라면 메소드가 포함된 객체가 호출자가 된다 (전역 객체 바인딩 X) 바로 코드로 넘어가보자. 123456789101112131415const aboutMe = { name: 'hoonjoo', introduce: function () { console.log(`제 이름은 ${this.name}입니다.`); },};const myFriend = { name: 'joongseob',};myFriend.introduce = aboutMe.introduce;aboutMe.introduce(); // ?myFriend.introduce(); // ? 위 코드에서 aboutMe와 myFriend의 실행 결과는 어떻게 될까? 정답부터 얘기하면, aboutMe의 this는 ‘hoonjoo’로 바인딩 된다. myFriend의 this는 ‘joongseob’으로 바인딩 된다. 생성자 함수에서의 this 생성자 함수란, 클래스와 비슷하게 객체를 생성하는 역할을 하는 함수다.주로 const OOO = new 생성자함수();와 같이 활용한다. 123456789// 생성자 함수는 대문자로 시작하는 것이 일반적이다.function Family(name) { // 리턴을 명시해주지 않은 이유는, // 생성자 함수는 리턴을 명시하지 않아도 막 새로 생성된 객체를 반환해주기 때문이다. this.name = name;}const brother = new Family('Chan');console.log(brother); // Family {name: &quot;Chan&quot;, constructor: Object} 위 코드에서 볼 수 있듯, 생성자 함수를 활용하면 새로 생성된 객체에 this가 바인딩 된다. 하지만 주의할 점은, new를 명시해주지 않으면 이는 생성자 함수로써의 기능을 유실하기 때문에, 반드시 생성자 함수를 사용할 때에는 new와 함께 사용해야 한다. (new 사용하지 않으면 전역객체에 바인딩) 생성자 함수는 어떻게 동작될까? 생성자 함수가 실행되면,빈 객체가 생성되고 → 그 빈 객체에 내가 설정한 프로퍼티 또는 메소드가 저장된다 → 그리고 새롭게 만들어진 객체를 반환해준다. 이를 위의 코드로 다시 설명 해보면 아래와 같다. 1234567function Family(name) { // 1.빈 객체가 만들어짐 this.name = name; // 2.name이라는 프로퍼티가 입력됨 // 3.자동으로 새로 만들어진 객체를 반환해줌}const brother = new Family('Chan'); // 실행! 화살표 함수에서의 this 위에서 분명 내부 함수는 전역객체를 바인딩한다고 신신당부 했었다.하지만 이를 우회할 수 있는 방법이 있는데, **화살표 함수(Arrow Function)**를 사용하는 것이다. 화살표 함수는 일반 함수와는 다르게, 바인딩할 this를 정적으로 결정한다. 이를 Lexical This라고도 하는데, 풀어 설명하자면 상위 스코프의 this를 가리킨다는 뜻이다. 이를 코드로 다시 설명해보자면 아래와 같다. 123456789101112131415const aboutMe = { name: 'hoonjoo', introduce: function () { console.log(`제 이름은 ${this.name}입니다.`); const inner = () =&gt; { console.log(`저도 ${this.name}입니다.`); }; inner(); },};aboutMe.introduce();// 실행 결과 :// 제 이름은 hoonjoo입니다.// 저도 hoonjoo입니다. 분명 위에서는 메소드 내의 내부함수는 call, bind, apply를 사용해서 this를 명시적으로 바인딩 해줘야 했었다. 하지만 위의 코드처럼 화살표 함수를 사용하면 내부함수를 사용했더라도, 전역객체가 아닌 상위 스코프의 this를 저절로 바인딩 하는 것을 확인할 수 있다🤭 정리 및 요약this는 호출자에 의해 동적으로 결정되는 하나의 객체이자 출처라고 할 수 있다. use strict를 사용하지 않는 경우, 일반함수에서 this를 사용하면 전역객체인 window를 바인딩 한다. 또한, 내부함수는 apply, call, bind 메소드 또는 화살표 함수를 사용하지 않는 한, 전역객체를 자동으로 바인딩 한다. 내부함수와 반대로 메소드 안에서 프로퍼티의 값으로 쓰인 함수는 메서드가 포함되는 객체를 바인딩 한다. 또한, 생성자 함수를 사용해도 생성자 함수에 의해 새로 생성된 객체를 바인딩 한다. 세 줄 요약 this는 자신(함수)을 호출한 객체를 지칭한다. 내부함수는 화살표 함수, apply, bind, call를 사용하지 않는 한, 전역객체를 바인딩한다. 메서드의 프로퍼티로 쓰인 함수와 생성자 함수는 호출 객체를 바인딩한다.","link":"/javascript/base/this/"},{"title":"var, let, const의 차이","text":"var var은 ES5까지 자바스크립트에서 모든 선언을 담당했던 키워드였다.근데 var은 참 많은 문제점들을 보유하고 있었다고 한다. 그럼 var 키워드의 특징들에는 무엇이 있는지 알아보자. 함수레벨 스코프(Function-Level-Scope) 기본적으로 var은 **함수레벨스코프(Function-Level-Scope)**로, 선언된 함수 안에서만 해당 변수를 사용할 수 있도록 한다. 즉, 함수의 코드블록 범위 까지만을 스코프로 인정하는 것이다. 12345678function test() { for (var i = 0; i &lt; 5; i++) { continue; } console.log(i); // 5}// 근데 함수 밖에서 쓰면 ?console.log(i); // ReferenceError: i is not defined ⇒ ⚠️ 만약 함수 밖에 전역적으로 var 선언을 했다면, 이는 전역변수가 된다. 따라서 var를 잘못 사용하면 전역변수의 오남용을 초래할 수 있다. 재선언이 가능하다. 아래와 같이 변수의 재선언이 가능하기 때문에, 변수 명을 헷갈려 실수로 같은 변수명을 사용하는 등의 오류 발생을 초래할 수 있다. 123var name = 'hoon';var name = 'joo';console.log(name); // 아무 오류도 발생하지 않고 joo가 출력된다. 변수를 호이스팅 한다. 아래에서 호이스팅에 대해 조금 더 자세히 다룰 것이다.우선, var은 호이스팅이 되기 때문에 변수를 선언하기 전에 console.log()를 찍어도 에러가 나지 않는다. 12console.log(name); // undefinedvar name = 'hoon'; ⇒ 하지만 let과 const는 위와 같은 코드를 실행시켰을 때 undefined가 아닌 ReferenceError: i is not defined 등의 결과가 나타난다. 스코프? 한 마디로, 변수에 접근할 수 있는 범위를 의미한다. 전역 스코프 ⇒ 전역적으로 선언된 변수는 전역 스코프에 해당한다. 따라서 어디서든지 변수에 접근하여 이를 활용할 수 있다. 지역 스코프 ⇒ 지역 스코프는 특정 지역(범위)에서만 해당 변수를 접근할 수 있다. 🎣 호이스팅 쉽게 말해 “감아올리다”라는 의미다.호이스팅은 모든 선언문들을 해당 선언문이 적용받은 스코프의 최상단으로 옮겨진 것처럼 작동하도록 한다.즉, 스코프의 최상단으로 해당 선언문을 끌어올리는 것이다. 호이스팅을 설명하기에 앞 서, 기본적으로 변수가 생성되는 과정은 선언 → 초기화 → 할당과 같다. 선언단계 (Declaration Phase) 변수 객체에 변수가 등록된다. 초기화 단계 (Initialization Phase) 해당 변수를 메모리에 할당한다. 그리고 변수는 undefined로 초기화 된다. 12// 선언 + 초기화var name; 할당 단계 (Assignment Phase) undefined로 초기화된 변수에 원하는 값을 할당한다. 12345// 선언 + 초기화var name; // undefined// 할당name = 'hoon';console.log(name); // hoon 호이스팅과 변수 생성 과정의 차이에 따라 아래와 같은 차이점들이 나타난다. var var의 경우에는 생성과 동시에 초기화가 이루어진다. 따라서 아래와 같이 console.log(name)만으로도 생성 + 초기화가 이루어진다. 123456console.log(name); // undefinedvar name;console.log(name); // undefinedname = 'hoon';console.log(name); // hoon let 하지만 let의 경우에는 생성과 초기화의 과정이 분리되어 있다. 따라서 아래와 같이 초기화를 하기 전에 변수를 사용하려고 하면 에러가 난다. 12console.log(name); // ReferenceError: name is not definedlet name; ES6 : let과 const의 등장 ES6 에서 부터 let과 const가 등장했다.이 둘은 var과 어떻게 다르며, 또 let과 const는 서로 어떻게 다를까? 함수레벨 스코프 vs 블록레벨 스코프 let과 const는 블록레벨 스코프다. 즉, 변수가 특정한 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언됐다면, 이 코드 블록 내에서만 변수에 접근할 수 있다. 12345// 그래서 아래와 같이 for문 안에서 선언된 let은 for문 밖에서 접근할 수 없다.for (let i = 0; i &lt; 5; i++) { continue;}console.log(i); // ReferenceError: i is not defined 재선언과 재할당 let과 const는 var과 달리 재선언이 절대 불가능하다. 하지만, 그럼에도 let과 const에는 차이점이 있다. let은 재할당이 가능하다. 123let name = 'hoon';name = 'joo';console.log(name); // joo const는 재할당마저도 불가능하다. 123const name = 'hoon';name = 'joo';console.log(name); // 오류 발생 TypeError: &quot;name&quot; is read-only","link":"/javascript/base/var_let_const/"},{"title":"왜 함수는 객체인걸까?","text":"“모든 함수는 객체지만, 모든 객체가 함수인 것은 아니다.” 위의 소제목이 이번 포스팅의 골자다.프로토타입을 공부하다 보니, 자꾸 Function 프로토타입의 __proto__가 객체라는 것이 직관적으로 와닿지가 않아 한번 제대로 짚고 넘어가보고 싶었다. 우선, 우리가 흔히 알고있듯, 자바스크립트에서 자료형은 원시타입과 참조타입으로 나뉘어진다. 원시타입에는 [number, string, boolean, null, undefined, symbol]이 있다. 그리고 그 이외에는 모두 참조타입이다. 참조타입에는 [Object, Array, Function]이 있다. 근데 모든 참조타입의 원형은 객체라고 한다. 이 때문에 함수건, 배열이건, 프로토타입을 통해 확인해보면 최상위 프로토타입이 Object로 찍히는 것이다. 필자는 그동안 코딩을 하며 위의 사진처럼 굉장히 단순하게만 자료형을 인식하고 있었다. 하지만 얕았던 이러한 생각에 점차 금이 가기 시작했고, 이왕 궁금증과 찝찝함이 생긴 김에 제대로 짚고 넘어가보고자 한다. 객체란? 함수가 왜 “객체”인지 이해하기 위해선, 당연히 객체가 무엇인지 먼저 이해해야 한다.”고래는 왜 포유류인가?”라는 질문에서, 포유류가 뭔지도 모르는데 고래가 왜 포유류인지 설명할 수는 없는 것처럼 말이다. 일단 각설하고, 본론으로 들어가자면 객체란 키-값 쌍으로 이루어진 참조형 데이터 타입이다. 키-값 쌍은 아래와 같이 표현된다. 1234const obj = { key: value, // value에는 거의 모든 것들이 할당될 수 있다. key: method, // 심지어 method처럼 함수가 값으로 할당될 수도 있다.}; 그리고 참조 타입은, 객체의 모든 연산이 실제값이 아닌 참조값으로 처리되는 자료형을 뜻한다. 조금 더 쉽게 말하면 데이터 자체를 저장하는 것이 아니라, 주소를 저장해둔 뒤 해당 주소를 통해 참조하고 있는 데이터에 접근해 값을 계산 및 활용한다는 것이다. 아래의 예시를 확인해보자. 123456// 이와 같이 객체를 생성했고,const foo = { age: 20,};// bar에 foo를 할당했다.const bar = foo; 그러면 이와 같이, foo와 bar은 모두 같은 값을 참조하고 있음을 확인할 수 있다. 여기서 다시금 강조하고싶은 것은 ‘참조’하고 있다는 것인데, 이에 따라 age가 30으로 변하면 foo bar 모두 변경된 값을 똑같이 참조한다. 그렇다면 아래와 같은 경우는 어떨까? 1234567const foo = { age: 20,};const bar = { age: 20,}; 두 번째 예시에서는 육안으로 봤을 때 동일해 보여도, 두 값이 서로 다른 데이터를 참조하고 있기 때문에 서로 완전히 다른 참조를 하고 있는 것이다. 따라서 foo의 age가 50으로 바뀌어도, bar이 참조하는 데이터는 완전히 독립적인 다른 데이터이므로 영향을 주지 않는다. 마지막으로 원시타입은 이하와 같은 모양일 것이다. 123const foo = 20;// 이렇게 foo에 number 원시타입을 할당해주면, 이는 참조가 아니라 데이터를 직접 저장하는 방식을 취한다. 객체 요약이처럼, 객체는 키-값 쌍으로 이루어져 있으며, 참조 타입이다. 키-값 쌍에는 프로퍼티와 메소드가 할당될 수 있다. 그리고 자신을 참조하고 있는 다른 변수들은 자신의 데이터를 ‘참조’만 할 뿐, 그 데이터 값을 직접적으로 저장하여 활용하는 것이 아니다. 따라서 참조값이 변하면 변수들은 변경된 참조값을 동일하게 참조하게 된다. 그럼 이제 객체가 무엇인지 이해했으니, 함수가 왜 객체인지에 대해서 이해해보도록 하자. 함수가 왜 객체인가? 정확히 말하면 “함수 객체”다.함수 객체는 기본적으로 객체의 기본적인 기능들을 사용할 수 있을 뿐만 아니라, 함수 객체만의 고유한 프로퍼티와 메소드들이 존재한다. 즉, 함수객체는 기존 객체에서 조금 더 확장된 개념이라고 봐도 될 것 같다. 객체의 내부 슬롯과 내부 메소드, 그리고 이에 더해 함수 객체만의 [[Envorinment]], [[FormalParameters]] 라는 내부 슬롯 + [[Call]], **[[Constructor]]**같은 내부 메소드도 추가적으로 보유하고 있기 때문이다. 글로만 봐서는 이해하기가 어렵기 때문에 아래의 사진들과 함께 훑어 내려가보도록 하자. 위의 코드의 실행이 정상적으로 되는 이유가 뭘까..? 분명 test는 함수고, Function의 프로토타입에도 hasOwnProperty라는 메소드는 없다. 즉, test에는 존재하지 않는 메소드가 오류 없이 실행된 것이다. 위 사진에서도 볼 수 있듯, hasOwnProperty는 Object 프로토타입에만 존재한다. 함수에서도 이 메소드의 사용이 가능한 이유는 결국 Function 프로토타입의 __proto__가 Object의 프로토타입과 연결되어 있기 때문이다(프로토타입 체인). 이를 쉽게 설명하자면, test의 프로토타입인 Function에 hasOwnProperty가 없기 때문에 한 단계 더 위의 프로토타입인 Object 프로토타입 객체에서 메소드를 끌어온 것이다. 즉, 함수 상위에는 객체가 존재한다. 함수는 객체에 포섭된다! 함수의 조상은 객체다. 콘솔창에 직접 Function.prototype.__proto__를 찍어보면 위와 같은 결과가 나올 것이다. Function의 프로토타입이 참조하고 있는 것은 결국 객체고, 이 Function은 객체로부터 파생된 것이라고 볼 수 있다. 이를 증명하는 것이 바로 constructor다. Function은 결국 Object()라는 생성자 함수에 의해 생성된 것이고, 이는 Function이 Object 프로토타입으로부터 메소드와 프로퍼티를 상속받을 수 있음을 의미한다. 그리고 함수 객체는 아래와 같이 자신만의 고유한 프로퍼티와 메소드를 보유한다. apply, bind, call은 이전에 this에 대한 포스팅을 했을 때 다뤘던 메소드들이다. 그리고 이외에도 함수는 length와 name과 같은 함수만의 프로퍼티도 보유한다. 함수 요약정리하자면, 함수는 하나의 객체다. 그리고 이러한 함수는 Object로부터 파생 된 것인데, 이러한 특성 덕분에 함수는 Object 프로토타입으로부터 메소드와 프로퍼티를 상속받을 수 있다. 그리고 객체의 기본적인 기능 이외에도 함수만이 갖는 apply, bind, length, name 등 고유의 프로퍼티와 메소드를 보유한다. 따라서 함수는 객체인 것이다. 뭐 이제 함수가 객체라는 것은 어느 정도 감이 잡혀가는 것 같다.근데 더 알아야 할 것이 있다. 자바스크립트에서 함수는 그냥 객체가 아닌 ‘1급 객체’라는 것이다. 자바스크립트에서의 함수는 “일급 객체”다. 쉽게 말해, 일등 시민과 비슷한 맥락이라 봐도 된다. 일급객체는 일급시민과 같이 누릴 수 있는 권리와 자유도가 굉장히 높다. 이러한 일급 객체가 되기 위한 조건은 크게 총 세 가지다. 데이터 구조 또는 변수에 할당될 수 있다. (+무명의 리터럴로 표현 가능) 파라미터로써 어딘가에 전달될 수 있다. 리턴 값으로써 사용될 수 있다. 함수가 데이터 구조 또는 변수에 할당되는 경우. 바로 코드로 설명해도록 하겠다. 12345678910// 변수에 함수가 할당됐다. + 무명의 리터럴로 함수명이 생략된 모습let someFunction = function(){};// 배열 안에 함수가 삽입됐다.const arr = ['javascript', 'react', someFunction];// 객체 안의 메소드로써 사용될 수 있다.const obj = { someFunction: function(){};}; 함수가 파라미터로 활용되는 경우1234567891011// 일반적인 함수의 선언function someFunction() { return 'Hello';}// 함수를 매개변수로 활용하는 또 다른 함수.function takeFunction(func) { return func();}console.log(takeFunction(someFunction)); // Hello 함수가 리턴값으로써 활용되는 경우1234567891011function aboutMySelf() { const name = 'hoon'; return function () { return `my name is ${name}!`; };}// 리턴값으로 함수를 받아준다.const func = aboutMySelf();// 그리고 그 함수를 실행시킨다.console.log(func()); // my name is hoon! 이처럼 자바스크립트에서 함수는 굉장히 자율성이 높다. 어디든 끼어들 수 있고, 어디서든 자유롭게 활용될 수 있기 때문이다. 이러한 이유 때문에 함수가 1급 객체 라고 불리는 것이다. 함수가 인식되는 과정 마지막으로 짚고 넘어가야할 것이 있다.콘솔창에 typeof 함수를 찍으면, object가 아닌 function이 반환된다는 것이다. 진짜 뭔 소린가 싶다. 위에서 실컷 “함수는 객체다. 함수는 객체다” 노래를 불렀는데.. 함수가 함수로 찍힌다니? 보이다시피, func 함수의 타입이 function으로 반환되는 모습이다. (물론 타입만 function으로 ‘인식’되는 것이지, 함수의 실제 자료형은 객체가 맞다) 왜 자바스크립트는 function의 타입을 객체가 아닌 함수로 인식하는 것일까? [[Call]] : 호출이 될 수 있는가 vs 없는가 호출될 수 있는 객체는 function으로, 없는 것들은 모조리 object로 인식한다는 것이 핵심이다.이는 아래에서 다루겠지만, 호출될 수 있는 객체는 callable이라고 표현한다. 우선 호출, 표현, 선언, 생성자, 화살표함수 라는 ‘함수 정의’의 개념부터 확실히 학습하고 넘어가보도록 하자. 이는 callable을 이해하는데 핵심적이기 때문이다. 위 네가지 함수 정의를 통해 (함수)객체는 [[Call]] 이라는 메소드를 보유하게 되고, 객체는 callable한 객체가 되어 함수로써 인식된다. 123456789101112131415// 함수 선언문function sayHello() { return 'Hello';}// 함수 표현식const sayHello = function () { return 'Hello';};// 생성자 함수 사용const guest = new sayHello();// 화살표 함수 사용const sayHello = () =&gt; {}; 즉, 위와 같이 우리가 알고있던 방식들로 함수를 정의하면, 해당 객체(함수)는 [[Call]] 메소드를 보유하게 되면서 함수로 인식된다. 하지만 이 부분이 조금 직관적으로 이해가 되지 않아서 ECMAScript를 찾아봤다. 해당 문서에서는 [[Call]] 내부 메소드를 보유한 객체는 곧 함수 객체이며, 함수가 호출될 때 이 [[Call]] 내부 메소드가 작동하는 것이라 설명하고 있다. 즉 이렇게 [[Call]] 내부 메소드를 보유하며 호출할 수 있는 객체를 함수 객체라고 정의할 수 있으며, 이는 곧 함수라고 통칭된다. ([[Call]]이 더 궁금하다면 ? ECMAScript-262) 함수가 정의되면 [[Construct]] 메소드를 보유하는 함수 객체로 생성된다. 이 [[Construct]] 을 통해 자바스크립트는 함수를 object가 아닌 function으로 인식하는 것이다. 자, 이제 확실히 정리가 된 것 같다. 함수 객체는 호출될 수 있는 객체고, 그 외의 객체들은 호출될 수 없는 객체다. [[Construct]] : 생성자인가 vs 아닌가 진짜 마지막이다.함수 객체가 갖는 고유의 메소드 중에 중요한 마지막 하나는, [[Construct]] 다. ECMAScript에서는 [[Construct]] 에 대해 이렇게 설명한다. new 또는 super를 통해 함수가 호출될 때 [[Construct]] 메소드가 호출되며 실행된다. 하지만 이러한 [[Construct]] 메소드가 존재하지 않는 함수 객체도 있는데, 이를 non-constructor 함수 객체라고 부른다. constructor vs non-constructor의 구분은 굉장히 간단하다. 화살표 함수와 메소드만 non-constructor다. 12345678910// 화살표 함수const apple = () =&gt; {};// 메소드const obj = { tomato() {},};//Uncaught TypeError: apple is not a constructorconst foo = new apple();const bar = new obj.tomato(); 이전 포스팅에서 Prototype에 대해서 다뤘을 때, constructor의 지위가 있는 함수만 생성자 함수가 될 수 있다고 했었다. 이처럼 모든 함수가 생성자(constructor)의 자격이 있는 것은 아니다. 정리 및 요약 포스팅 제목과 같다.”모든 함수는 객체지만, 모든 객체가 함수인 것은 아니다” 자바스크립트에서 함수는 객체다. 특히, Object라는 최상위 프로토타입으로부터 파생된 객체다. 함수 객체는 일반 객체의 기본 기능 이외에도, [[Call]], [[Construct]], apply, bind, call, length, name 과 같은 함수 객체만의 프로퍼티와 메소드를 보유한다. 그리고 Function이 참조하는 프로토타입을 확인해보면, Object가 반환된다. 이는 함수 객체가 Object 프로토타입으로부터 생성된 것이라는 것을 증명한다.","link":"/javascript/base/whyFunctionsAreObj/"},{"title":"Wesbos - Drum Kit","text":"키보드를 누르면 해당 키값에 맞는 드럼 사운드가 재생되는 간단한 웹페이지다.우선, 각 키를 눌렀을 때 기능해야하는 것들 + 웹페이지 작동 원리와 로직은 이하와 같다! 로직 키보드를 눌렀을 때? 해당 키값 찾기 (keyCode) 해당 오디오 태그 값 찾아서 play 연타 가능하도록 Currenttime = 0으로 설정 css 적용 (.playing 삽입) 적용된 css 제거하며 역트랜지션 구현 가능하도록 구현 코딩 과정1. 해당 키값 찾기 (keyCode) 각 키보드에는 고유한 키값이 존재한다.http://keycode.info/ 이곳에 들어가 각 키값(keyCode)들을 알아보자. html파일에서 key블록을 구성하고 있는 div에 data-key = “nn”형식으로 키값을 부여한다. 123&lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;kbd&gt;&lt;/div&gt; 참고로 본인은 기존에 설정 되어있던 [a-s-d-f-g-h-j-k-l] 배열이 불편하다 생각이 들어 오투잼 배열로 키보드 배열을 변경했음. (div와 audio 태그 내의 data-key만 변경해주면 쉽게 변경 가능!) 완료했다면, JS파일로 돌아가 keys라는 변수를 querySelectorAll을 통해 지정해준다. 1const keys = document.querySelectorAll('.key'); 이제 키보드를 눌렀다는 event를 컴퓨터가 감지할 수 있도록 addEventListener를 통해 keydown 이벤트에 반응하는 함수를 만들어준다. 1window.addEventListener('keydown', keydown); forEach 💡 배열에 사용되는 함수! 편리하게도 배열의 각 요소에 대한 callback 함수를 적용할 수 있음 123456//예시const array1 = ['가', '나', '다'];array1.forEach((element) =&gt; console.log(element));// 예상 아웃풋: &quot;가&quot;// 예상 아웃풋: &quot;나&quot;// 예상 아웃풋: &quot;다&quot; 이제 위에서 설정한 keydown 이벤트를 들을 수 있는 keydown함수를 작성해준다. 그리고 console.log를 통해 누른 키에 해당하는 keyCode값을 콘솔 창에 찍어보자. 123function keydown(e) { console.log(e.keyCode);} 2. 키 값을 활용해 audio를 play audio에 입력된 data-key와 입력된 키의 keyCode가 상호 연결되어,입력된 키에 해당하는 audio만 재생이 돼야 한다. ⇒ 따라서, audio를 따로 변수처리 해서 해당 오디오 파일을 재생시켜줘야 함 12345678const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);// 이렇게 e.keyCode를 변수화 하여 audio에 대입시키면 audio는 특정 audio,// 즉 눌러진 키에 해당하는 사운드만 플레이 될 수 있도록 지정할 수 있는 것!audio.play();//이제 play함수를 적용시키면 눌려진 키 값에 해당하는 사운드만 재생되는 것을 확인 할 수 있다. 3. currentTime을 활용한 연타 기능 추가 But… 키값에 맞는 오디오가 잘 플레이 되기는 하지만, 키를 연속적으로 눌러도 한 사운드의 재생이 끝날 때 까지 다음 키의 재생이 이루어지지 않는 것을 확인할 수 있다. ⇒ 따라서 currentTime을 활용해 키가 연속적으로 눌렸을 때 이에 즉각적으로 play() 함수가 반응되도록 해보자. 123456function keydown(e) { console.log(e.keycode); //이제는 필요 없는 코드 const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`); audio.currentTime = 0; audio.play();} currentTime currentTime은 HTML 내의 태그를 제어하기 위한 메소드다. currentTime = n; 을 통해 특정 수를 부여하면 audio는 해당 숫자에 해당되는 초로 이동한다.이에 따라, 위에서와 같이 currentTime=0; 을 사용하게 되면어떤 키가 눌렸을 때 해당 audio의 현재 플레이 위치는 0이 되는 것이다.즉, “재생이 정지된 것과 같은 효과 ⇒ 그에 따른 연타 가능”의 기능이 적용될 수 있는 것! 4. CSS 적용! 이제 CSS 적용만 하면 된다 :)audio에서 적용했던 논리와 동일하게 내가 누른 키에 해당하는 에만 css가 적용되도록 하면 됨! 123const key = document.querySelector(`.key[data-key=&quot;${e.keyCode}&quot;]`);key.classList.add('playing'); //미리 작성해둔 css 클래스를 적용 하지만…. 위의 코드만으론 css가 “적용”되기만 할 뿐, 키보드를 떼었을 때 css가 제거되지는 않는다. 5. 역트랜지션 구현 위의 키보드 div들의 .playing CSS의 적용과 트랜지션이 끝났을 때 곧바로 CSS가 제거되도록 코드를 짜주면 된다. 123456keys.forEach((key) =&gt; key.addEventListener('transitionend', transitionRemove));function transitionRemove(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing'); //transition이 끝난 div들의 playing css는 모두 제거된다.} 이제 모든 필요 기능들에 필요한 코드를 다 짰다. 아래는 그에 따른 최종 완성 코드다 :) 최종 완성 코드12345678910111213141516171819function playsound(e) { const key = document.querySelector(`.key[data-key = &quot;${e.keyCode}&quot;]`); const audio = document.querySelector(`audio[data-key = &quot;${e.keyCode}&quot;]`); if (!audio) return; //반드시 필요한 것은 아니지만, audio의 data-key에 해당하지 않는 키값이 입력됐을 때 함수가 종료되도록 //위와 같은 코드를 추가했음! audio.currentTime = 0; audio.play(); key.classList.add('playing');}function removeTransition(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach((key) =&gt; key.addEventListener('transitionend', removeTransition));window.addEventListener('keydown', playsound);","link":"/javascript/wesbos/01.%20Drum%20Kit%20/"},{"title":"Wesbos - Clock","text":"CSS와 JS를 이용해 아날로그 시계를 구현해보는 챕터다.시침 분침 초침이 시간에 따라 움직이도록 하려면 어떻게 해야할까? 로직시간이 변할 때 시간이 지날 때마다 침들의 deg에 변화를 준다. (rotate) = 1초, 1분, 1시간을 기준으로! = 각도는 360도를 기준으로! 침이 움직일 때 (CSS) = transition 효과를 줘서 실제 시계 침의 움직임과 유사하도록 구현 (째깍째깍의 느낌) 코딩 과정1. 초침, 분침, 시침을 지정해주자123const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand'); 그렇다면….. 시간의 흐름을 어떻게 get하고 표현해야할까? 2. 현재 시, 분, 초를 불러오기현재 시,분,초에 따라 침들의 각도가 달라져야 하기 때문에, 시분초를 불러오는게 가장 먼저 해야 할 일 ! Date(), getHours(), getMinutes(), getSeconds() 👉 new Date()를 통해 현재 년월일 시분초를 불러올 수 있다. 이후, Date 내에서 getOOO을 통해 시 분 초를 골라서 사용할 수 있음 ! 123456function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds();} 3. 현재 시, 분, 초에 따른 침들의 각도 지정하기! 👉 transform = rotate(OOdeg); 를 활용 ! 123456const secondsDegrees = (seconds / 60) * 360 + 90;secondsHand.style.transform = `rotate(${secondsDegrees}deg)`;const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90;hoursHand.style.transform = `rotate(${hoursDegrees}deg)`;const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90;minutesHand.style.transform = `rotate(${minutesDegrees}deg)`; 4. setInterval을 활용한 함수의 주기적 실행 👉 현재 시간에 따라 침이 변화해야 하는데 setInterval( ) 을 추가하지 않을 시 위의 setDate( ) 함수는 한번밖에 실행되지 않아 시계가 멈춰있게 된다. setInterval() 👉 일정한 시간 간격을 기준으로 특정 코드블록을 반복 실행할 수 있도록 하는 함수 setInterval(실행할 함수 이름, 시간 간격 기준) 단, 시간 간격은 ms가 기본 단위이다 (1000에 1초) 12setInterval(setDate, 1000);//1초에 한번씩 setDate함수를 실행하겠다는 뜻 최종 완성 코드123456789101112131415161718const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand');function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds(); const secondsDegrees = (seconds / 60) * 360 + 90; secondsHand.style.transform = `rotate(${secondsDegrees}deg)`; const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90; hoursHand.style.transform = `rotate(${hoursDegrees}deg)`; const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90; minutesHand.style.transform = `rotate(${minutesDegrees}deg)`;}setInterval(setDate, 1000);","link":"/javascript/wesbos/02.%20Clock/"},{"title":"Wesbos - Variable CSS","text":"로직 스크롤 → 해당 라벨의 이동값 선택 → 해당 값이 css variable에 적용 → 뒤에 suffix값 붙여넣기 CSS의 변수화 👉 CSS에서의 Variable control은 이하와 같이 표현 12345:root { --속성 : 값};//:root는 최상위 엘리먼트를 의미한다. (HTML) setProperty() 👉 설정, 2개의 인자 (속성,값) 1document.documentElement.style.setProperty(속성, 값); documentElement 👉 html 안의 모든 요소를 말한다 최종 코드 123456789101112const inputs = document.querySelectorAll('.controls input');function handleUpdate() { const suffix = this.dataset.sizing || ''; document.documentElement.style.setProperty( `--${this.name}`, this.value + suffix );}inputs.forEach((input) =&gt; input.addEventListener('change', handleUpdate));inputs.forEach((input) =&gt; input.addEventListener('mousemove', handleUpdate)); 1font-family: 'helvetica neue', sans-serif;","link":"/javascript/wesbos/03.%20Variable%20CSS/"},{"title":"Wesbos - Flex Box","text":"box-sizing 🔥 박스 크기의 기준을 어떤 것으로 설정할 것인가? content-box : 오로지 콘텐트 요소만 포함 (기본값) border-box : 콘텐트 + 보더 + 패딩 값을 모두 포함 inherit : 부모 요소로부터 상속 12345// 대부분의 개발자들은 border-box를 기본값으로 설정해두고 코딩을 함*{ box-sizing : border-box;}; justify-content와 align-items 🌸flex-basis와 flex-grow flex-basis = flex item의 기본 크기를 설정함 ! (direction이 row면 너비, column이면 높이) flex-grow = item이 basis값보다 커질 수 있는지 설정! (기본값은 0, 유연하게 늘어날 수 있도록 설정은 1) 123456// 비율 놀이라고 생각해도 편함 !.item:nth-child(1) { flex-grow: 1;}.item:nth-child(2) { flex-grow: 2;}.item:nth-child(3) { flex-grow: 1;}// 이럴 경우 1: 2: 1 비율로 컨테이너 안에서 크기가 형성됨 축약 속성 🔥 flex : grow, shrink, basis; Flex-container와 Flex-items? 🔥 Container는 아이템을 담는 박스라고 생각하면 되고,item은 개별 객체들이라고 보면 됨 ! // container에 display=flex를 주고, items에는 items에 쓸 수 있는 기능들이 따로 있음 flex-basis 🔥 flex를 적용할 경우, item들은 컨텐츠에 맞게 넓이가 설정되는데 basis값을 줄 경우 기본 넓이값이 설정된다. 만약 flex-basis를 100px로 줬는데 아이템 안에 컨텐츠가 100px보다 크다면 컨텐츠 값에 맞게 늘어난다. 즉, 컨텐츠 길이가 basis값보다 작으면 아이템은 basis에 맞춰서 크기가 설정됨 ! flex-grow (유연하게 늘리기) 🔥 flex-basis가 갖는 영역을 제외한 여백의 비율을 지정.기본값 = 0 flex-shrink (유연하게 줄이기) 🔥 flex-basis보다 크기가 줄어들 수 있는가 ?기본값 : 1 만약, 0으로 값을 설정하면 고정값으로 설정돼 basis의 크기가 고정값으로 지정된다.** 최종 완성 코드12345678const panels = document.querySelectorAll('.panel');function clicked() { this.classList.toggle('open'); this.classList.toggle('open-active');}panels.forEach((div) =&gt; div.addEventListener('click', clicked));","link":"/javascript/wesbos/05.%20Flex%20Box/"},{"title":"Wesbos - Array Cardio_1","text":"✅ 모든 언어에서 필수적으로 다뤄야 하는,그리고 굉장히 중요한 영역인 배열을 다루는 챕터였다. 기본 사항 이번 챕터에서 다룬 주요 배열 함수들은 순서대로filter(), map(), sort(), reduce()다. Javascript에서 배열 = [] 객체={}로 표현한다.객체는 {key : value}가 기본 형태 🙂 console.log 외에도 console.table(), console.dir() 등을 활용해볼 수도 있다. table()은 표 형태로 콘솔창에 출력되고,dir()은 해당 객체의 property들이 출력된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 주어진 배열const inventors = [ { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 }, { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 }, { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 }, { first: 'Max', last: 'Planck', year: 1858, passed: 1947 }, { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 }, { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 }, { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 }, { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 }, { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 },];const people = [ 'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig', 'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving', 'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano', 'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose', 'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank',]; filter() 🔥 array.filter()를 통해 기존 배열을 조건에 맞게 새로운 배열로 반환할 수 있다. 실행결과123//filter를 활용하여 inventors 배열 내에서 &quot;1500년도에 태어난 inventor만&quot;을 새 배열로 추출해보시오.const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year =&lt; 1599));console.table(fifteen); map() 🔥 array.map()를 통해 배열 내의 데이터를 **”콜백함수”**에 맞게 새로운 배열로 반환! filter와 map의 차이점? filter는 조건!map은 콜백(CallBack)함수! ⇒ 이처럼, filter는 콜백함수에 반응하지 앉고 map()만 콜백함수가 조건으로써 적용될 수 있다.쉽게 생각하면, filter()는 if가 사용되는 배열함수라고 생각하면 될 것 같다. 실행결과123456//map() 함수를 사용해서 invertor들의 성과 이름을 통해 Full Name이 담긴 새 배열을 만들어보시오.const fullNames = inventors.map( (inventor) =&gt; `${inventors.first} ${inventors.last}`);console.table(fullNames); sort() sort()의 기본형은 글자순으로 자동정렬 or 숫자(앞자리 기준) 기준으로 자동정렬이다. 하지만, 우리가 이번 챕터에서 사용하는 sort()함수는 Compare Function. 즉, 비교 함수로써의 sort()다. Compare Function으로써의 sort() 🔥 array.sort(a,b)를 통해 a와 b를 비교해 “오름차순 또는 내림차순” 정렬 방식을 정하여 반환 123array.sort((a, b) =&gt; (a.value &gt; b.value ? 1 : -1));// 즉, a값이 b보다 크면 아래로 내리고, 그 반대라면 작은 것을 위로 올리겠다는 뜻 !// 0 또한 지정해줄 수 있는데, 이는 a와 b가 같은 값일 때를 의미한다. 실행결과123456// sort()를 활용하여 inventors를 나이에 대한 내림차순으로 정렬해보시오.const orderByBirth = inventors.sort((a, b) =&gt; (a.year &gt; b.year ? 1 : -1));// True라면 1이 부여되어 비교대상보다 위로 올라간다. (모든항 비교해 점수매기기라고 생각해도 될듯)console.table(orderByBirth); reduce() 🔥 array.reduce(리듀서 함수, 현재값) ⇒ 리듀서 함수를 실행하여 하나의 결과값을 반환한다. 1234array.reduce((total, currentValue) =&gt; { return total + currentValue;}, 0);// total의 초기값은 0, 이후 currentValue에 부여한 수식이 루프되어 총합이 계산된다. 실행결과1234567// reduce()를 활용하여 inventors의 나이를 모두 합한 결과값을 반환하시오.const sumOld = inventors.reduce((sum, inventor) =&gt; { return sum + (inventor.passed - inventor.year);}, 0);//여기서 0은 initialValue를 의미하는데, 가장 처음 루프 때 sum의 값이라고 생각하면 된다.","link":"/javascript/wesbos/04.%20Array%20Cardio1%20/"},{"title":"Wesbos - Type Ahead (동적 검색)","text":"💡 앞으로 개발을 하다보면 자주 사용하게 될 것 같은 동적 검색창이다.사실 Wes Bos 30일 챌린지를 진행하면서 근 6회차 중에 가장 어려운 챕터였던 것 같다…. 로직 json파일 불러오기 json파일을 새로운 배열 형태로 생성 (fetch) 검색어 찾기 기능 (“찾기”) 검색어에 해당하는 cities 나타내기(display) 1. json파일 불러오기 💡 json 주소 주소에 저장돼있는 json 형식의 city 파일 1234//이 json 파일 주소를 const를 통해 endpoint라는 값으로 지정!const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json'; ❓ 하지만, 여기까지는 아직 주소값만 지정해준 것이기 때문에,이 json파일을 배열로써 나타나게 해줘야 한다. 12// 우선 cities라는 빈 배열을 만들어주자const cities = []; ⭐ 그렇다면, 이제 어떻게 저 주소로부터 city 값들을 불러들여올 수 있을까? =&gt; fetch API를 사용하면 된다 ! fetch API💡 fetch는 서버에 네트워크 요청을 할 수 있도록 도와주는 AJAX기반의 API다. 💡 fetch(접근하고자 하는 url, 옵션)then.() == 호출에 성공했을 때 응답객체를 resolve 즉, then은 fetch에 대한 응답형태 및 방식이라고 보면 된다. 123456//우선, 나는 json 주소를 endpoint로 지정해뒀으니까 주소 대신 변수명을 넣어준다.fetch(endpoint) //Blob은 타입이 존재하는 바이너리 객체! .then((Blob) =&gt; Blob.json()) //이제 이 json 데이터를 위에서 생성한 cities 배열에 push 해주면 기본적인 세팅은 끝! .then((data) =&gt; cities.push(...data)); fetch(endpoint)를 통해 Promise가 resolve됐음 Blob형태의 json 값들이 배열로 반환됨 검색을 통해 해당하는 city 찾기! ❓ 일단 findMatches라는 함수를 생성할건데,filter 조건 내에서 검색창에 입력될 글자는 매번 다를 것이므로 이를 어떻게 변수화 할지가 관건이다.이것을 해결해줄 기능이 바로 “**RegEXP와 match()”**다. RegExp 🔥 정규표현식 = 문자검색, 문자 대체, 문자추출에 주로 사용 new RegExp(표현식, 플래그) match() 🔥 정규표현식에 맞는 문자열을 찾아서 배열 객체**(문자열 형태)**로 반환한다. 12345678function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { // 모든 문자와 여러줄을 영어 대소문자를 구분하지 않고 받아들임 const regex = new RegExp(wordToMatch, 'gi'); // &quot;||&quot;은 or을 뜻한다는 점 복기! return place.city.match(regex) || place.state.match(regex); });} 검색어에 해당하는 city or state 나타내기 💡 우선, 검색창과 검색결과가 보여질 html 요소를 정의해주고,addEventListener를 통해 변화에 따른 함수 실행을 설정하자 1234567// html 요소 정의const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');// addEventListener 사용searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches); displayMatches12345678910111213141516171819202122232425function displayMatches() { // 검색창에 입력된 글을 변수화! const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { // 각 값들에 대한 정의 const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';console.log(endpoint);const cities = [];fetch(endpoint) .then((Blob) =&gt; Blob.json()) .then((data) =&gt; cities.push(...data));function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { const regex = new RegExp(wordToMatch, 'gi'); return place.city.match(regex) || place.state.match(regex); });}function displayMatches() { const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);}const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches);","link":"/javascript/wesbos/06.%20Type%20Ahead/"},{"title":"Wesbos - Dev Tools (개발자 도구)","text":"Interpolated'hello %s', 'hoonjoo' 12console.log(&quot;hello my name is %s What's your name?&quot;, 'hoonjoo');// 결과값 : hello my name is hoonjoo What's your name? Styled12345// CSS를 컨트롤 할 수도 있다!console.log( '%c I can change my style by this', 'font-size : 50px; color : #BADA55'); warning 12// 콘솔 창에 경고 표시를 할 수 있음console.warn('stop'); error 12// 콘솔 창에 오류 표시를 할 수 있음console.error('stop'); Info1console.info(''); Testing1assert(1 === 1, 'That's Wrong!') Cleaning1console.clear(); Grouping Together123456789dogs.forEach(dog ⇒ {console.group(``${dog.name}``)console.log(`${dog.name} is ${dog.old} years old`)console.groupEnd(`${dog.name}`);}); count1console.count(); time12// 불러오는데 얼마나 걸리는지?console.time();","link":"/javascript/wesbos/09.%20Dev%20Tools/"},{"title":"[Wesbos] 배열 기초체력 다지기2","text":"이번 챕터에서 다룰 기능들 array.some() array.every() array.find() array.findIndex() 주어진 배열1234567891011121314const people = [ { name: 'Wes', year: 1988 }, { name: 'Kait', year: 1986 }, { name: 'Irv', year: 1970 }, { name: 'Lux', year: 2015 },];const comments = [ { text: 'Love this!', id: 523423 }, { text: 'Super good', id: 823423 }, { text: 'You are the best', id: 2039842 }, { text: 'Ramen is my fav food ever', id: 123523 }, { text: 'Nice Nice Nice!', id: 542328 },]; some() 💡 배열 안에서 “특정” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 1234// 최소 한명이라도 19살 이상인 사람이 있는가?const isAdult = people.some(person =&gt; ((new Date()).getFullYear() - person.year &gt;= 19);console.log(isAult); every() 💡 배열 안에서 “모든” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 123456// 모든 사람들이 19세 이상인가?const isEvery = people.every( (person) =&gt; new Date().getFullYear - people.year &gt;= 19);console.log({ isEvery }); find() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소값을 반환 123// ID가 823423인 사람이 쓴 comment는 무엇인가?const findID = comments.find((comment) =&gt; comment.id === 823423);console.log(findID); findIndex() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소의 index값을 반환 123456// ID가 823423인 사람이 쓴 comment를 삭제하시오.const index = comments.findIndex((comment) =&gt; comment.id === 823423);const newComments = [...comments.slice(0, index), ...comments.slice(index + 1)];console.table(newComments);","link":"/javascript/wesbos/07.%20Array%20Cardio2/"},{"title":"Wesbos - Fun with Canvas","text":"🙂 사실 그렇게 자주 사용할것 같지는 않지만, 배워두면 좋을 것 같은 ..?Javascript를 이용한 그리기 도구 기능 구현 챕터다 로직 canvas태그를 통해 그림판을 브라우저에 깔아준다 canvas의 개념적 정의를 ‘2d’로 설정한다 : canvas.getContext(‘2d’) canvas에 이벤트리스너를 부여한다. 캔버스 내에서 마우스 움직임에 따라 그림이 그려질 수 있도록 ctx설정을 한다 (그리기 속성과 위치값 설정) 그림판 깔기canvas 태그 💡 &lt;canvas&gt;&lt;/canvas&gt;와 같은 형태로 쓰이며, id값을 부여해 사용해주는 것이 바람직하다. canvas태그에 id값을 #draw로 부여해뒀다. 이를 활용! 12345const canvas = document.querySelector('#draw');//그림판 캔버스가 브라우저 전체 크기를 차지할 수 있도록 설정canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas태그 불러오기 및 기본설정 (렌더링 컨텍스트) 💡 canvas만 브라우저에 펼쳐져 있다고 그림을 그릴 수 있는게 아니다. **getContext()**를 통해 렌더링 컨텍스트까지 canvas에 노출시켜줘야그리기 함수나 렌더링 컨텍스트 등을 활용할 수 있다. 그리기 도구를 지정해준다고 생각하면 이해하기 편할 것이다. 1const ctx = canvas.getContext('2d'); 이벤트리스너 적용 및 함수 생성 💡 canvas가 이벤트를 감지할 수 있도록 addEventListener와 그에 따른 함수를 생성해줘야 한다. 12//마우스의 움직임을 감지canvas.addEventListener('mousemove', draw); 💡 이제 draw함수를 생성해보자 ! 12//일단 만들어만 놓자function draw() {} ctx를 통한 그리기 속성 세팅 💡 그림을 그려야하기 때문에, 먼저 그리기 도구들을 세팅해주자 ctx세팅을 위한 함수 및 기능들은 아래 표에 정리해두었다. 1234ctx.strokeStyle = '#BADA55';ctx.lineCap = 'round';ctx.lineJoin = 'round';ctx.lineWidth = 50; ctx를 통한 위치값 설정 및 그리기 기능 구현 💡 거의 다 왔다….. 이제 그림을 그릴 수 있도록 xy 좌표값과 그에 해당하는 기본 변수값들을 지정해줘야 한다. 123456789101112131415//마우스를 클릭한 상태로 움직였을 때만 그리기가 가능하도록 isDrawing을 설정해줬다.let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { //마우스를 뗀 상태라면 그려지지 않는다 if (!isDrawing) return; ctx.beginPath(); //새로운 경로가 생성된다. ctx.moveTo(lastX, lastY); //마우스가 눌린 시점의 x,y의 좌표가 입력될 것이다. ctx.lineTo(e.offsetX, e.offsetY); //마우스가 이동한 위치의 좌표가 입력될 것이다. ctx.stroke(); //도형(선 포함)이 그려진다. //마우스 움직임에 따라 lastX와 lastY값 지속적으로 변동 [lastX, lastY] = [e.offsetX, e.offsetY];} 123456789//마우스를 눌렀을 때 x와 y값이 입력되도록 설정!canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});//마우스가 눌려있지 않은 경우에 그리기를 실행하지 않기 위한 설정canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false)); offsetX &amp; offsetY 💡 offsetX : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “x좌표” 위치를 나타냄 offsetY : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “y좌표” 위치를 나타냄 최종 완성 코드123456789101112131415161718192021222324252627282930313233const canvas = document.querySelector('#draw');const ctx = canvas.getContext('2d');canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = '#BADA55';ctx.lineJoin = 'round';ctx.lineCap = 'round';ctx.lineWidth = 50;let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { if (!isDrawing) return; ctx.beginPath(); ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.moveTo(lastX, lastY); ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke(); [lastX, lastY] = [e.offsetX, e.offsetY];}canvas.addEventListener('mousemove', draw);canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false));","link":"/javascript/wesbos/08.%20Fun%20with%20Canvas/"},{"title":"Wesbos - 코나미 코드","text":"코나미 코드…? 💡 게임이나 웹사이트 내에 개발자가 숨겨둔 “이스터에그” 같은 것이라고 생각하면 된다. 로직 키보드 입력을 감지할 이벤트리스너 + 함수 생성 배열 생성하기 특정한 문자열이 입력됐을 때 이스터에그 발생되도록 설정 이벤트리스너 💡 이 부분은 쉽다.**’keyup’**을 listen할 수 있도록 설정하고 그에 따른 함수를 생성해보자 1234567// 'keyup'을 감지해야 할 것은 window 전체!window.addEventListener('keyup', easterEgg);// 키가 잘 찍히는지 콘솔창을 통해 확인해보자function easterEgg(e) { console.log(e.key);} 잘 된다!! 배열 생성 💡 내가 입력한 키값들이 저장될 수 있도록 배열을 활용해보자. 12345678910const pressed = [];// 배열에 잘 저장되는지 테스트도 해보기!function easterEggg(e) { pressed.push(e.key); console.log(pressed);}//근데... 무한으로 배열에 키가 저장되면 비효율적이니까 MAXIMUM 길이를 정해주자. (splice 활용) 잘 된다! splice() ⭐ 배열의 기존 요소를 삭제, 교체, 추가 하며 배열의 내용을 변경할 수 있도록 하는 메서드! 123456//기본 문법array.splice(index, deleteCount, item);//deleteCount를 0으로 지정하면 insert!//item 지정하지 않으면 삭제만 수행함 시크릿코드 생성 💡 진부하지만… 일단 편의상 ‘hoonjoo’로…!! 1const secretCode = 'hoonjoo'; 이스터에그 실행 💡 배열에 ‘hoonjoo’가 포함된다면 이스터에그 실행되도록 할 것임! 1234567891011function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!'); //이건 그냥 자바스크립트에서 제공하는 플러그인인 것 같다. cornify_add(); }} 최종코드1234567891011121314const pressed = [];const secretCode = 'hoonjoo';function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!!'); cornify_add(); }}window.addEventListener('keyup', easterEggg);","link":"/javascript/wesbos/12.%20Konami/"},{"title":"Wesbos - Hold Shift Button to Check","text":"정말 자주 쓰일 것 같은 기능이다. 첫 번째 체크박스를 클릭하고 쉬프트를 누른 뒤아래에 있는 임의의 박스를 클릭하면 그 사이에 있는 체크박스들이 함께 체크된다. 네이버에서도 사용! 로직 체크박스를 변수화해 지정한다. (const) click 이벤트를 위한 addEventListener + 함수 생성 lastChecked와 inBetween을 선언하여 플래그값으로 활용 ⭐️ 체크박스 지정하기 💡 거의 가장 먼저 하는 것은 const를 통해 사용할 객체를 변수화 하는 것이다. 1const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]'); addEventListener + 함수 생성 💡 여기서 사용할 것은 click 이벤트다.이 챕터를 진행하기 전이었다면, keyCode를 활용해 keydown등의 이벤트를 사용했을텐데…‘e.shiftKey’를 사용할 수 있더라 0_0; 12345// 이벤트리스너checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));//함수 생성function checkIt(e) {} 플래그 활용 다른 것들은 어렵지 않은데…. 이 부분이 참 생소하고 어려웠다 ㅜㅜ lastChecked 💡 제일 최초로 체크된 박스를 저장하기 위한 플래그다. 12// Boolean값 없이 선언만 해준다let lastChecked; inBetween 💡 최초 체크박스와 쉬프트를 누른채 클릭한 체크박스 사이에 있는 박스들을 인식하기 위한 플래그! 12345678910111213141516171819function checkIt(e) { //사이에 있는 놈인가? false let inBetween = false; //만약 쉬프트키가 눌려져 있고, 현재 체크 박스가 체크됐다면? if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { // 방금 눌린 것 or 최초로 눌린 것 = inBetween 아님! if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } // inBetween이면 checked되게 하라 if (inBetween) { checkbox.checked = true; } }); } // 처음 눌린 놈! lastChecked = this;} 최종 완성 코드12345678910111213141516171819202122const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]');//lastChecked 변수를 부여let lastChecked;function checkIt(e) { //사이에 있는가? =&gt; 일단 false let inBetween = false; //여기서 e는 click 이벤트다, 그리고 this는 &lt;input type=&quot;checkbox&quot;&gt;임!! if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } if (inBetween) { checkbox.checked = true; } }); } lastChecked = this;}checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));","link":"/javascript/wesbos/10.%20Hold%20Shift%20Button%20to%20Check/"},{"title":"Wesbos - Custom Video Player","text":"사실 요즘은 자체적으로 이렇게 동영상 플레이어를 구현하는 것이 아니라,유튜브와 같은 플랫폼에 이미 업로드 되어있는 영상을 불러오는 형식을 더 자주 사용하기 때문에, 실용적인 챕터일까? 라는 생각을 하기도 했다. 하지만…JS를 통해 CSS적인 요소를 컨트롤 하는 부분과 valueChange를 하는 등의 연습은 큰 도움이 됐던 것 같다. 로직 다양한 객체들 const로 정의 이벤트 리스너 (재생버튼, 프로그레스바, 볼륨바, 속도바, 스킵버튼) 재생 기능과 CSS 제어 프로그레스바 구현 볼륨 컨트롤 구현 속도 설정 구현 스킵버튼 구현 Const!! 💡 이번 챕터에선 정의해줘야 할 객체들이 많다…. 1234567const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider'); 이벤트리스너 💡 구현해야 할 기능들이 많기 때문에… 이벤트 또한 역시나 많다… 123456789101112131415//재생&amp;일시정지 버튼toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);//비디오 뷰어 내에 있는 버튼과 프로그레스바video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);// 프로그레스바, 사운드, 속도 등등의 value값 제어를 위한 것ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));//스킵버튼skipButtons.forEach((button) =&gt; button.addEventListener('click', skip)); 재생과 버튼 업데이트 💡 재생 버튼을 누르면 재생이 되고, 버튼 아이콘도 변경되어야 한다. 필자는 if문을 쓰는게 더 쉽고 간편할 것 같아서…if문을 통해 재생 및 일시정지, 그리고 재생버튼 업데이트 기능을 구현해봤다. ❗ 재생버튼 뿐만 아니라, 유튜브와 같이 비디오 플레이어 화면을 클릭했을 때도 재생 또는 일시정지가 될 수 있도록 구현하기 위해 pause함수가 video와 toggle에도 작동할 수 있도록 이벤트리스너를 작성했다. 12345678910111213141516171819202122//puase함수function pause() { //비디오가 정지되어 있으면 플레이 if (video.paused) { video.play(); } //아니면 일시정지 else { video.pause(); }}function updateButton() { // 정지되어 있으면 재생 아이콘이, if (video.paused) { toggle.textContent = '►'; } // 재생중이면 일시정지 아이콘이 나타나도록 설정 else { toggle.textContent = '❚ ❚'; }} 그 외 기능들123456789101112131415161718// 볼륨과 속도바function valueChange() { //volume or playBackRate = this.value가 되는 것! video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;} 최종 완성 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider');function pause() { if (video.paused) { video.play(); } else { video.pause(); }}function updateButton() { if (video.paused) { toggle.textContent = '►'; } else { toggle.textContent = '❚ ❚'; }}function valueChange() { video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;}toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));skipButtons.forEach((button) =&gt; button.addEventListener('click', skip));let mousedown = false;progress.addEventListener('click', scrub);progress.addEventListener('mouseup', (e) =&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener('mousedown', () =&gt; (mousedown = true));progress.addEventListener('mousemove', () =&gt; (mousedown = false));","link":"/javascript/wesbos/11.%20Custom%20Video%20Player/"},{"title":"Wesbos - 배열 참조 vs 복사","text":"참조와 원본 간의 관계 num, string, boolean값들의 참조 변수는 앞에 선언된 것을 우선시한다. 12345678age = 100;age = age2;console.log(age, age2); // 100 100//하지만 여기서 age값을 바꿔주면age = 200;console.log(age, age2); // 200 100 이 결과값으로 도출된다. 하지만!!! 배열에선 다르다 💡 위에선 참조와 원본이 다르게 처리됐지만, 배열에선 참조를 변경 시 원본에 영향을 준다. 1234567const players = ['hoonjoo', 'chanjoo', 'jaeseong', 'hyobum'];const team = players;team[1] = 'saeeun';//team = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum'];//players = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum']; 그렇다면, 배열에서 원본에 영향을 주지 않고 참조를 변경하는 방법은 없을까? array.slice() 💡 앞에서 배웠던 것과 같이, slice()를 사용하면 배열의 복사본을 만든다. concat(array) 💡 [].concat(array)를 사용해서 빈 배열에 기존 배열을 합치는 식의 복사를 할 수도 있다. spread 💡 newArray = […orgArray]; 와 같은 방식을 사용할 수도 있다. Array.from() 💡 newArray = Array.from(orgArray); 복사와 원본 간의 관계object.assign() 💡 특정 객체를 “얕게” 복사함 object.assign({}, 복사할 객체) assign을 통해 복사를 할 경우,이는 얕은 복사이기 때문에 한 층에 대한 변경은 원본 배열 객체에는 영향을 주지 않는다! 하지만, 더 깊은 층에 대한 변경은 원본 배열에도 영향을 준다 예시123456789101112131415161718192021const hoonjoo = { name: 'hoonjoo', country: 'Korea', social: { twitter: '@hoon', instagram: '#hooonjooo', },};const second = object.assign({}, hoonjoo);// 이 경우 원본 배열에는 영향 주지 않음 (원본 : Korea, 복사본 : USA)second.country = 'USA';//하지만....// 이 경우 social의 층이 깊기 때문에 원본 배열에도 영향을 준다second.social.instagram = '$hooonjooo';//따라서 이 두 결과값은 동일하다hoonjoo.social;second.social; 그렇다면 딥 클론을 할 수 있는 방법은? 편법!!1const second = JSON.parse(JSON.stringify(hoonjoo));","link":"/javascript/wesbos/14.%20Array_Copy/"},{"title":"Wesbos - 스크롤 → 슬라이드인","text":"진~~~짜 유용하게 잘 쓰일 것 같은 챕터다.스크롤을 내리면 비어있던 이미지들이 위치에 맞게 슬라이드 인 되는 기능이다. 🤔 그동안은 클릭이나 키다운에 의한 이벤트 함수를 생성했었는데,이번 챕터에서는 스크롤한 위치에 따른 기능실행이라는 점이 신선했던 것 같다. 로직 const eventListener + 함수생성 offset값을 활용한 위치값 불러오기 const!1const slideIn = document.querySelectorAll('.slide-in'); 이벤트리스너와 함수12345function slide(e) { console.log(e);}window.addEventListener('scroll', slide); 하지만, 이렇게 둘 경우 너무 자주 함수(slide)가 실행되어 비효율적일 수 있다. 1234567891011121314151617181920//미리 입력되어 있던 debounce 함수 모듈을 활용해보자function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}//slide함수에 적용될 수 있또록 감싸주자window.addEventListener('scroll', debounce(slide)); offset 값을 활용! 💡 scrollY : 세로로 스크롤이 몇 px만큼 움직였는지 알 수 있음 💡 innerHeight : 현재 뷰포트의 세로값(px)을 알 수 있음 어느 위치를 기준으로 이미지가 슬라이드 인 되어야 할까? 🤔 이미지의 세로 중간 쯤 뷰포트 바텀라인이 도착하면 슬라이드인 되도록 하는 것이 자연스러울 것 같다. 💡 그럼 ! 일단 현재 얼마나 스크롤 됐는지에 대한 값을 불러오는 변수를 설정해주자. 얼마나 스크롤 됐는지?❗ 뷰포트 바닥을 기준으로 계산을 할 것이다. (상단 기준이면 scrollY만 있어도 됨) 123// 스크롤한 만큼의 Y값(px) + 뷰포트의 Y길이(px)const slideAt = window.scrollY + window.innerHeight;console.log(slideAt); 이미지의 바닥 위치12// 떨어진 거리 + 이미지박스 높이 = 이미지 바닥의 위치const imageBottom = slideImage.offsetTop + slideImage.height; offsetTop? 💡 부모의 상단 보더로부터 자신의 상단 보더가 떨어진 만큼의 거리! 슬라이드인 조건들스크롤이 이미지의 절반까지 위치했는가?1const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; 화면에서 이미지가 이미 지나쳐갔는가?12// 이미지가 스크롤되어 지나쳐, 이미 화면에서 안보이는데 굳이 띄워둘 필요는 없음!const isPassed = window.scrollY &lt; imageBottom; 이제 이미지를 위의 두 조건이 아닐 경우에는 이미지가 슬라이드 아웃 되도록 해주면 된다. 최종 코드123456789101112131415161718192021222324252627282930313233343536function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}const slideIn = document.querySelectorAll('.slide-in');function slide(e) { slideIn.forEach((slideImage) =&gt; { const slideAt = window.scrollY + window.innerHeight; console.log(slideAt); console.dir(slideImage); // bottom of the image const imageBottom = slideImage.offsetTop + slideImage.height; const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; const isPassed = window.scrollY &lt; imageBottom; if (isHalfShown &amp;&amp; isPassed) { slideImage.classList.add('active'); } else { slideImage.classList.remove('active'); } });}window.addEventListener('scroll', debounce(slide));","link":"/javascript/wesbos/13.%20Scroll_SlideIn/"},{"title":"Wesbos - 로컬스토리지 &amp; 이벤트 위임","text":"로컬스토리지의 활용법과 이벤트 위임이라는 굉장히 유용한 기능을 배울 수 있는 챕터였다. (어려웠지만….. ㅋㅋ) 물론 mongoDB와 같은 DB를 사용하면 크게 사용할 일은 없겠지만, 간단한 웹서비스 등을 만들 때에는 유용할 것 같다. 로직 사용할 객체들 변수화 하기 (const) + 이벤트리스너와 함수 생성 &lt;input&gt;에입력한 값을 인식할 수 있도록 함수 설정 add item(submit)을 누르면 가 append! append된 요소들이 로컬스토리지에 저장 되도록 설정 체크박스의 체크 유무 또한 로컬 스토리지에 저장 되도록 설정 (위임도 필요) 삭제 기능 추가 const 선언 💡 Add item버튼, html에 추가될 아이템 ul, 아이템 배열을 생성하여 변수화해준다. 123const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const items = []; addEventListener1234567function addItem(e) { e.preventDefault(); //잘 작동하는지 확인! console.log('hi');}addItems.addEventListener('submit', addItem); event.preventDefault() 💡 페이지의 이동 또는 리로드가 실행되지 않도록 막아준다! ⇒ 이 챕터에선 submit을 눌러도 페이지가 새로고침되지 않고 submit만 될 수 있도록 하기 위해 사용 &lt;input&gt;에 입력한 텍스트 인식 💡 &lt;input&gt; 에 입력한 값이 잘 불러와질 수 있도록 addItem 함수를 수정보완 1234567891011121314function addItem(e) { e.preventDefault(); // 입력된 값을 text로 변수화 text = this.querySelector('[name=item]').value; // 객체 생성 item = { text: text, done: false, }; //찍어보기 console.log(item); // 미리 생성한 배열인 items에 item을 push} 미리 생성한 배열인 items에 item을 push!123456789function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item);} setItem() 💡 로컬스토리지 객체에 접근하여 항목 하나를 추가한다 ⭐️JSON.stringify()⭐️ 💡 JavaScript값이나 객체를 JSON형태의 문자열로 변환한다. (배열 자체가 문자열이 되어 반환된다고 생각하면 편할듯?) 12console.log(JSON.stringify({ x: 5, y: 6 }));// 예상 결과값 : &quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot; 버튼 누르면 → 아이템(&lt;li&gt;) append! 💡 우선 appendList라는 함수를 생성해주자. 1234567891011121314function appendList(plates = [], platesList) { platesList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${ plate.done ? 'checked' : '' } /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join(''); // map에 의해서 콤마(,)가 append될 때마다 붙기 때문에 이를 제거하기 위해 join을 사용!} localStoragegetItem() 💡 로컬스토리지 내에서 항목을 읽어냄 ⭐️JSON.parse()⭐️ 💡 문자열로 구성된 JSON을 JavaScript값이나 객체로 반환한다. 문자열 → JavaScript 객체 123456789101112131415161718// 로컬 스토리지에 저장된 메뉴가 있으면 불러오고, 없으면 빈 배열!const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); // input박스에 입력될 텍스트를 변수화 const text = this.querySelector('[name=item]').value; const item = { text: text, // 체크박스에 활용할 Boolean값 done: false, }; items.push(item); populateList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();} 체크 유무 저장 💡 위의 items 객체에서 설정한 done의 boolean값을 저장하여체크박스의 체크 유무를 새로고침해도 유지될 수 있도록 설정 12345678function toggleDone(e) { if (!e.target.matches('input')) return; // input 태그가 아니면 종료 (label도 찍힐 수 있기 때문) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; // 반대값 설정 트릭 ! localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);} 삭제기능 추가 💡 wrapper 하단에 Clear All 버튼을 만들어 준 뒤, localStorage.removeItem() 을 사용해서 삭제기능을 구현하면 된다. removeItem() 💡 로컬 스토리지에서 항목 하나를 제거한다. 1234567891011// 클리어 버튼 변수화const clear = document.querySelector('.clear');function removeAll() { localStorage.removeItem('items'); // removeItem은 로컬스토리지 삭제 기능만 하기 때문에, li가 제거될 수 있도록 새로고침을 해준다. location.reload();}// 클릭 이벤트 &amp; 함수 할당clear.addEventListener('click', removeAll); 최종 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const clear = document.querySelector('.clear');const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item); appendList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();}// 원본 훼손을 최대한 방지하기 위해 items 복사!function appendList(plates = [], plateList) { plateList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;items${i}&quot; ${ plate.done ? 'checked' : '' }/&gt; &lt;label for=&quot;items${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join('');}function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);}function removeAll() { localStorage.removeItem('items'); location.reload();}clear.addEventListener('click', removeAll);addItems.addEventListener('submit', addItem);itemsList.addEventListener('click', toggleDone);appendList(items, itemsList);","link":"/javascript/wesbos/15.%20LocalStorage/"},{"title":"Wesbos - 배열 조건부 정렬","text":"보통 가수 이름이나, 노래 제목 등을 정렬할 때관사 The, a, an 등은 참조하지 않은 채로 정렬을 한다고 한다. 이를 바탕으로 sort() 등을 활용해 정렬해보자. 로직 정렬에 조건 걸기 (/ ^(a | the | an)/) 정렬하기 sort() 정렬된 것 ul에 넣어주기 innerHTML 참조한 관사 (A, The, An)에만 CSS값 주기 정렬에 조건 걸기 💡 굉장히 새로운 내용이었다. 내가 제거하고 싶은 부분들을 제거해서 배열을 새로 만든 다음에, 이것을 기준으로 정렬한다는 것이 참신했다. 우선, bands 배열 내에 있는 오브젝트들의 관사를 제거해주는 함수를 만들어보자. 12345678// bandName 인자가 들어오면 -&gt; a, the, an을 제거하고 양 옆 공백을 삭제하여 반환해준다.function strip(bandName) { return bandName.replace(/^(a |the |an )/i, '').trim(); // 반드시 | 뒤에 공백이 없어야 한다. 공백까지 인식해버림..}console.log(strip('the hoonjoo Park'));// 잘 기능하는지 찍어보기 string.trim() 💡 문자열에서 양 옆에 있는 공백을 제거해준다. 정렬하기 💡 기초체력 다지기에서 공부했듯이, sort() 를 사용하면 된다. 12// 코드는 항상 최대한 간결하게 !!const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1)); 정렬한 것 화면에 띄우기123const bandUl = document.querySelector('#bands');bandUl.innerHTML = sortedBands.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 참조한 관사 (A, The, An)에만 CSS값 주기 💡 Type Ahead 챕터에서 사용했던 정규식 RegExp() 를 활용해봤다. 우선… 새로운 특정 관사가 &lt;span class=&quot;hl&quot;&gt;&lt;/span&gt; 로 replace될 수 있도록 해보자 12345678910111213// map을 통해 새로운 배열을 생성해야 하므로 anThe를 만들어서 써보자const anThe = sortedBands.map((node) =&gt; { // 첫 문자 &amp; 대소문자를 구분하는 regex 생성 const regex = new RegExp(/^(A |The |An )/g); // 노드 내에서 regex와 일치하는 (A The An)을 matchRegex에 할당 const matchRegex = node.match(regex); // replace를 통해 해당 regex값이 &lt;span&gt;태그가 붙은 형태로 바뀌어질 수 있도록! const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;}); 최종 완성 코드12345678910111213141516171819202122232425262728293031323334const bands = [ 'The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil', 'Norma Jean', 'The Bled', 'Say Anything', 'The Midway State', 'We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive', 'Anywhere But Here', 'An Old Dog',];const bandUl = document.querySelector('#bands');function strip(bandName) { return bandName.replace(/^(a |the |an)/i, '').trim();}const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1));const anThe = sortedBands.map((node) =&gt; { const regex = new RegExp(/^(A |The |An )/g); const matchRegex = node.match(regex); const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;});const appendBand = anThe.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join('');bandUl.innerHTML = appendBand;","link":"/javascript/wesbos/17.%20SortArray/"},{"title":"Wesbos - Mouse Move Shadow","text":"mousemove 이벤트가 일어날 때마다해당 텍스트의 그림자가 마우스 위치로 이동하는 기능을 구현하면 된다. 로직 const와 함수 생성 및 할당 마우스 offset값 활용 해당 값을 style.textShadow에 적용! const와 함수 생성 및 할당 💡 마우스가 움직일 공간인 뷰포트와 h1태그를 변수화 한 후, 함수를 생성해준다. 123456789const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { // 확인해보기! console.log(e);}hero.addEventListener('mousemove', shadow); offsetX &amp; offsetY 값의 활용 💡 canvas 챕터에서 사용했었던 offset값을 다시 활용해보자. 1234function shadow(e) { let { offsetX: x, offsetY: y } = e; console.log(x, y);} 하지만… hero 안에 자식요소로 &lt;h1&gt; 태그가 존재하기 때문에text위에 마우스를 올리면 자식요소에 대한 offset값이 출력된다. 🤔 X축에 대해선 offsetLeft를, Y축에 대해선 offsetTop을 활용하면 된다. 123456789function shadow(e) { let { offsetX: x, offsetY: y } = e; // 즉, 뷰포트인 hero가 타게팅되고 있지 않다면~ if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; }} offset 값을 px로 반환하여 활용 💡 기본 단위를 선언 ⇒ 픽셀 값으로 반환하여 적용 12345678910111213141516function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } // 내가 마우스를 움직인 만큼의 거리가 뷰포트 내에서 몇 퍼센트인지 xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; // 위의 값을 css에 적용! text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;} 최종 완성 코드1234567891011121314151617181920const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this != e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;}hero.addEventListener('mousemove', shadow);","link":"/javascript/wesbos/16.%20Mouse%20Move%20Shadow/"},{"title":"Wesbos - Canvas를 활용한 웹캠제어","text":"이런 것도 가능하다니…웹캠을 제어하는 것도 JS와 라이브러리를 통해 구현할 수 있다는게 신기하고 재밌었다. 로직 필요한 HTML태그 정리와 선언 webcam 불러오기 캔버스설정과 캔버스에 영상 띄우기 사진 찍기 기능! 필요한 HTML 태그 💡 &lt;canvas&gt;, &lt;video&gt;, &lt;audio&gt; 태그들이 필수적으로 필요하다. &lt;canvas&gt; 와 &lt;audio&gt;는 왜???⇒ 캔버스는 웹캠 화면에서 다양한 색상 또는 픽셀 등을 다루기 위해서 필요한 것! ⇒ 오디오는 “찰칵소리“의 구현을 위해 필요 123456// 선언const video = document.querySelector('.player');const canvas = document.querySelector('.photo');const ctx = canvas.getContext('2d');const strip = document.querySelector('.strip'); // 찍은 사진이 display될 공간const snap = document.querySelector('.snap'); // &quot;찰칵!&quot; 웹캠 불러오기navigator.mediaDevices.getUserMedia() 💡 getUserMedia()는 사용자에게 미디어 입력장치 사용 권한을 요청! ⇒{video : true, audio : false} 와 같이 설정해주면 됨 ⭐️ 이는 프로미스를 반환한다 ⭐️ 123456789function getvideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((MediaStream) =&gt; { console.log(MediaStream); });}getvideo(); 그럼 이제 촬영되고 있는 화면을 어떻게 브라우저에 띄울 수 있을까? 💡 video 태그에 srcObject값을 부여해주면 된다! 1234567891011121314function getVideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((localMediaStream) =&gt; { video.srcObject = localMediaStream; // 위에 보이다시피 localMediaStream은 blob형태라서 scrObject를 사용해서 DOMSTRING형태로 주소를 부여해줘야한다. video.play(); }) .catch((error) =&gt; { console.error('카메라 로드 실패', error); });}video.addEventListener('canplay', paintToCanvas); // 미디어 사용이 준비됐을 때 해당 함수 실행! 캔버스 설정 💡 주의해야 할 점은, 시각효과를 정확하게 적용하기 위해선 캔버스 크기(넓이, 높이)와 비디오 크기가 같아야 한다는 것이다. 1234567891011function paintToCanvas() { const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt; { // 왼쪽 위 모두 0에서 시작, 넓이와 높이는 위의 값과 동일 ctx.drawImage(video, 0, 0, width, height); }, 16); // 16밀리세컨즈} 참고로 필자는 웹캠과 캔버스의 좌우반전이 좀 거슬려서 캔버스와 비디오에 각각transform:rotateY(180deg); 값을 부여했다. 사진 찍기 기능! 💡 toDataURL, setAttribute, insertBefore에 대한 이해가 필요하다. canvas.toDataURL() 💡 캔버스에 그려진 이미지를 base64형태 (이미지가 스트링으로 구성)로 변환해준다. link.setAttribute() 💡 해당 링크의 (메서드, 형태) 등을 설정할 수 있다. insertBefore() 💡 다음에 추가될 노드가 자식노드와 같이 아래로 쌓여진다. 123456789101112function takePhoto() { // 사진 찍는 소리를 구현해주고 snap.currentTime = 0; snap.play(); const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'photo'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;hoonjoo&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);} 최종 완성 코드12345678910111213141516171819202122232425262728293031323334353637383940414243const video = document.querySelector('.player');const canvas = document.querySelector('.photo');const ctx = canvas.getContext('2d');const strip = document.querySelector('.strip');const snap = document.querySelector('.snap');function getVideo() { navigator.mediaDevices .getUserMedia({ video: true, audio: false }) .then((localMediaStream) =&gt; { video.srcObject = localMediaStream; video.play(); }) .catch((error) =&gt; { console.error('카메라 로드 실패', error); });}function paintToCanvas() { const width = video.videoWidth; const height = video.videoHeight; canvas.width = width; canvas.height = height; return setInterval(() =&gt; { ctx.drawImage(video, 0, 0, width, height); }, 16);}function takePhoto() { snap.currentTime = 0; snap.play(); const data = canvas.toDataURL('image/jpeg'); const link = document.createElement('a'); link.href = data; link.setAttribute('download', 'photo'); link.innerHTML = `&lt;img src=&quot;${data}&quot; alt=&quot;hoonjoo&quot; /&gt;`; strip.insertBefore(link, strip.firstChild);}getVideo();video.addEventListener('canplay', paintToCanvas);","link":"/javascript/wesbos/19.%20CanvasAndWebCam/"},{"title":"Wesbos - 음성인식","text":"음성인식 라이브러리를 통해 내 말을 자동으로 받아쓰여지도록 구현해볼 수 있다 ! 로직 라이브러리 불러오기 및 기본설정 (window.SpeechRecognition) addEventListener ⇒ 이벤트 수신과 메서드 태그 형태로 append 라이브러리 불러오기 및 기본설정! 💡 SpeechRecognition이라는 웹 라이브러리를 사용한다. (크롬, 엣지) 파이어폭스에선 window.webkitSpeechRecognition 이 사용된다. 사용법const OOOO = new SpeechRecognition(); 12345678910// 브라우저 호환성을 위해 두 개의 라이브러리를 선언window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;const recognition = new SpeechRecognition();// interimResults = false로 줄 경우, 문장이 아닌 단어만을 인식한다.recognition.interimResults = true;// 'en-US'도 가능!recognition.lang = 'ko-KR'; 이벤트리스너 💡 result = 결과값이 도출될 경우 123456789recognition.addEventListener('result', e =&gt; { const transcript = Array.from(e.results) .map(result =&gt; result[0]) // 제일 첫번째에 results, transcript 담겨있음 .map(result =&gt; result.transcript) .join(''); };})recognition.addEventListener('end', recognition.start); 우리에게 필요한건 results의 transcript! p태그로 append!1234567891011121314151617let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p); // .words의 자식요소로 넣기recognition.addEventListener('result', (e) =&gt; { const transcript = Array.from(e.results) .map((result) =&gt; result[0]) .map((result) =&gt; result.transcript) .join(''); p.textContent = transcript; // 만약 말이 끝났으면, 다시 p태그를 생성 -&gt; 음성 인식 -&gt; 인식된 결과 붙여넣기 if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }}); 덮어쓰기 → 줄글 형태로 쭉 쓰기 최종 완성 코드1234567891011121314151617181920212223242526window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;const recognition = new SpeechRecognition();recognition.interimResults = true;recognition.lang = 'ko-KR';let p = document.createElement('p');const words = document.querySelector('.words');words.appendChild(p);recognition.addEventListener('result', (e) =&gt; { const transcript = Array.from(e.results) .map((result) =&gt; result[0]) .map((result) =&gt; result.transcript) .join(''); p.textContent = transcript; if (e.results[0].isFinal) { p = document.createElement('p'); words.appendChild(p); }});recognition.addEventListener('end', recognition.start);recognition.start();","link":"/javascript/wesbos/20.%20Voice/"},{"title":"Wesbos - reduce와 map 응용","text":"[data-time]에 저장되어 있는 시간 값들의 총합을 구하여 비디오의 총 러닝타임을 구해보자 로직 const를 통해 사용할 요소 선언 map과 split을 통해 값 정제 reduce()를 통해 총합 구하기! 시간들을 수학적 계산을 통해 알맞게 전환 const 선언부터… 💡 이번 챕터에선 간단하게 &lt;li&gt; 태그들만 선언 해줘도 된다. 12345// nodelist로 표현되긴 하지만, 실제 배열은 아니기 때문에 배열에 집어넣어줘야 함!const timeNodes = Array.from(document.querySelectorAll('[data-time]'));console.log(timeNodes); map과 split을 통해 시간값 정제 💡 우선… 원활한 계산을 위해 [분 : 초]의 형식에서 “:”을 제거해주고 정수화시켜줘야 될 것 같다. dataset.time🤔 태그 내에 [data-OOO]이 저장되어 있다면, dataset.OOO 을 통해 그 값을 불러올 수 있다. 12345678910const seconds = timeNodes // 노드들은 이제 data-time에 적힌 값이 됐음 .map((node) =&gt; node.dataset.time) // 이것을 timeCode라고 하고, :을 기준으로 나눠서 왼쪽은 mins, 오른쪽은 secs로 할당 .map((timeCode) =&gt; { // 정수화!! const [mins, secs] = timeCode.split(':').map(parseFloat); // mins는 분 형식이니까 초 값으로 만들려면 곱하기 60! return mins * 60 + secs; }); reduce를 사용하여 총합 구하기123.reduce((acc, current) =&gt; acc + current);console.log(seconds); 계산 → “시 : 분 : 초”로 나타내기 💡 시 → 분 → 초 순서대로 계산을 해보자한 시간은 3600초… 1234567891011// secondsLeft를 활용해서 계속 남은 초를 계산let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);// 3600초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);// 60초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft); 최종 완성 코드123456789101112131415161718192021const timeNodes = Array.from(document.querySelectorAll('[data-time]'));const totalTime = document.querySelector('p');const seconds = timeNodes .map((node) =&gt; node.dataset.time) .map((timeCode) =&gt; { const [mins, secs] = timeCode.split(':').map(parseFloat); return mins * 60 + secs; }) .reduce((acc, current) =&gt; acc + current);let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft);totalTime.innerHTML = `&lt;span&gt;${hours}시간 ${minutes}분 ${secondsLeft}초&lt;/span&gt;`;","link":"/javascript/wesbos/18.%20Reduce_Map/"},{"title":"Wesbos - 나침반과 속도계","text":"처음으로 Xcode를 사용해봤다.navigator.geolocation 을 활용한 지리적 정보를 통해 방향과 속도를 측정해볼 수 있었다. 로직 Xcode &amp; 시뮬레이터 실행 시뮬레이터를 통해 html파일 실행 사용할 HTML요소 선언 (const) 지리적 정보 API 불러오기 geolocation.watchPosition() 방향 정보와 속도 정보 받아와서 append Xcode와 시뮬레이터 세팅 💡 Xcode 설치 ⇒ 시뮬레이터 실행! 시뮬레이터 실행과 기종 선택 시뮬레이터를 통해 html파일 실행 💡 내장된 package.json파일을 terminal을 통해 실행시켜서npm install → npm start를 입력해준다. 첫 번째 External URL을 시뮬레이터에 입력하여 접속 index-START.html 파일 실행사파리에서 시뮬레이터 디버깅 하는 법 (f12) 사파리 환경설정에 들어가 ‘고급설정’에서 메뉴 막대에서 “개발자용 메뉴보기” 설정 const 선언 💡 나침반에 들어간 arrow와 속도값만 선언해주면 된다. 12const arrow = document.querySelector('.arrow');const speedValue = document.querySelector('.speed-value'); 지리적 정보(geolocation) API 💡 navigator.geolocation.watchPosition() 을 사용한다. geolocation 디바이스의 위치정보를 가져올 수 있도록 하는 인터페이스 watchPosition() 디바이스의 위치가 변경될 때마다 호출하는 콜백을 등록한다. 123navigator.geolocation.watchPosition((data) =&gt; { console.log(data);}); 🔥주의사항!!! 💡 반드시 features에 들어가 위치설정을 해줘야한다. 그렇지 않으면 heading이나 speed값이 null값으로 나타나기 때문 방향 정보와 속도 정보 활용 💡 위에서 찍어본 data 내에서 필요한 정보를 활용하면 된다 ! heading , speed 1234567891011navigator.geolocation.watchPosition( (data) =&gt; { console.log(data); speedValue.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`; }, (err) =&gt; { console.error(err); alert('위치정보 접근을 허용해주세요!'); }); 최종 완성 코드1234567891011121314const arrow = document.querySelector('.arrow');const speedValue = document.querySelector('.speed-value');navigator.geolocation.watchPosition( (data) =&gt; { console.log(data); speedValue.textContent = data.coords.speed; arrow.style.transform = `rotate(${data.coords.heading}deg)`; }, (err) =&gt; { console.error(err); alert('위치정보 접근을 허용해주세요!'); });","link":"/javascript/wesbos/21.%20Direction/"},{"title":"Wesbos - 따라다니는 하이라이트","text":"추후에 드롭다운 메뉴 등에 활용할 수 있을 것 같은 기능이다.원래 나였으면 CSS값을 add하고 remove하는 방식을 썼을 것 같은데, 이번 챕터에선 하이라이터가 마우스가 올라간 객체의 위치값을 활용해서 하이라이팅한다. 로직 HTML, CSS값 선언 및 할당 (const) 스크롤 했을 때를 가정하여 위치값 설정 (window.scrollY) 이벤트리스너와 함수 생성 (mouseenter) 마우스가 올라간 객체의 위치값 활용 getBoundingClientRect() const 선언부터… 💡 태그에 하이라이팅을 할 것이므로 ⇒ a태그를 선언 + 하이라이팅 요소(span)를 생성해주기 주의‼️ 원래는 CSS값을 add하고 remove하는 방식이지만,여기선 하이라이트 요소를 만들어놓고 → 요놈을 움직이고 크기를 조절하며 하이라이팅 함 1234567const triggers = document.querySelectorAll('a');// 하이라이트는 &lt;span&gt;을 사용할 것const highlight = document.createElement('span');// 미리 설정해둔 CSS값을 &quot;하이라이트 span에&quot; 적용highlight.classList.add('highlight');// 일단 그냥 띄워두기document.body.append(highlight); 이벤트리스너와 함수 생성 💡 mouseenter을 활용 mouseenter vs mouseover mouseover : 자식요소에까지 이벤트가 할당됨 12345function highlightLink() { console.log(this);}triggers.forEach((a) =&gt; a.addEventListener('mouseenter', highlightLink)); 위치값을 활용한 하이라이트 💡 여기서부턴 처음 사용해보는 메서드를 활용해야한다. Element.getBoundingClientRect() 뷰포트를 기준으로 한 상대적 엘리먼트의 위치와 사이즈를 포함하는 DOMRect를 리턴해준다. highlight의 너비와 위치가 동적으로 변할 수 있도록 설정12345678function highlightLink() { const linkCoords = this.getBoundingClientRect(); console.log(linkCoords); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; highlight.style.left = `${linkCoords.left}px`; highlight.style.top = `${linkCoords.top}px`;} 스크롤값을 반영 하지만… 스크롤을 내리면 아래와 같이 스크롤을 내리기 전 위치값으로 이동되기 때문에 highlight의 위치값에 스크롤 이동에 따른 변화값을 추가해줘야된다. 12345678910function highlightLink() { const linkCoords = this.getBoundingClientRect(); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; // top, left 값에 각각 스크롤한 만큼의 값을 더해줌! const scrollY = linkCoords.top + window.scrollY; const scrollX = linkCoords.left + window.scrollX; highlight.style.left = `${scrollX}px`; highlight.style.top = `${scrollY}px`;} 최종 완성 코드123456789101112131415161718192021222324const triggers = document.querySelectorAll('a');const highlight = document.createElement('span');highlight.classList.add('highlight');document.body.append(highlight);function highlightLink() { const linkCoords = this.getBoundingClientRect(); highlight.style.width = `${linkCoords.width}px`; highlight.style.height = `${linkCoords.height}px`; const scrollY = linkCoords.top + window.scrollY; const scrollX = linkCoords.left + window.scrollX; highlight.style.left = `${scrollX}px`; highlight.style.top = `${scrollY}px`; highlight.style.opacity = 1;}//마우스가 나가있을 때 사라지게 할 수 있도록 opacity값을 변경하는 함수도 추가했다.function deHighlight() { highlight.style.opacity = 0;}triggers.forEach((a) =&gt; a.addEventListener('mouseenter', highlightLink));triggers.forEach((a) =&gt; a.addEventListener('mouseleave', deHighlight));","link":"/javascript/wesbos/22.%20Highlight/"},{"title":"Wesbos - 텍스트 음성변환","text":"Web Speech API인 SpeechSynthesisUtterance() 를 활용한 텍스트 음성 합성기를 활용해보는 챕터였다. 배우면 배울수록 JavaScript가 다재다능한 언어임을 깨닫는다. 로직 선언과 SpeechSynthesisUtterance() 불러오기 음성종류(voice) option에 불러오기 텍스트 읽기와 정지 기능 구현하기 Rate와 Pitch값 조절기능 구현 const &amp; Speech APISpeechSynthesisUtterance() 💡 Web Speech API로, 스피치(말하기)서비스와 읽기관련 다양한 기능들을 제공한다. 이름 설명 .lang 언어를 불러오고 세팅함 .pitch 피치를 조절할 수 있음 .rate 말하기 속도를 조절 가능 .text 말하기 할 텍스트를 설정 및 입력 .getVoices 목소리 종류를 설정\u001f .volume 볼륨 설정 버튼, 옵션인풋, 드롭다운 등을 선언해준다.123456const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name=&quot;voice&quot;]');const options = document.querySelectorAll('[type=&quot;range&quot;], [name=&quot;text&quot;]');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop'); Voices 드롭다운에 불러오기 💡 speechSynthesis.OOO을 활용해야 한다. voiceschanged 페이지 실행 시(로드) 실행되며, list를 불러오기 위해 주로 사용된다. 1234567891011121314function populateVoices() { voices = this.getVoices(); console.log(voices); voicesDropdown.innerHTML = voices // 영어와 한국어만 사용하기 위해 이하와 같이 filter를 걸었다. .filter((voice) =&gt; voice.lang.includes('en') || voice.lang.includes('ko')) .map( (voice) =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;` ) .join('');}speechSynthesis.addEventListener('voiceschanged', populateVoices); 보이스 세팅 💡 읽기(speak)를 기능하게 하도록 하기 위해선 보이스(voice)를 설정해줘야 한다. 123456function setVoices() { console.log(this); console.log(this.value);}voicesDropdown.addEventListener('change', setVoices); 자… 이제 위의 값들을 msg.voice에 넣어주면 된다.123function setVoices() { msg.voice = voices.find((voice) =&gt; voice.name == this.value);} 읽기와 정지 버튼 활성화 💡 speechSynthesis.speak || .cancel 메서드를 활용해주면 된다 ! 우선! textarea에 적혀있는 텍스트가 msg.text에 할당되어야 한다.1msg.text = document.querySelector('[name=&quot;text&quot;]').value; texarea에 입력된 텍스트 읽기12345678function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}speakButton.addEventListener('click', toggle); 하지만…. 여기서 끝낼 경우 계속 HTML에 미리 입력해둔 “Hello! I love JavaScript 👍”만 읽는다… ⇒ 옵션을 세팅해줘야 함! msg.text와 Rate, 그리고 Pitch값 할당textarea나 Rate, Pitch값이 변경되면 그 값을 msg에 할당하도록 해보자123456789const typedText = document.querySelector('[name=&quot;text&quot;]').value;msg.text = typedText;function setOption() { console.log(this.name, this.value); msg[this.name] = this.value;}options.forEach((option) =&gt; option.addEventListener('change', setOption)); 최종 완성 코드참고로 필자는 옵션이 변경될 때마다 텍스트를 읽는게 불편해서toggle() 이 말하기를 눌렀을 때만 실행되도록 코딩했다. 123456789101112131415161718192021222324252627282930313233343536373839404142const msg = new SpeechSynthesisUtterance();let voices = [];const voicesDropdown = document.querySelector('[name=&quot;voice&quot;]');const options = document.querySelectorAll('[type=&quot;range&quot;], [name=&quot;text&quot;]');const textarea = document.querySelector('textarea');const speakButton = document.querySelector('#speak');const stopButton = document.querySelector('#stop');const typedText = document.querySelector('[name=&quot;text&quot;]').value;msg.text = typedText;function populateVoices() { voices = this.getVoices(); voicesDropdown.innerHTML = voices .filter((voice) =&gt; voice.lang.includes('en') || voice.lang.includes('ko')) .map( (voice) =&gt; `&lt;option value=&quot;${voice.name}&quot;&gt;${voice.name} (${voice.lang})&lt;/option&gt;` ) .join('');}function setVoices() { msg.voice = voices.find((voice) =&gt; voice.name == this.value);}function toggle(startOver = true) { speechSynthesis.cancel(); if (startOver) { speechSynthesis.speak(msg); }}function setOption() { console.log(this.name, this.value); msg[this.name] = this.value;}speechSynthesis.addEventListener('voiceschanged', populateVoices);voicesDropdown.addEventListener('change', setVoices);options.forEach((option) =&gt; option.addEventListener('change', setOption));speakButton.addEventListener('click', toggle);stopButton.addEventListener('click', toggle(false));","link":"/javascript/wesbos/23.%20ConvertVoice/"},{"title":"Wesbos - Sticky Nav","text":"반응형 웹사이트를 만드는 데에 굉장히 유용하게 쓰일 것 같은 챕터였다.많은 비즈니스 웹사이트들이 이러한 기능들을 활용하고 있는 것 같다. 로직 const와 스크롤 이벤트에 반응하는 함수 만들기 nav바의 offsetTop값 활용하기 부자연스러운 부분 해결하며 완성도 높이기 const 선언과 Scroll 이벤트 💡 nav에 대한 선언을 하고, Scroll이벤트를 수신할 엘리먼트와 그에 따른 함수를 생성해주자. 1234567const nav = document.querySelector('#main');function fixNav() { console.log(nav); // 찍어보기}window.addEventListener('scroll', fixNav); offsetTop과 scrollY의 활용 스크롤 슬라이드인 챕터에서 사용했던 논리와 유사하다고 생각하면 된다. 12345678function fixNav() { console.log(nav.offsetTop); if (window.scrollY &gt;= nav.offsetTop) { document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); }} ‼️ 하지만…. fixed-nav 클래스가 remove되지 않는 현상이 발생한다. ❓ 뭐가 문제일까…. 고민을 해보다 console.log(nav.offsetTop)로 찍어보니if문 실행 이후 -&gt; 보이는 바와 같이 offsetTop의 값이 0으로 변해버려 else문이 실행이 되지 않았던 것이 문제였다. 함수 밖에서 let을 통해 nav.offsetTop의 값을 선언해주면 되는 문제였다.12345678910let navTop = nav.offsetTop; // fixNav에 의해 nav가 fixed 되어도 offsetTop값은 초기의 값으로 고정된다.function fixNav() { console.log(navTop); if (window.scrollY &gt;= navTop) { document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); }} 부자연스러운 transition ❓ fixNav() 함수에 의해 position이 fixed될 때 트랜지션이 부자연스럽게 뚝뚝 끊기는 현상이 발생한다 body의 height가 정확히 nav의 height만큼 늘었다 줄었다 하는 것을 발견했다. 이는 nav의 포지션이 fixed 되면서nav의 height값 만큼 body의 상단을 잡아먹었기 때문이다. 그럼 nav의 height값 만큼 padding-top을 줘서fixNav() 가 실행될 때 body 내에 존재하는 엘리먼트들을 아래로 밀어내주면 되지 않을까 123456789function fixNav() { if (window.scrollY &gt;= navTop) { document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }} 최종 완성 코드123456789101112131415const nav = document.querySelector('#main');let navTop = nav.offsetTop;function fixNav() { console.log(navTop); if (window.scrollY &gt;= navTop) { document.body.style.paddingTop = nav.offsetHeight + 'px'; document.body.classList.add('fixed-nav'); } else { document.body.classList.remove('fixed-nav'); document.body.style.paddingTop = 0; }}window.addEventListener('scroll', fixNav);","link":"/javascript/wesbos/24.%20Sticky%20Nav/"},{"title":"Wesbos - 동적 드롭다운 메뉴","text":"Sticky Nav와 같이 웹 사이트를 제작할 때 자주 사용할 수 있을 것 같은 기능이다.마우스 hover → 서브메뉴들의 크기에 따라 동적으로 드롭다운 된다. 로직 const를 통한 선언 함수 만들기 + 이벤트리스너 (mouseenter, mouseleave) 마우스 이벤트에 반응 할 CSS 작성 classlist.add 와 remove getBoundingClientRect()를 활용한 엘리먼트 위치 및 크기 값 활용 const 선언-불편한 바보 드롭다운이 되지 않기 위해선 a가 아닌, li태그에 이벤트를 걸어줘야 한다. -dropdownBackground가 따라다녀야 함 -nav태그의 위치값이 추후에 필요하므로 nav태그 또한 선언 필요 123const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top'); 함수 &amp; eventListener 💡 마우스 hover와 같은 기능이자 해당 이벤트가 엘리먼트에만 적용되는 mouseenter, mouseleave 12345678910function handleEnter() { console.log('Entered!'); // 잘 작동하는지 찍어보기}function handleLeave() { console.log('Leaved!');}triggers.forEach((li) =&gt; li.addEventListener('mouseenter', handleEnter));triggers.forEach((li) =&gt; li.addEventListener('mouseleave', handleLeave)); CSS 작성하기1234567891011.trigger-enter .dropdown { display: block;} /* trigger-enter 그리고 .dropdown 모두 */.trigger-enter-active .dropdown { opacity: 1;}.dropdownBackground.open { opacity: 1;} classList.add &amp; remove12345678910function handleEnter() { this.classList.add('trigger-enter'); this.classList.add('trigger-enter-active'); background.classList.add('open');}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');} ‼️ 하지만… 이렇게 코딩할 경우, transition 효과가 적용되지 않는다. 💡 display : block에는 transition이 먹히지 않기 때문에, block이 된 후 opacity에 변화를 줘야 ⇒ transition이 적절하게 적용된다. 1234567891011function handleEnter(){ this.classList.add('trigger-enter') // &amp;&amp; 앞이 조건문, 뒤에는 True일 경우의 결과 setTimeout(()=&gt; this.classList.add('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 150)')) background.classList.add('open')};function handleLeave(){ this.classList.remove('trigger-enter', 'trigger-enter-active') background.classList.remove('open')}; getBoundingClientRect()의 활용 💡 getBoundingClientRect() = 엘리먼트의 넓이, 뷰포트를 기준으로 한 위치값(x,y) 등을 알 수 있다. 1234567891011121314151617181920212223242526272829function handleEnter() { this.classList.add('trigger-enter'); setTimeout( () =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 100 ); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); background.style.setProperty('width', `${dropdownCoords.width}px`); background.style.setProperty('height', `${dropdownCoords.height}px`); // nav의 위치가 변경되면 위치가 뒤틀릴 수 있기 때문에 애초에 nav의 top과 left값을 빼준다. background.style.setProperty( 'transform', `translate(${dropdownCoords.left - navCoords.left}px, ${ dropdownCoords.top - navCoords.top }px)` );}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435const triggers = document.querySelectorAll('.cool &gt; li');const background = document.querySelector('.dropdownBackground');const nav = document.querySelector('.top');function handleEnter() { this.classList.add('trigger-enter'); setTimeout( () =&gt; this.classList.contains('trigger-enter') &amp;&amp; this.classList.add('trigger-enter-active'), 100 ); background.classList.add('open'); const dropdown = this.querySelector('.dropdown'); const dropdownCoords = dropdown.getBoundingClientRect(); const navCoords = nav.getBoundingClientRect(); background.style.setProperty('width', `${dropdownCoords.width}px`); background.style.setProperty('height', `${dropdownCoords.height}px`); background.style.setProperty( 'transform', `translate(${dropdownCoords.left - navCoords.left}px, ${ dropdownCoords.top - navCoords.top }px)` );}function handleLeave() { this.classList.remove('trigger-enter', 'trigger-enter-active'); background.classList.remove('open');}triggers.forEach((li) =&gt; li.addEventListener('mouseenter', handleEnter));triggers.forEach((li) =&gt; li.addEventListener('mouseleave', handleLeave));","link":"/javascript/wesbos/26.%20Dropdown/"},{"title":"Wesbos - 이벤트 버블링 &amp; 캡쳐 &amp; 위임","text":"브라우저가 JavaScript 명령을 어떤 방식으로 수행하는지 좀 더 자세히 배울 수 있는 챕터였다. 이벤트 버블링 💡 이벤트가 **”Bottom-Up 형식”**으로 전달되어 가는 특성을 의미한다 ! 예시1234567&lt;body class=&quot;body&quot;&gt; &lt;div class=&quot;one&quot;&gt; &lt;div class=&quot;two&quot;&gt; &lt;div class=&quot;three&quot;&gt;&lt;!-- 클릭 --&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1234567const divs = document.querySelectorAll('div');function check() { console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check)); 결과 (이벤트 버블링) 세번째 요소 뿐만이 아니라, 상위 엘리먼트들인 two와 one에도 click이벤트에 따른 함수가 실행되는 것을 확인할 수 있다. “Trigger clicks all the way up” 이벤트 캡쳐 💡 이벤트 버블과 반대로 Top-Down 형식으로 해당 엘리먼트를 찾아 내려가고, 이벤트를 실행한다. 예시 : addEventListener('OOO', function, {capture : boolean}) 1234567891011const divs = document.querySelectorAll('div');function check() { console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check, { capture: true, })); 이벤트 위임 방지 💡 event.stopPropagation()을 사용하면, 정확히 내가 이벤트를 발생시킨 엘리먼트에서만 이벤트가 발생한다. event.stopPropagation()의 활용예시12345678const divs = document.querySelectorAll('div');function check(e) { e.stopPropagation(); console.log(this.classList.value);}divs.forEach((div) =&gt; div.addEventListener('click', check)); 이벤트 위임의 활용 💡 Todo List를 만들때 자주 나타나는 현상인데,Todo리스트에 대한 event가 잘 작동하다가 새로운 리스트가 추가됐을 때 새로운 리스트에는 이벤트가 동작하지 않는 경우가 많다. event는 기존에 생성되어 있던 엘리먼트들에게만 적용되기 때문.‼️이를 해결하기 위해선, 위임을 활용하면 된다 상위 요소에 이벤트리스너를 적용해주면, 위임에 의해 새로운 엘리먼트가 추가되어도event가 추가된 요소에도 잘 할당된다.","link":"/javascript/wesbos/25.%20Bubling/"},{"title":"Wesbos - 드래그 슬라이드","text":"내가 디스트리 프로젝트에서 꽤나 애먹었던 기능이다.여러 웹사이트에서 볼 수 있는 드래그가 가능한 이미지 슬라이더를 구현해보는 챕터다. 로직 const와 addEventListener 선언 mousedown이 true일 때만 mousemove function 실행되도록 설정 마우스가 클릭 후 시작점 &amp; 드래그된 이동값 출력하기 마우스가 드래그 된 만큼 item들 움직이기 (부가적 기능) CSS적용해서 시각적 효과 더 입히기 const와 addEventListener 선언 💡 mousedown, mouseup, mousemove, mouseleave를 사용하면 된다. 12345678910111213141516const slider = document.querySelector('.items');// 다 한 번씩 찍어보기~slider.addEventListener('mousedown', () =&gt; { console.log('Down!');});slider.addEventListener('mouseup', () =&gt; { console.log('up!');});slider.addEventListener('mousemove', () =&gt; { console.log(&quot;It's moving!&quot;);});slider.addEventListener('mouseleave', () =&gt; { console.log('Leaved!');}); mousedown이 true일 때만 mousemove 함수 실행! 💡 드래그의 기본 동작 방식은 “클릭 → 마우스움직이기” 이므로 mousedown이 발생하지 않았을 때에는 mousemove에 대한 함수가 실행돼선 안된다. 12345678910111213141516let isDown = false;slider.addEventListener('mousedown', () =&gt; { isDown = true; // 클릭됐을 때 true 적용 console.log('Down!');});slider.addEventListener('mouseup', () =&gt; { isDown = false; // 당연히 마우스업 됐을 때에는 isDown이 false처리! console.log('up!');});slider.addEventListener('mousemove', () =&gt; { if (!isDown) return; // 클릭이 안됐을 때에는 isDown이 false이므로 return된다. console.log(&quot;It's moving!&quot;);}); mousedown 후 마우스 위치와 이동된 값 출력하기 💡 pageX,Y = 브라우저 내에서의 XY좌표를 반환하지만, 스크롤 화면을 포함해 계산한다.offsetX,Y = 이벤트 대상 객체가 기준이 되어 상대적 마우스 XY좌표를 반환 123456slider.addEventListener('mousedown', (e) =&gt; { isDown = true; console.log(e.pageX); console.log(slider.offsetLeft); // slider박스 옆에 엘리먼트가 추가되거나 마진이 생겼을 때를 대비 console.log(slider.scrollLeft); // 얼마나 움직였는지!}); 이러한 첫 클릭 시의 마우스 위치와 마우스를 움직인 만큼의 값을 변수화 하여 저장! 1234567891011// 미리 변수화!let startX;let scrollLeft;slider.addEventListener('mousedown', (e) =&gt; { isDown = true; startX = e.pageX - slider.offsetLeft; scrollLeft = slider.scrollLeft; console.log(startX); console.log(scrollLeft);}); 마우스가 드래그 된 만큼 스크롤 💡 scrollLeft = 오른쪽 또는 왼쪽으로 스크롤된 만큼의 값을 반환하거나, 이동하도록 명령할 수 있음 12345678slider.addEventListener('mousemove', (e) =&gt; { if (!isDown) return; e.preventDefault(); const moved = e.pageX - slider.offsetLeft; // 마우스가 움직인 상대값 const walk = (moved - startX) * 2; // 실제로 마우스를 움직인 절대적 값 slider.scrollLeft = scrollLeft - walk; // scrollLeft에서 walk를 빼주는 이유 : 그냥 walk만 주게 될 경우, 현재 스크롤된 만큼의 위치값은 저장되지 않음}); (부가적) CSS로 시각적 효과 넣어주기12slider.classList.add('active');slider.classList.remove('active'); 최종 완성 코드1234567891011121314151617181920212223242526272829const slider = document.querySelector('.items');let isDown = false;let startX;let scrollLeft;slider.addEventListener('mousedown', (e) =&gt; { isDown = true; startX = e.pageX - slider.offsetLeft; scrollLeft = slider.scrollLeft; slider.classList.add('active');});slider.addEventListener('mouseup', () =&gt; { isDown = false; slider.classList.remove('active');});slider.addEventListener('mousemove', (e) =&gt; { if (!isDown) return; e.preventDefault(); const moved = e.pageX - slider.offsetLeft; const walk = (moved - startX) * 2; slider.scrollLeft = scrollLeft - walk;});slider.addEventListener('mouseleave', () =&gt; { isDown = false; slider.classList.remove('active');});","link":"/javascript/wesbos/27.%20Drag_Slide/"},{"title":"Wesbos - 동영상 속도제어 Bar","text":"초반 챕터에서 다뤘던 동영상 제어 중, 동영상 속도를 시각적으로 이쁘게 조절할 수 있는 Bar를 만들어 제어하는 기능을 구현해봤다. 로직 const와 addEventListener (video, speed, speed-bar, mousemove 등등) mousemove에 따른 마우스 상대위치값 출력 speed-bar 값에 적용하여 CSS 변경 재생속도(playbackRate) 값 부여 CSS 디테일 다듬기 (grab → grabbing 등) const와 addEventListener 💡 mousedown, mouseup, mousemove 와 isDown 변수를 통해 드래그 이벤트 인식하도록 설정 1234567891011121314151617181920212223const video = document.querySelector('.flex');const stick = document.querySelector('.speed');const speedBar = document.querySelector('.speed-bar');// 이전 챕터에서 사용했던 방식과 동일하다.let isDown = false;function isClicked() { isDown = true; console.log('clicked!');}function cancelDown() { isDown = false;}function handleMove(e) { if (!isDown) return; console.log(&quot;it's Moving~&quot;);}stick.addEventListener('mousedown', isClicked);stick.addEventListener('mouseup', cancelDown);stick.addEventListener('mousemove', handleMove); mousemove에 따른 마우스 상대적 마우스 이동값 구하기 💡 e.pageY와 offsetTop, 그리고 offsetHeight를 활용해줘야 한다. 12345678function handleMove(e) { if (!isDown) return; y = e.pageY - stick.offsetTop; // 뒤의 offsetTop은 혹시 모를 stick 위치 변화에 대비 percentageY = y / stick.offsetHeight; // 페이지 내에서의 마우스y 값을 stick의 총 높이로 나누면 stick내에서의 상대적 위치값 도출 가능 height = Math.round(percentageY * 100) + '%'; // 이제 이 height값을 speedBar의 height CSS값에 부여해주면 된다.} speed-bar에 height 값 적용하여 CSS 변경 💡 height값을 1% ~ 100%로 변환하여 CSS값에 넣어주면 끝 12height = Math.round(percentageY * 100) + '%';speedBar.style.setProperty('height', height); 하지만, height뿐만 아니라 innerHTML 또한 변경해줘야 한다. 123playbackRate = percentageY * (max - min) + min;textContent = playbackRate.toFixed(1) + 'x';speedBar.innerHTML = textContent; num.toFixed(n) 💡 숫자를 소숫점 n자리수 만큼 반올림해준다 재생속도(playbackRate) 값 부여 💡 위의 내용까지 잘 이해했다면, 굉장히 쉽다. 123video.playbackRate = playbackRate;// 이거 한 줄이면 됨! 최종 완성 코드1234567891011121314151617181920212223242526272829303132const video = document.querySelector('.flex');const stick = document.querySelector('.speed');const speedBar = document.querySelector('.speed-bar');let isDown = false;function isClicked() { isDown = true; speedBar.style.setProperty('cursor', 'grabbing');}function cancelDown() { isDown = false; speedBar.style.setProperty('cursor', 'grab');}function handleMove(e) { if (!isDown) return; const max = 4; const min = 0.4; y = e.pageY - stick.offsetTop; percentageY = y / stick.offsetHeight; height = Math.round(percentageY * 100) + '%'; speedBar.style.setProperty('height', height); playbackRate = percentageY * (max - min) + min; textContent = playbackRate.toFixed(1) + 'x'; speedBar.innerHTML = textContent; video.playbackRate = playbackRate;}stick.addEventListener('mousedown', isClicked);stick.addEventListener('mouseup', cancelDown);stick.addEventListener('mousemove', handleMove);","link":"/javascript/wesbos/28.%20VideoController/"},{"title":"LeetCode - Flood Fill (Javascript)","text":"타겟 넘버와 연결되어 있는 요소들을 모두 새로운 색(숫자)으로 변환시키는 문제였다. 문제 설명 뭐 대충, 테이블이 주어지고, 타겟 넘버의 위치(행과 열), 그리고 바꿀 색깔(숫자)를 인자에 담아 보내준다는 뜻이다. An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with newColor. Return the modified image after performing the flood fill. Example 1: 타겟 넘버인 가운데(1,1)과 연결된 숫자들(동일한 숫자여야 함) → 새로운 색으로 칠해줌 (숫자 변경) 12345Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2:12Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2Output: [[2,2,2],[2,2,2]] 소스코드12345678910111213141516171819202122function floodFill(image, sr, sc, newColor) { const answer = image; const targetNum = image[sr][sc]; const maxRow = image.length; const maxColumn = image[0].length; let visited = {}; let idx; function traverse(r, c) { idx = r.toString() + c.toString(); if (visited[idx]) return; visited[idx] = true; const currentNode = image[r][c]; if (currentNode !== targetNum) return; answer[r][c] = newColor; if (r - 1 &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; maxColumn) traverse(r - 1, c); if (r &gt;= 0 &amp;&amp; r &lt; maxRow &amp;&amp; c + 1 &lt; maxColumn) traverse(r, c + 1); if (r + 1 &lt; maxRow &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; maxColumn) traverse(r + 1, c); if (r &gt;= 0 &amp;&amp; r &lt; maxRow &amp;&amp; c - 1 &gt;= 0) traverse(r, c - 1); } traverse(sr, sc); return answer;}","link":"/algorithm/leet/floodFill/"},{"title":"LeetCode - Max Area of Island (Javascript)","text":"Description 위에서 풀었던 문제와 굉장히 유사하다. 그냥 그 문제에서 최대 넓이만 구하면 되는 문제다! You are given an m x n binary matrix grid. An island is a group of 1‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. Example 1: 123Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]Output: 6Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2:12Input: grid = [[0,0,0,0,0,0,0,0]]Output: 0 Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 50 grid[i][j] is either 0 or 1. 소스 코드12345678910111213141516171819202122232425262728293031323334353637function maxAreaOfIsland(grid) { let answer = 0; let count = 0; const maxRow = grid.length - 1; const maxColumn = grid[0].length - 1; function traverse(row, col, grid) { // 아래 조건에 해당되면 해당 노드의 값은 1이 아닌 것! if ( grid[row] === undefined || grid[row][col] === undefined || grid[row][col] === 0 ) { return; } grid[row][col] = 0; // 매 재귀 실행 시, 1을 찾을 때마다 count++을 해준다. count++; traverse(row - 1, col, grid); traverse(row, col + 1, grid); traverse(row + 1, col, grid); traverse(row, col - 1, grid); } for (let i = 0; i &lt;= maxRow; i++) { for (let j = 0; j &lt;= maxColumn; j++) { if (grid[i][j] === 1) { traverse(i, j, grid); // 그리고 재귀가 끝났을 때, answer와 count 중 더 큰 값을 answer에 할당해준다. answer = Math.max(answer, count); // 그리고 다시 count는 0으로 초기화 해주면 된다. count = 0; } } } return answer;}","link":"/algorithm/leet/maxAreaOfIslands/"},{"title":"LeetCode - Number of Closed Islands (Javascript)","text":"Description 1이라는 물에 둘러싸인 0이라는 섬의 개수를 구하는 문제다. Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s. Return the number of closed islands. ExampleExample 1: 1234Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]Output: 2Explanation:Islands in gray are closed because they are completely surrounded by water (group of 1s). Example 2: 123Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]Output: 1 Example 3:123456789Input: grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]]Output: 2 소스코드1234567891011121314151617181920212223242526272829303132333435363738394041function closedIsland(grid) { let answer = 0; let temp = 1; // 행과 열의 끝 부분을 maxRow와 maxCol로 지정 const maxRow = grid.length - 1; const maxCol = grid[0].length - 1; // 헬퍼함수 traverse function traverse(r, c, grid) { // 현재 섬이 유효하지 않은 섬이거나(범위 밖), 1일 경우에는 재귀를 종료시킨다. if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] === 1) return; // 이 아래부터는 위의 조건문에 의해 모든 노드가 0일 때다. // r이 0이거나, 행의 끝에 닿았으면 -&gt; 갇힌 섬이 아니다. (c또한 마찬가지) if (r === 0 || r &gt;= maxRow || c === 0 || c &gt;= maxCol) { // 따라서 temp에 0을 할당해준다. temp = 0; } // 그리고 효율성을 위해 매 순회마다 0인 섬을 1로 변환시켜준다. grid[r][c] = 1; traverse(r - 1, c, grid); //상 traverse(r, c + 1, grid); //우 traverse(r + 1, c, grid); //하 traverse(r, c - 1, grid); //좌 } // 1. 우선 모든 grid를 탐색하기 위한 2중 for문을 아래와 같이 생성했다. for (let i = 1; i &lt;= maxRow; i++) { for (let j = 1; j &lt;= maxCol; j++) { // 효율성을 위해 i가 마지막 행일 때, j가 마지막 열일 때는 무시하도록 설정했다. if (i === maxRow || j === maxCol) continue; // temp는 매 반복마다 1로 초기화 한다. temp = 1; // 그리고 순회를 하다가, 노드가 0인 경우 헬퍼 함수를 실행시킨다. if (grid[i][j] === 0) { traverse(i, j, grid); // traverse가 끝났는데도 여전히 temp가 1이라면 갇혀있는 섬이라는 뜻이다. if (temp !== 0) answer++; } } } return answer;} 소스코드 (주석 제거)1234567891011121314151617181920212223242526272829function closedIsland(grid) { let answer = 0; let temp = 1; const maxRow = grid.length - 1; const maxCol = grid[0].length - 1; function traverse(r, c, grid) { if (grid[r] === undefined || grid[r][c] === undefined || grid[r][c] === 1) return; if (r === 0 || r &gt;= maxRow || c === 0 || c &gt;= maxCol) temp = 0; grid[r][c] = 1; traverse(r - 1, c, grid); traverse(r, c + 1, grid); traverse(r + 1, c, grid); traverse(r, c - 1, grid); } for (let i = 1; i &lt;= maxRow; i++) { for (let j = 1; j &lt;= maxCol; j++) { if (i === maxRow || j === maxCol) continue; temp = 1; if (grid[i][j] === 0) { traverse(i, j, grid); if (temp !== 0) answer++; } } } return answer;}","link":"/algorithm/leet/numberOfClosedIslands/"},{"title":"LeetCode - Number of Islands (Javascript)","text":"DescriptionGiven an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1:1234567Input: grid = [ ['1', '1', '1', '1', '0'], ['1', '1', '0', '1', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '0', '0', '0'],];Output: 1; Example 2:1234567Input: grid = [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'],];Output: 3; Constraints: m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] is '0' or '1' 소스코드123456789101112131415161718192021222324252627282930313233343536function numIslands(grid) { let answer = 0; const maxRow = grid.length - 1; const maxColumn = grid[0].length - 1; function traverse(row, col, grid) { // 재귀 endPoint if ( grid[row] === undefined || grid[row][col] === undefined || grid[row][col] === '0' ) { return; } // 위 조건 통과하면 현재 탐색하고 있는 node가 1이라는 뜻 =&gt; 0으로 바꿔줌 grid[row][col] = '0'; // 재귀 시작 (상하좌우 탐색) traverse(row - 1, col, grid); traverse(row, col + 1, grid); traverse(row + 1, col, grid); traverse(row, col - 1, grid); } for (let i = 0; i &lt;= maxRow; i++) { for (let j = 0; j &lt;= maxColumn; j++) { if (grid[i][j] === '1') { // 완전 탐색을 하는 것이기 때문에, 처음 1이 발견됐을 때 하나의 섬이 모두 0으로 바뀔 것이다. // 하지만 만약 다음 탐색에서 어떤 node가 1이라면, 그건 다른 동떨어져있는 섬일 것이다. (이전 섬은 모두 0이 된 상태기 때문) answer++; // 그러면 그 node를 다시 탐색하며 모두 0으로 바꿔주는 작업을 반복한다. traverse(i, j, grid); } } } return answer;}","link":"/algorithm/leet/numberOfIslands/"},{"title":"Wesbos - 타이머","text":"이전에 노마드코더의 클론코딩 강의에서 시도했다가 실패했던 것과 비슷한 챕터다…타이머 기능이라고 하면 굉장히 쉬워보이지만…. 막상 해보면 굉장히 복잡하다. 로직 const와 addEventListener 초(seconds)입력하면 → 분 : 초 형식으로 화면에 띄우기 input 박스 입력된 값을 함수에 전달! 띄워진 시간 countdown 타이머 종료 시간(endTime) 계산 → 띄우기 const와 addEventListener123456789const time = document.querySelector('.display__time-left');const endTime = document.querySelector('.display__end-time');const buttons = document.querySelectorAll('[data-time]');function startTimer() { // console.log(this.dataset.time);}buttons.forEach((button) =&gt; button.addEventListener('click', startTimer)); Seconds입력 → Minutes : Seconds 형식으로 반환 💡 분(Minutes) : 초 / 60초 (Seconds) : 초 % 60 12345function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; time.innerHTML = `${minutes}:${secondsLeft}`;} But, 이대로 실행할 경우 아래와 같은 문제가 발생한다 123456789// 조건을 걸어서 10 이하일 경우 앞에 0이 붙어서 출력되도록 해야한다.function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; // 초가 10보다 작을 경우, 0 붙임 const display = `${minutes}:${secondsLeft &lt; 10 ? '0' : ''}${secondsLeft}`; document.title = display; // 이건 그냥 타이틀에도 시간 표시되면 좋을 것 같아서 추가 time.innerHTML = display;} 지금 다시 코드를 봐보니까.. padend나 padstart를 사용했어도 됐을 것 같다. input박스에 입력한 값을 각 함수들에 전달하기 💡 submit 이벤트에 반응할 엘리먼트 및 함수를 만들고, 해당 함수에서 timer에 분값*60을 전송 → timer(seconds) 에서 displayTimer() 함수 실행하면 된다. 1234567891011function timer(seconds) { displayTimer(seconds);}function submitSeconds(e) { e.preventDefault(); const inputMins = this.minutes.value; timer(inputMins * 60);}document.customForm.addEventListener('submit', submitSeconds); 띄워진 시간을 카운트다운! 💡 가장 핵심적인 부분이다. setInterval을 활용해 1초마다 seconds가 —1 되도록 하고→ seconds가 00을 지나 마이너스 되면→ minutes가 —1 되도록 구현하면 된다. 123456789101112131415161718function timer(seconds) { const now = Date.now(); //현재 시간(날짜) 정보 const then = now + seconds * 1000; // then = 현재 시간 및 날짜정보 + 입력 seconds*1000 console.log(now, then); displayTimer(seconds); countdown = setInterval(() =&gt; { // ((현재 시간 + 추가된 시간) - 현재 시간) / 1000 // then은 고정값이고 Date.now는 계속 증가 =&gt; 즉, 값이 점점 마이너스 됨 const countSeconds = Math.round((then - Date.now()) / 1000); if (countSeconds &lt; 0) { clearInterval(countdown); return; } displayTimer(countSeconds); }, 1000);} 부가설명 ⇒ 즉, 고정된 시간 값 (then)에서 계속 증가하는 값을 빼주면 결국 countSeconds는 1초씩 줄어들게 된다. 종료시간 표시하기 💡 위의 내용들을 잘 수행했다면 어렵지 않다. 12345678function displayEndTime(timestamp) { const end = new Date(timestamp); const hours = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `종료 시간 ${ hours &lt; 10 ? '0' : '' }${hours} : ${minutes}`;} 최종 완성 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566let countdown;let working = false;const time = document.querySelector('.display__time-left');const endTime = document.querySelector('.display__end-time');const buttons = document.querySelectorAll('[data-time]');const quit = document.querySelector('.quit');function timer(seconds) { working = true; if (working == false) { return; } clearInterval(countdown); quit.style.setProperty('opacity', '100'); const now = Date.now(); const then = now + seconds * 1000; displayTimer(seconds); displayEndTime(then); countdown = setInterval(() =&gt; { const countSeconds = Math.round((then - Date.now()) / 1000); if (countSeconds &lt; 0) { clearInterval(countdown); return; } displayTimer(countSeconds); }, 1000);}function displayTimer(seconds) { const minutes = Math.floor(seconds / 60); const secondsLeft = seconds % 60; const display = `${minutes}:${secondsLeft &lt; 10 ? '0' : ''}${secondsLeft}`; document.title = display; time.innerHTML = display;}function displayEndTime(timestamp) { const end = new Date(timestamp); const hours = end.getHours(); const minutes = end.getMinutes(); endTime.textContent = `종료 시간 ${hours &lt; 10 ? '0' : ''}${hours} : ${ minutes &lt; 10 ? '0' : '' }${minutes}`;}function startTimer() { const seconds = parseInt(this.dataset.time); timer(seconds);}function quitTimer() { clearInterval(countdown); working = false;}buttons.forEach((button) =&gt; button.addEventListener('click', startTimer));quit.addEventListener('click', quitTimer);document.customForm.addEventListener('submit', submitSeconds);function submitSeconds(e) { e.preventDefault(); const inputMins = this.minutes.value; timer(inputMins * 60); this.reset();}","link":"/javascript/wesbos/29.%20Timer/"},{"title":"Wesbos - 두더지 잡기","text":"음… 실용성은 없을 것 같지만 그래도 그동안 배웠던 JS 지식들을 잘 활용할 수 있는 챕터였다.클릭해서 올라오는 두더지를 잡고, 잡은 수 만큼 스코어를 올리면 된다. 로직 const &amp; addEventListener “랜덤으로 반복되지 않게” 두더지가 올라오도록 하기 ( + 들어가는 것 까지) 두더지가 클릭된 횟수를 기억하기 해당 횟수를 스코어보드에 기록하기 const123const holes = document.querySelectorAll('.hole');const scoreBoard = document.querySelector('.score');const moles = document.querySelectorAll('.mole'); randomHole 함수를 만들어 보자 💡 임의의 두더지 구멍(hole)이 반환될 수 있도록 Math.random() 을 활용해보자 12345function randomHole() { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; console.log(hole);} 다 좋은데, 아래와 같이 동일한 hole이 출력된다.이 게임에선 난이도 조절을 위해 같은 hole에서 두더지가 나오지 않도록 할 것이기 때문에 아래와 같은 중복 반환 현상이 일어나선 안된다…! 123456789101112let lastHole;function randomHole() { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; if (hole == lastHole) { console.log('이미 나온 놈..!!'); return randomHole(); } lastHole = hole; // 여기서 hole은 lasthole로 지정된다. console.log(hole);} 두 값 사이의 난수 생성하기? 💡 예를 들어, 1과 5 사이에 있는 숫자들 중에 난수를 반환하고자 한다면, 아래와 같은 함수 및 공식을 활용하면 된다. 123function getRandomArbitrary(min, max) { return Math.random() * (max - min) + min;} 두더지가 튀어나오도록 해보자1234function popUp() { const hole = randomHole(holes); hole.classList.add('up');} 하지만! 들어가는 속도가 너무 일정하면 게임이 너무 쉽다… 그래서 들어가는 속도도 랜덤으로 해보고자 한다. 1234567891011121314function randomTime(min, max) { return Math.round(Math.random() * (max - min) + min);}function popUp() { // 0.2초 ~ 1초 사이의 랜덤한 숫자(초)를 반환한다. const time = randomTime(200, 1000); const hole = randomHole(holes); hole.classList.add('up'); // 0.2초 ~ 1초 사이에서 임의의 속도로 두더지는 다시 들어간다. setTimeout(() =&gt; { hole.classList.remove('up'); }, time);} 점수 계산123456789function scored(e) { if (e.isTrusted == false) { alert(&quot;Don't Cheating!!&quot;); return; } score++; this.parentNode.classList.remove('up'); scoreBoard.textContent = score;} isTrusted 💡 클릭 이벤트가 진짜 사용자에 의한 “물리적 클릭“에 의해서 이루어졌는지 확인할 수 있음 게임 시작버튼 활성화123456789101112131415function popUp() { const time = randomTime(200, 1000); const hole = randomHole(holes); hole.classList.add('up'); setTimeout(() =&gt; { hole.classList.remove('up'); if (!finished) popUp(); // 10초가 지나기 전까진 계속 false이므로 popUp돼야 함! }, time);}function start() { popUp(); finished = false; setTimeout(() =&gt; (finished = true), 10000); // 게임은 10초동안 진행된다.} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const holes = document.querySelectorAll('.hole');const scoreBoard = document.querySelector('.score');const moles = document.querySelectorAll('.mole');let lastHole;let finished = false;let score = 0;function randomTime(min, max) { return Math.round(Math.random() * (max - min) + min);}function randomHole(holes) { const index = Math.floor(Math.random() * holes.length); const hole = holes[index]; if (hole == lastHole) { console.log('이미 나온 놈!!'); return randomHole(holes); } lastHole = hole; return hole;}function popUp() { const time = randomTime(500, 1000); const hole = randomHole(holes); hole.classList.add('up'); setTimeout(() =&gt; { hole.classList.remove('up'); if (!finished) popUp(); }, time);}function scored(e) { if (e.isTrusted == false) { alert(&quot;Don't Cheating!!&quot;); return; } score++; this.parentNode.classList.remove('up'); scoreBoard.textContent = score;}function start() { scoreBoard.textContent = 0; popUp(); finished = false; setTimeout(() =&gt; (finished = true), 10000);}moles.forEach((mole) =&gt; mole.addEventListener('click', scored));","link":"/javascript/wesbos/30.%20Mole/"},{"title":"환율 계산기","text":"프리온보딩 구현 과제 API를 통해 환율값을 받아 와, 실시간 환율 계산을 할 수 있도록 하는 계산기를 구현해봤다. 배포 주소http://beefplz.s3-website.ap-northeast-2.amazonaws.com 사용 기술 및 스택 Stack React Hooks styled-components fetch Deploy : Netilfy Other : Git / GitHub Build Tool (Create React App) Code Quality Tool (Prettier) 디렉토리 구조 (CRA Project Structure)123456789101112131415161718192021222324src│├─components│ │ │ └─SelectConverter │ SelectBox.jsx│ │ SelectConverter.jsx│ └─TabConverter│ FormBox.jsx│ ResultBox.jsx│ TabConverter.jsx│├─constants│ index.js│├─pages│ MainPage.jsx│├─styles│ GlobalStyles.js│├─utils│ dateConverter.js│ 표기법 케이스 약속 폴더명 소문자로 작성 파일명 파스칼케이스 (PascalCase) 변수명 카멜 케이스 (camelCase) constants 대문자 + 언더바 조합 (BACKGROUND_COLOR) 레이아웃 MainPage.jsx의 기본 레이아웃은 화면에 가득 차도록 하여 그 안에 들어오는 두 계산기 컴포넌트들이 절반씩을 차지할 수 있도록 flex를 준다. 그리고 각 계산기 컴포넌트의 컨테이너는 50vw만큼을 준 뒤, display: flex를 주고 모두 중앙 정렬 시킨다. 탭 계산기 (박훈주, 이주영) 레이아웃 및 UI 설계 (input, select 로 입력값 설정 후 하단의 탭박스에 결과값 출력) 선택된 통화의 종류에 따라 Tab의 구성이 유동적으로 변화되도록 구현ex) 드롭다운 메뉴를 “USD” → “CAD”로 바꿀 경우, 탭 내부의 “CAD”는 제거되고 “USD” 추가. 선택된 Tab의 border-bottom만 제거되도록 구현 input 박스에 숫자만 입력되도록 설정 후 회계/통화 형식에 맞춰 콤마(,)가 천의 자리마다 찍힐 수 있도록 구현 ex) ‘2000’ 입력 시 ‘2,000’ 으로 출력 API를 통해 실시간으로 환율 데이터를 가져와서 환율 계산기 구현.환율 연산식 : `input 입력값 * (탭에서 선택된 통화 / 드롭다운에서 선택된 통화)` 컴포넌트 레이아웃TabConverter의 컴포넌트 구성 12345// TabConverter.jsx&lt;TabConverterContainer&gt; &lt;FormBox /&gt; &lt;ResultBox /&gt;&lt;/TabConverterContainer&gt; 기능 구현 기준통화를 변경할 때마다 아래의 Tab 리스트가 변경되어야 한다. 입력값이 1000 이상일 때는 셋째 자리수마다 콤마가 찍혀야 한다. 선택된 기준통화에 따른 국가들의 환율 환산값이 계산되어야 한다. 1. 기준통화 변경될 때마다 Tab 리스트 변경하기 constants에 tab에 들어갈 고정된 국가별 통화들을 배열로 입력해뒀다. 그리고 기준통화가 변경될 때마다 filter()를 활용해 tab배열이 변화되도록 구현했다. 123// ../constants/index.jsexport const TAB_CURRENCY = ['USD', 'KRW', 'JPY', 'CAD', 'HKD', 'CNY']; 12345678910111213// ResultBox.jsxuseEffect(() =&gt; { // useEffect를 통해 기준통화가 변경될 때마다 아래 함수가 실행되도록 했다. const handleTab = () =&gt; { // TAB_CURRENCT 상수를 불러와 filter한다. (기준통화와 같지 않은 값들만 필터링된다) let changedTabs = TAB_CURRENCY.filter((tab) =&gt; tab !== currency); // 그리고 Tabs에 기준통화가 제외된 새로운 배열이 담긴다 setTabs(changedTabs); // 그리고 첫 번째 탭으로 지정되어야 할 국가가 currentTab에 저장된다.(첫 탭이 디폴트로 선택되도록 하기 위함) setCurrentTab(changedTabs[0]); }; handleTab();}, [currency, setCurrentTab]); 2. 숫자에 콤마 표시, 그리고 소수점 자리수 제한 toLocaleString() 을 활용했으며, 원활하고 즉각적인 input value를 받아오기 위해 onChange와 onKeyUp 이벤트를 같이 사용했다. 12345678// onChange, onKeyUp 모두 사용&lt;input type='text' placeholder='값을 입력하세요' value={inputValue} onChange={(e) =&gt; handleType(e)} onKeyUp={(e) =&gt; handleType(e)}/&gt; 123456789101112131415161718192021const handleType = (e) =&gt; { // 1000이 넘어갔을 때 콤마를 붙여줘야 하는데... 콤마가 붙으면 더이상 숫자가 아니다. // 따라서 해당 값을 콤마를 제거한 상태로 초기화시켜줘야 한다. const pureString = e.target.value.split(',').join(''); if (isNaN(Number(pureString))) { return; } // 따라서 1000 이상의 값이 입력됐을 때 이전에 입력된 값이 콤마가 붙은 string이면 아래의 조건문에 걸리지 않는다. // 이 때문에 pureString을 선언하여 사용한건 것이다. if (Number(pureString) &gt;= 1000) { // 이 조건문에 해당된다면, 다시 콤마를 붙여줘야 한다. (toLocaleString을 활용했다) setInputValue( Number(pureString).toLocaleString('en', { maximumFractionDigits: 3, }) ); return; } // 1000보다 작으면 그냥 pureString을 넣어준다. setInputValue(pureString);}; toLocaleString() 사용법 123let testNum = 1234;// 한국식 회계 콤마 표준, 그리고 소수점은 둘 째 자리까지 허용testNum.toLocaleString('ko-KR', { maximumFractionDigits: 2 }); 3. 환율 계산 calculator()라는 함수를 만들어 계산했다. 123456789101112131415// ResultBox.jsx// 기준통화가 base, 상대국 통화가 target이다.const calculator = (target, base) =&gt; { // api 데이터의 value값은 다 USD기준이기에 'USDOOO'으로 표기되어있다. // 따라서 아래와 같이 앞에 USD를 붙여준 뒤 해당 값을 가져왔다. let targetRate = apiData.quotes[`USD${target}`]; let baseRate = apiData.quotes[`USD${base}`]; // 미국 통화가 기준이기에 모든 환율값의 분모는 USD다. 따라서 그냥 나눗셈을 해주면 자동 약분처리되기 때문에 쉽게 계산할 수 있다. // 계산식은 =&gt; (상대국 환율 / 기준국 환율) * input에 적은 액수 let exchangeRate = Number((targetRate / baseRate) * writtenMoney); // 마지막으로 해당 환율값의 소숫점은 둘째 자리까지, 콤마 표기도 해줘야 하기 때문에 아래와 같이 리턴해준다. return exchangeRate.toLocaleString('en', { maximumFractionDigits: 2, });};","link":"/projects/preonboard/1.currencyConverter/"},{"title":"견적서 요청 확인 페이지","text":"😎 프로젝트 소개 제조업 어드민 페이지를 가정하여, 각 필터별 견적요청서를 한 눈에 확인할 수 있는 웹페이지를 제작해봤다. 🪄 링크 깃헙 주소https://github.com/hoonjoo-park/estimate-board 배포 주소https://estimate-board-page.herokuapp.com/ 🔮 프로젝트 주요 기능 json-server를 통한 API fetch 기본적인 REST-API 중, GET요청을 활용하기 위해 json-server를 직접 사용하여 데이터를 요청받아 fetch 후 활용했다. 설치 1$ npm install json-server server 디렉토리 생성 index.js 구성 1234567891011121314151617181920// server/index.jsconst jsonServer = require('json-server');const path = require('path');const server = jsonServer.create();const router = jsonServer.router(path.resolve(__dirname + '/db.json'));const middlewares = jsonServer.defaults({ static: path.resolve(__dirname + '/../build/'),});const port = process.env.PORT || 3001;server.use(middlewares);server.use(jsonServer.bodyParser);server.use(router);server.listen(port, () =&gt; { console.log('JSON Server is running');}); db.json 구성 123456789101112131415161718// server/db.json{ &quot;requests&quot;: [ { &quot;id&quot;: 1, &quot;title&quot;: &quot;자동차 시제품 제작&quot;, &quot;client&quot;: &quot;A 고객사&quot;, &quot;due&quot;: &quot;2020.12.14&quot;, &quot;count&quot;: 2, &quot;amount&quot;: 100, &quot;method&quot;: [&quot;밀링&quot;, &quot;선반&quot;], &quot;material&quot;: [&quot;알루미늄&quot;], &quot;status&quot;: &quot;대기중&quot; } // ... 이하 생략 ]} fetcher 유틸함수를 통한 데이터 fetch 12// fetcher.tsxexport const fetcher = await (await fetch('/requests')).json(); 12345// mainPage.tsx에서 useEffect를 통해 초기 렌더링때마다 데이터를 받아 저장할 수 있도록 구현.useEffect(() =&gt; { const fetchData = fetcher(); setApiData(fetchData);}, []); 필터 카테고리 중복 제거 카테고리에 해당하는 값들이 업데이트 될 수도 있다는 것을 가정해야 한다고 생각했다.따라서 견적서에 존재하는 가공방식 및 재료를 모두 불러온 뒤 Set()을 활용해 중복을 제거했다. map을 통한 각 필드에 해당하는 Array 반환 12// 받아온 apiData를 map 돌려서 모든 값들을 배열에 담는다.const methodArr = apiData.map((data) =&gt; data.method); flat()을 활용하여 겹배열 해제 123// 하지만 위의 방식만 활용할 경우 [[],[],[]]과 같이 겹배열 형식이 반환된다.// 따라서 아래와 같이 flat()을 활용하여 겹배열을 하나의 배열로 풀어줬다.const methodArr = apiData.map(data =&gt; data.method);.flat(Infinity) Set을 활용하여 중복 제거 1234// 이제 하나의 배열이 만들어졌으므로, 중복을 제거해야 한다.// 가장 간편한 방법을 고안해 보았는데, Set을 활용하기로 결정했다.const methodSet = Array.from(new Set(methodArr)); onBlur 이벤트를 통한 Select박스 동적 여닫힘 기능 가장 헤맨 파트였다… 사실 굉장히 사소한 기능이라고 생각할 수 있으나, 사용자 입장에서는 일일이 필터 드롭다운을 닫아줘야 한다는 부분이 피곤하게 느껴질 것 같았다. 따라서 반드시 해당 기능을 구현하여 불편점을 개선해보고 싶었다. tabIndex 부여와 onBlur 이벤트 활용 12345// ul태그는 기본적으로 input태그가 아니기 때문에 focus가 되지 않는 요소다.// 따라서 아래와 같이 tabIndex를 수기로 부여해주어야 onBlur이벤트를 활용할 수 있다.&lt;ul onBlur={(e) =&gt; handleBlur(e)} tabIndex={0}&gt; 드롭다운&lt;/ul&gt; e.relatedTarget()의 활용 onBlur는 focusOut과 같다고 생각하면 된다. 즉, 포커싱이 된 요소의 포커스가 해제됐을 때의 이벤트를 리스닝하는 것이다. 🎫 Event &lt;a&gt; (단, href 포함됐을 때) &lt;link&gt; (단, href 포함됐을 때) &lt;button&gt; &lt;input&gt; (단, hidden이 설정된 경우는 제외) &lt;select&gt; &lt;textarea&gt; draggable이 적용된 모든 엘리먼트 e.relatedTarget은 이벤트를 리스닝하고 있는 엘리먼트에 focus/onBlur 됐을 때 함께 포커싱되거나 블러된 엘리먼트를 담아준다. 즉, 함께 포커싱 되거나 포커스 아웃된 엘리먼트를 표시해준다고 생각하면 된다. 123456789// handleBlur 함수const handleBlur = (e: React.FocusEvent&lt;HTMLUListElement&gt;, type: string) =&gt; { if (e.relatedTarget !== null) { return; } if (type === 'method') return setIsMethodOpen(false); if (type === 'material') return setIsMaterialOpen(false);}; 선택 카테고리에 따른 견적서 필터링 팀원과 함께 필터링 알고리즘을 고민하는 과정이 굉장히 유익했다.나 또한 시간복잡도가 너무 비효율적으로 변하는 것을 선호하지 않는데, 팀원 또한 같은 생각을 갖고 있어 같은 방향성으로 알고리즘을 구현하려 노력했다. 물론 프로젝트 완성 기한에 대한 고려 때문에… 결과적으론 시간복잡도를 O(n) 또는 O(nlogn)으로 구현해 내는 데에는 실패했지만, 과정 자체가 매우 유의미했다고 생각한다. 12345678910111213141516171819202122232425// getFilter.tsexport const getFilter = (apiData: Estimate[], categories: Category) =&gt; { const newData = []; for (let i = 0; i &lt; apiData.length; i++) { // target Array에서 필터링 되어야 하는 카테고리가 있다면 해당 값들을 모두 배열화 const methodFiltered = apiData[i].method.filter((data: string) =&gt; categories.method.includes(data) ); const materialFiltered = apiData[i].material.filter((data: string) =&gt; categories.material.includes(data) ); // Array.filter를 통해 일치되는 카테고리들만 배열화 되었다. // 따라서 target Array(선택된 카테고리들)를 각 데이터들이 모두 포함하는지 확인하는 절차가 필요하다. if ( // 만약 필터링된 각 데이터들의 카테고리 모음(array)의 길이가 기준 배열의 길이보다 길다면, // 이는 기준 배열이 target Arrat에 포섭된다는 뜻이다. 따라서 target Array는 기준 배열의 모든 요소들을 포함하고 있다는 뜻이 된다. methodFiltered.length &gt;= categories.method.length &amp;&amp; materialFiltered.length &gt;= categories.material.length ) { newData.push(apiData[i]); } } return newData;}; 🤔 회고 프로젝트 실행 초기에 Typescript + React에서의 절대경로 설정에서 꽤나 애를 먹었다. 하지만 tsconfig 파일에서 아래 두 코드만 추가해주니 쉽게 해결됐다. 12345678{&quot;compileOptions&quot; : { // 생략 &quot;jsx&quot;: &quot;react-jsx&quot;, &quot;baseUrl&quot;: &quot;src&quot;},&quot;include&quot;: ['src']} 팀원들과 페어 프로그래밍을 하며 협업에 대한 안목과 방법론 등을 더 단련할 수 있는 기회였다고 생각한다. 굉장히 훌륭한 팀원들과 함께 프로젝트를 진행할 수 있어서 배울 점이 너무나도 많다. 이를 동기부여 삼아 꾸준히 성장하는 개발자가 되도록 노력해야겠다…!!","link":"/projects/preonboard/3.estimation/"},{"title":"메신저 웹(1&#x2F;2)","text":"🖐 프로젝트 소개 Redux, Typescript, CRA를 활용하여 메신저 웹앱을 개발했다.사실 Typescript와 함께 Redux를 사용하는 것이 처음이었기에 많은 것들을 배울 수 있었다. 🧤 배포 주소https://messenger-web-b98e6.web.app/ 🎃 Redux의 활용 본 프로젝트에서는 Typescript + React를 사용했기 때문에 connect가 아닌, hook방식의 react-redux 상태관리 로직을 활용했다. 실제로 React-Redux 공식 문서에서도 Typescript를 활용할 경우 connect보다는 hooks의 사용을 권장하고 있다. Redux 디렉토리 구조 🦾 구현 내용 정리 Action action은 reducer를 실행시킨다! 기본 구조는 아래와 같다. 1234export const someAction = (data?) =&gt; ({ type : '', payload: data?,}); 위에서 정의된 type은 하나의 action의 **고유 주소값(이름)**이라고 생각하면 된다. 그리고 payload는 이 action이 Dispatch에 의해 불려질 때 함께 담겨져서 따라온 data라고 볼 수 있다. Reducer Reducer는 직접적으로 state에 변화를 준다. 아래와 같이 switch문을 활용하여 action type에 맞는 로직이나 의도된 기능을 한 뒤, state에 변화를 준다. 123456789101112131415161718// redux/reducers/auth.ts// 아래와 같이 초기 값을 지정해주는 것이 좋다.const initialState = { users: [], currentUser: null };export default function auth(state = initialState, action: any) { switch (action.type) { // action의 type이 GET_USERS일 때는 아래와 같이 기능 case GET_USERS: return { ...state, users: action.payload }; // action의 type이 UPDATE~일 때는 아래와 같이 기능 case UPDATE_CURRENT_USER: return { ...state, currentUser: action.payload }; // 어느 케이스에도 걸리지 않는다면 기존 state값을 반환한다. default: return state; }} ⚠️ 반드시 reducer는 export default 해줘야 오류없이 리듀서를 활용할 수 있다. 그리고 아래와 같이 리듀서가 여러개라면 아래와 같이 여러 리듀서를 하나로 묶어줘야 한다. 123456789101112// redux/reducers/index.tsimport { combineReducers } from 'redux';import auth from './auth';export type RootState = ReturnType&lt;typeof rootReducer&gt;;const rootReducer = combineReducers({ auth,});export default rootReducer; Store store는 하나로 모아진 reducer를 담는 최종 상태관리 담당자라고 볼 수 있다. 코드는 생각보다 간단하다. 우선 rootReducer를 store에 담아준다. 12345678// src/redux/store.tsimport { createStore } from 'redux';import rootReducer from './reducers';const store = createStore(rootReducer);export default store; 그리고 이후에 Provider를 통해 index.ts의 App컴포넌트를 감싸주면 초기 세팅은 끝이다. 123456789101112// src/index.ts// import라인 생략ReactDOM.render( &lt;React.StrictMode&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 🌮 컴포넌트에서의 state 활용(useSelect) 여기부터 실전이다.useSelect를 활용하여 컴포넌트 내에서 store에 있는 state에 접근할 수 있어야 한다. 하지만 이번 프로젝트에서는 초기 화면에서의 state접근이 선행되는 것이 아니라, firestore에 있는 유저 데이터를 fetch 후 → dispatch를 통해 store에 유저데이터를 먼저 넣어줘야 했다. 그림으로 크게 보자면, 로직은 이와 같다. App.tsx가 렌더링 되면 → useEffect내에서 DB의 users데이터를 불러온다 → 그리고 그 데이터를 dispatch에 담아서 → action 호출 → action에 맞는 reducer를 실행시킴 → 이제 users라는 state를 fetch해온 users데이터로 업데이트 해주는 것이다. ‼️ 우리가 계속 Promise&lt;pending&gt; 문제로 고생했던 것은, state가 dispatch에 의해 업데이트가 되기도 전에 useSelect로 state에 접근했기 때문이다. 따라서 data fetch → dispatch → useSelect가 될 수 있도록 위와 같은 코드 로직을 구현했다. ‼️ 이제 컴포넌트에서 useSelect를 호출 해보자. 12const userData = useSelect((state) =&gt; state);console.log(state); 분명 오류가 날텐데, 이는 typescript에서 state에 타입을 지정해주지 않았기 때문에 발생하는 문제다. 따라서 위에서 언급했던 rootReducer 파일로 이동 후, RootState 타입을 생성 후 export 해줘야 한다. 1234// redux/reducers/index.ts// 1. 이 코드를 rootReducer가 있는 파일에서 생성 후 export 해준다.export type RootState = ReturnType&lt;typeof rootReducer&gt;; 12345// 2. 이제 state를 사용하길 원하는 컴포넌트로 이동한다.// 3. 아래와 같이 state 매개변수에 RootState 타입을 지정해주면 더이상 타입오류가 나지 않는다.const userData = useSelect((state: RootState) =&gt; state); 🧛‍♂️ 컴포넌트에서의 dispatch 활용(useDispatch) Dispatch는 useDispatch를 통해 컴포넌트 내에서 action을 호출할 수 있다. 항상 action이 무슨 기능을 담당하는지 생각해야 한다. 유저를 업데이트하는 액션, 유저를 삭제하는 액션 등등 내가 필요한 액션을 명확히 정의한 후, dispatch를 통해 해당 액션을 호출하면 된다. 만약 이번 프로젝트에서 처럼, 내가 초기 화면에서 사용자 프로필을 눌렀을 때, 해당 사용자로 로그인 될 수 있도록 구현하고자 한다면? 프로필 박스의 onclick이벤트에 dispatch를 걸어주면 되는 것이다. 123456789101112131415161718interface Props { user: User;}export const AuthProfileBox = ({ user }: Props) =&gt; { // 1. dispatch를 아래와 같이 우선 dispatch라는 상수에 선언해주고 const dispatch = useDispatch(); // 3. 해당 Dispatch는 클릭된 유저의 유저데이터를 넘겨줘야 하기 때문에 아래와 같이 action에 user데이터를 넘겨준다. const handleSetCurrentUser = () =&gt; { dispatch(setCurrentUser(user)); }; return ( // 2. Profile박스를 클릭했을 때 dispatch가 실행되도록 한다. &lt;ProfileBox onClick={handleSetCurrentUser}&gt; &lt;img src={user.profileImage} alt='profile' /&gt; &lt;h3&gt;{user.userName}&lt;/h3&gt; &lt;/ProfileBox&gt; );}; 잘 이해가 되지 않는다면 아래의 action 코드 구조와 reducer 구조를 다시 확인해보자 action 1234567// 위에서 유저 프로필을 클릭했을 때 실행되는 액션이다.// 괄호 안에 있는 user가 중요하다. 이게 컴포넌트 측에서 담겨져서 와야하는 데이터를 의미한다.export const setCurrentUser = (user: User) =&gt; ({ type: UPDATE_CURRENT_USER, // 그리고 그 넘겨져온 데이터를 payload라는 키에 할당해준다. payload: user,}); reducer 12345678910export default function auth(state = initialState, action: any) { switch (action.type) { // 위의 경우가 이 action type에 해당된다. case UPDATE_CURRENT_USER: // 따라서 해당 action의 payload(선택된 유저)를 currentUser라는 state 할당하며 업데이트 해주는 것이다. return { ...state, currentUser: action.payload }; default: return state; }}","link":"/projects/preonboard/4.messenger/"},{"title":"기프티콘 거래 플랫폼","text":"🐯 프로젝트 소개 기프티콘 거래 플랫폼의 웹페이지를 클로닝하는 프로젝트를 진행했다.nextjs와 typescript를 사용하였으며, SSR에서의 데이터 및 props 전달, 그리고 E2E 테스트에 대해서도 학습할 수 있는 좋은 프로젝트 경험이었다. SSR 및 Nextjs 관련하여 학습 후 정리한 블로그 포스트 🤴 배포 주소https://gifticon-market.vercel.app/ 🗂 CNA 구조 🔡 텍스트 데이터의 정제 이번 프로젝트에서 가장 애를 먹은 파트였다.받아온 API 데이터와 실제 웹페이지의 텍스트 구조가 달랐기 때문에, 최대한 똑같이 만들어보고 싶은 욕심에 텍스트를 직접 정규표현식 및 유틸함수를 활용하여 정제 후 활용해봤다. API 데이터는 위처럼 받아와졌지만, 실제 화면에는 아래와 같이 입력되어야 했다. 따라서 getDescription()이라는 유틸함수를 직접 만들어서 API 데이터를 넣어서 보내주면, 실제 뷰와 동일한 형식의 텍스트 템플릿으로 받은 후 활용할 수 있도록 기능을 구현했다. 1234567891011121314151617// utils/getDescription.tsimport { Description } from '@types';export const getDescription = async (desc: string) =&gt; { // 1. 텍스트를 descriptions에 담아서 return해줄 것이다. let descriptions: Description[] = []; // 2. 위의 사진에서 볼 수 있듯이, [사용 불가 매장]이라는 라벨은 쓰이지 않는다. 따라서 아래와 같이 replace를 통해 삭제했다. const sliceRestricted = desc &amp;&amp; desc.replace('\\n[사용 불가 매장]\\n', ''); // 3. 그리고 각 주제별 텍스트들을 분리하기 위해 아래와 같이 본문들을 분리했다. (두 번의 띄어쓰기가 쓰인다는 공통점을 이용) const splitDesc = sliceRestricted.split('\\n\\n'); // 4. [OOO] 또는 *OOO 형태로 쓰여진 라벨을 본문과 분리하기 위해 아래와 같이 정규표현식을 사용했다. const normalRegex = new RegExp('\\\\[.*\\\\n', 'g'); const voucherRegex = new RegExp('\\\\*.*\\\\n', 'g'); // 이하 생략 -&gt; 아래에서 설명 예정 return descriptions;}; 위의 선언 코드들을 통해 데이터를 정제하기 위한 준비를 끝냈다. 이제 해당 데이터들을 어떻게 분리하여 템플릿에 맞게 정제했는지 아래의 코드를 통해 설명해보도록 하겠다. 12345678910111213141516// 위의 코드 const voucherRegex 바로 아래에 붙는 코드다. (각 배열 요소들에 대한 명령을 주기 위해 forEach 활용)splitDesc.forEach((text, i) =&gt; { // 만약 배열 요소에 [OOO]형식의 라벨이 있다면 rawLabel에 [OOO]형식을, 아니면 *OOO형식을 담는다. const rawLabel = text.match(normalRegex) ? text.match(normalRegex)![0] : text.match(voucherRegex)![0]; // 그리고 이제 양 옆에 있는 '[', ']'를 템플릿과 동일하게 삭제해준다. const labelString = rawLabel.replace('[', '').replace(']', ''); // 그리고 라벨을 제외한 본문 내용을 descText에 담아주고, 템플릿과 동일하게 -를 ·으로 바꿔준다. const descText = text.slice(rawLabel.length).replaceAll('-', '·'); // 이제 라벨과 본문으로 나눠진 텍스트를 하나의 객체에 담아 descriptions에 push해준다. const newDesc = { label: labelString, text: descText }; descriptions.push(newDesc); });// 함수를 호출한 곳에 descriptions를 리턴해준다return descriptions 이렇게 하면 내가 원하는 템플릿에 맞게 rawTextData를 정제하여 뷰에 띄워줄 수 있다.조금 하드코딩식으로 코드를 짜긴 했지만, 문제 없이 작동됐기에 추후 리팩토링이 가능하다면 공간복잡도 개선을 위해 forEach 내부에서 const들을 선언해주는 것이 아닌, 바깥에서 선언과 할당이 이루어질 수 있는 방법도 고려해보고자 한다. 🧦 meta태그 SEO를 위해 pages 디렉토리 안에 _document.tsx 파일을 만든 후 meta태그를 작성했다. 기존 CRA에서 작업을 할 때에는, 그냥 public의 index.html 파일에 들어가 meta, font, title, body 등에 대한 코드들을 직접 작성해줄 수 있었다. 하지만 NextJS의 경우에는 이를 직접 index.html 파일을 찾아 수정하는 것이 아닌, pages 디렉토리에 _document.tsx 파일을 생성 후 head와 body태그를 작성해줘야 한다. 아래의 코드는 본 프로젝트에서 사용한 _document.tsx 파일이다. 1234567891011121314151617181920212223242526272829303132333435import Document, { Html, Head, Main, NextScript } from 'next/document';class MyDocument extends Document { render() { return ( &lt;Html&gt; &lt;Head&gt; &lt;meta name='description' content='모바일 쿠폰 중고거래 사이트. 남들은 정가로 살 때, 나는 할인가로 산다' /&gt; &lt;meta name='keywords' content='쿠폰,상품권,기프티콘,기프티콘판매,기프티콘구매,기프티콘추천,기프티콘앱,편의점기프티콘,기프티콘선물,기프티콘사용법,모바일쿠폰,모바일상품권,중고쿠폰,중고장터,e쿠폰,할인쿠폰' /&gt; &lt;meta name='og:title' content='니콘내콘 - 국내 1위 기프티콘 플리마켓' /&gt; &lt;meta name='og:description' content='모바일 쿠폰 중고거래 사이트. 남들은 정가로 살 때, 나는 할인가로 산다' /&gt; &lt;link rel='icon' href='/favicon.ico' /&gt; &lt;/Head&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ); }}export default MyDocument; 코드 최상단에 next/document 에서 import한 Html, Head, Main, NextScript 태그(컴포넌트)는 빌드후에 html, head, main, script 태그가 된다. 이 컴포넌트들을 위에서 import하지 않으면 Next.js가 제대로 서버 사이드 렌더링을 할 수가 없다. 또한, _document.js는 서버에서만 실행되는 파일이므로 window.alert와 같은 전역객체 메소드를 사용할 수 없다. meta 태그? 메타태그는 HTML문서에 대한 주요 정보(요약본)를 담고 있는 태그다. meta태그는 (x)html 문서가 어떤내용을 담고있는지, 그리고 핵심키워드는 무엇이며, 저자가 누구인지 어떤 언어로 작성되었는지 등의 정보를 담고있다. 이 메타태그는 브라우저 뷰에는 표시되지 않지만 검색엔진이 쉽게 크롤링을 할 때 읽을 수 있다. 위에서 사용한 &lt;meta name=og:OOO&gt;는 카카오톡이나 노션 등에 링크를 붙여넣기 했을 때 나타나는 정보다. 아래 사진을 보면 쉽게 이해할 수 있을 것이다. 🧪 Cypress를 활용한 E2E테스트 처음으로 E2E 테스트라는 것을 해봤다.E2E테스트란 End to End 테스트로, 개발한 웹사이트를 유저의 입장에서서 직접 테스트 해보는 테스트를 뜻한다. 내가 만든 캐러셀이 잘 슬라이딩 되는지, 라우팅은 잘 되는지, 데이터가 잘 입력되는지 등등 여러 구현 테스트를 진행할 수 있다. 본 프로젝트에서는 이러한 E2E 테스트를 위해 cypress프레임워크를 선정했다. 가장 다운로드 수도 많았으며, 래퍼런스를 찾기 용이할 것 같다는 판단 하에서였다. Cypress 설치123$ npm install cypress --save-dev$ yarn add cypress -D 기본 설정 (package.json, tsconfig.json) 아래와 같이 두 파일들을 수정해주면 된다. 123456789// package.json&quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;lint&quot;: &quot;next lint&quot;, &quot;cypress:open&quot;: &quot;cypress open&quot;}, 123456// tsconfig.json&quot;compilerOptions&quot;: { ... &quot;types&quot;: [&quot;cypress&quot;]}, Cypress 실행해보기123$ npm run cypress:open$ yarn cypress:open 그러면 이와 같은 cypress 브라우저가 실행될 것이다. (필자는 사전에 test파일들을 모두 삭제했기 때문에 기본설치 파일들이 나타나지 않는것이니 본인 파일들과 다르다고 해서 걱정하지 않아도 된다.) test코드 작성하기 cypress/integration 디렉토리에 first.spec.tsx와 같이 임의의 테스트 파일을 생성해주자 그리고 아래와 같이 기본적인 테스트 코드를 작성해주면 된다. 1234567891011121314/// &lt;reference types=&quot;cypress&quot;/&gt;context('Home Page', () =&gt; { // 모든 테스트 실행 전에 아래 주소를 visit 한다. beforeEach(() =&gt; { cy.visit('http://localhost:3000'); }); it('h1태그를 찾아 니콘내콘이라는 텍스트를 포함하는지 테스트', () =&gt; { cy.get('h1').contains('니콘내콘'); });});export {}; 분명 오류가 날텐데, 아래의 설치과정만 마무리 하면 된다123$ npm install start-server-and-test --save-dev$ yarn add start-server-and-test -D 그리고 package.json파일에 한 줄의 코드를 더 작성해준다. 12345678&quot;scripts&quot;: { &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;, &quot;lint&quot;: &quot;next lint&quot;, &quot;cypress:open&quot;: &quot;cypress open&quot;, &quot;test&quot;: &quot;start-server-and-test dev 3000 cypress:open&quot; }, 이제 yarn test 또는 npm run test를 통해 작성한 테스트 케이스를 실행해볼 수 있다. 포스팅에 참고한 자료How to create integration test with Cypress in your Next.js project","link":"/projects/preonboard/6.gifticon/"},{"title":"메신저 웹(2&#x2F;2)","text":"🍄 이전 블로그 포스트 (1/2) 링크메신저 웹(1/2) 💊 기능 구현 및 TIL 메시지 답장 기능 답장 기능의 경우, 답장하기 버튼을 클릭하면 특정 문자열이 textarea에 입력되어야 했다. 이렇게 메시지 박스 안에 내가 답장하고자 하는 메시지의 기본 정보가 자동으로 textarea에 입력되어야 한다. 이를 위해 해당 정보를 담기 위한 replyObj라는 state를 생성했고, state의 컨트롤을 위한 action과 reducer를 생성했다. 내가 이 기능을 구현하기 위해 구상한 로직은 이하와 같다. 답장하고자 하는 메시지 내에서 답장 버튼을 클릭한다 (onClick) 컴포넌트에서 해당 메시지의 기본 정보 (메시지 작성자 이름, 메시지 정보)를 action의 payload에 담아 호출한다. replyObj state가 리듀서에 의해 업데이트 된다. 123456789// redux/actions/setReplyContent.ts (Action)import { ReplyUser } from 'types';import { SET_REPLY_CONTENT } from './types';export const setReplyContent = (replyObj: ReplyUser | null) =&gt; ({ type: SET_REPLY_CONTENT, payload: replyObj,}); textarea가 있는 컴포넌트에서 replyObj의 변화를 리스닝 하도록 useEffect를 활용한다. 위의 회신 기본 템플릿을 상수에 담아 textarea에 담아준다. 그리고 replyObj state를 null로 업데이트 한다. 1234567891011121314// components/ChatForm.tsx (textarea가 있는 컴포넌트)useEffect(() =&gt; { // 만약 replyObj가 null이 아니라면? if (replyObj) { // 1. 템플릿을 생성하고 (회신자 이름, 내용, (회신)) const replyTemplate = `${replyObj.userName}\\n${replyObj.content.text}\\n(회신)\\n`; // 2. 이를 textarea의 value와 연결된 state에 업데이트 시켜준다. setText(replyTemplate); // 3. 조건문의 단발성 실행을 위해 replyObj는 다시 null로 업데이트 해준다. dispatch(setReplyContent(null)); return; }}, [replyObj, dispatch]); textarea에서 Enter 개행 방지하기 쉬울 것 같았지만 생각보다 헤맨 부분이었다 textarea에서는 기본적으로 Enter키와 Enter + Shift키를 통해 개행이 가능하다. 하지만 shift + enter를 통해서만 개행이 되도록 하고, Enter키를 눌렀을 때는 개행이 아닌 submit이 실행되도록 이벤트 핸들러 함수를 구현해야 했다. 따라서 Enter 키를 감지하기 위해 form태그에 onKeyDown이벤트에 대한 핸들링 함수를 구현해줬다. 1&lt;form onKeyDown={(e) =&gt; handleKeyPress}&gt;&lt;/form&gt; 엔터키 입력 감지 123456789const handleKeyPress = (e: React.KeyboardEvent&lt;HTMLFormElement&gt;) =&gt; { // 만약 엔터키가 눌렸고, shift키는 눌리지 않았다면? (즉, 엔터키만 눌린 상태라면?) if (e.key === 'Enter' &amp;&amp; !e.shiftKey) { e.preventDefault(); // 미리 선언해둔 submit 버튼에 대한 ref를 불러와 click()이벤트를 실행시킨다. buttonRef.current?.click(); return; }}; textarea의 높이 동적으로 세팅하기 위에서의 답장 template이 textarea에 세팅되었을 때, 그 템플릿의 라인 수 만큼 textarea의 높이가 높아지도록 구현해야 했다. 기존에 팀원 주영님이 textarea에 값이 입력되며 개행이 될 때마다 textarea의 높이가 높아지도록 구현을 해주셨으나, setState에 의해 textarea에 값이 입력되는 것은 onChange로 인식되지 않는 것 같았다. 이 때문에 답장 버튼 클릭 후 템플릿이 입력됐을 때 템플릿의 라인 수 만큼 textarea의 높이값을 세팅해주는 작업이 필요했던 것이다. useRef를 통해 textArea에 대한 ref를 생성해준다. 1const textAreaRef = useRef &lt; HTMLTextAreaElement &gt; null; 정규표현식을 사용하여 (개행되어야 하는 라인 수 * 인풋의 높이)만큼 height값을 설정해준다. 123456789101112131415useEffect(() =&gt; { if (replyObj &amp;&amp; textAreaRef.current) { const replyTemplate = `${replyObj.userName}\\n${replyObj.content.text}\\n(회신)\\n`; setText(replyTemplate); // 개행되는 라인 수를 카운트 하기 위해'\\n'의 개수를 String.match()를 통해 계산해준다. const lineBreakRegex = new RegExp('\\\\n', 'g'); const lineBreakCount = replyTemplate.match(lineBreakRegex)!.length; // textarea가 자동으로 포커스 되도록! textAreaRef.current.focus(); // 한 줄당 기본 hieght값인 20px * 개행되어야 하는 수 +1 textAreaRef.current.style.height = (lineBreakCount + 1) * 20 + 'px'; dispatch(setReplyContent(null)); return; } }, [replyObj, dispatch]); reducer에서 state와 action의 type 지정하기 초기에 Redux에서 작업할 것들이 많아 action에 any타입을 지정해준 뒤에 작업을 진행했었는데, 이를 수정하는 과정에서 많은 것들을 배웠다. 우리가 상수 또는 state에 명확한 타입을 지정해 주듯이, action의 type과 payload에 대해서도 명확한 타입을 지정해주어 오류 발생의 가능성을 최소화 해야 한다. action의 기본 구조는 이하와 같다. 위에서 설명했듯이, 이에는 type과 payload가 들어가 있기 때문에 해당 액션이 사용되는 reducer에서 액션에 대한 명확한 타입지정을 해줘야 한다. 아래의 reducer 코드를 봐보자 123456789101112131415// action에 대한 인터페이스!interface ContentAction { type: typeof GET_CONTENT; payload: Content[];}// 위에서 만들어 둔 인터페이스를 action에 선언export default function content(state: ContentState, action: ContentAction) { switch (action.type) { case GET_CONTENT: return { ...state, content: action.payload }; default: return state; }} 위 코드를 보면 알 수 있듯이 GET_CONTENT에 해당하는 액션의 모든 값들을 명확하게 타입지정 해줬다. 이렇게 타입을 지정해줘야 내가 액션을 실행할 때 원치 않는 데이터가 담겨져 state가 의도하지 않은대로 업데이트 되는 오류를 최소화 할 수 있다. 근데 설명 없이 위의 솔루션 코드만 보면 “**type에 왜 typeof를 써줬지?**” 라는 의문이 들 수 있다. 위의 예시에서 사용한 GET_CONTENT는 하나의 value이다. 즉 GET_CONTENT 자체는 하나의 value이지, string이 아니기 때문에 GET_CONTENT를 바로 선언해주면 안되고, 앞에 typeof를 붙여줘야 인터페이스가 제 기능을 할 수 있는 것이다. string타입과 리터럴 타입 (GET_CONTENT)는 명확히 다르다는 것을 분명히 짚고 넘어가야 한다…!!","link":"/projects/preonboard/5.messenger2/"},{"title":"제 방을 소개합니다","text":"프로젝트 소개 인테리어 서비스 플랫폼을 가정하고, 컴포넌트 내에서 가구 및 인테리어 용품 정보를 손 쉽게 확인할 수 있는 서비스를 개발해 보았다. 이번 포스팅에서는 해당 개인 프로젝트를 진행하며 발생했던 문제들과, 해당 문제들을 어떻게 해결했는지 정리해보려 한다. 배포 주소 https://house-deco.netlify.app/ 🗂 z-index 제대로 짚고 넘어가기 툴팁 뱃지를 클릭했을 때 띄워지는 상품정보 박스가 툴팁뱃지에 가려지는 문제를 발견했다.그래서 간단히 z-index를 줘서 해결해보려 했지만, 아무리 z-index를 건드려봐도 해결되지 않았다… 문제는 z-index값이 비교되는 방식에 있었다. 나는 단순히 상품정보 박스의 z-index가 높으면 높은대로 제일 상단에 위치할 것이라 생각했었다. 하지만, 나의 컴포넌트 구조는 툴팁 뱃지 아래에 자식으로써 상품정보 박스가 위치해 있었기 때문에, 문제가 발생했던 것이다. 그림으로 설명해보면 아래와 같다. 이렇게 상품정보 박스의 z-index만 높여주면 된다고 생각했던 것이다. 하지만 이 경우에는 아래의 그림과 같은 계산방식이 적용된다. 즉, 결국 상품정보 박스들은 툴팁뱃지의 자식들이기 때문에 아무리 z-index를 높여줘도 부모를 이길 수 없었던 것이다. 그리고 더 나아가, 부모(툴팁뱃지)들의 z-index는 모두 0으로 고정되어 있었기 때문에, 그 같은 z-index값으로 우열을 가릴 수 없으므로 HTML 태그가 배치된 index 순서에 따라 z-index값이 부여됐던 것이다. 해결 방법 간단히 해결했다.상품정보 박스를 툴팁뱃지의 자식으로 배치하지 않고 형제 컴포넌트로 배치하니 문제가 해결됐기 때문이다. 그리고 각 상품정보 박스에 조건부 transform: translate(X, Y) 값을 줘서 박스들이 컨테이너 밖으로 돌출되지 않도록 하여 해당 작업을 마무리 했다. 코드툴팁뱃지 코드 상품정보 박스 코드 🎨 Border에 Gradient 주기 처음 해보는 작업이라 조금 헤맸다.그냥 단순하게 border에 gradient값을 주려고 애썼지만, 생각해보니 background를 활용한 트릭을 쓰면 해결될 문제였다. 부모 background 색의 디폴트 값에 원하는 색과 gradient값을 준다. 그리고 제품이 선택됐을 때 img에 border : 2px solid transparent 를 줘서 마치 border가 생긴것 과 같은 트릭을 준다. 코드border gradient 코드 (60~65번 라인) 🖱️ Drag &amp; Scroll 클릭했을 때 해당 제품의 위치로 translate을 하는 것은 그리 어렵지 않았지만, 드래그를 통해 제품 리스트를 스크롤되도록 구현하는 부분에서 조금 애를 먹었다. 처음에는 드래그값에 따라 움직여야 하는 distance값에 대한 state를 주고, 마우스 드래그 거리가 변할 때마다 해당 state를 업데이트해서 transform을 할까도 잠시 고민했었다. 하지만 그럴 경우 useRef를 쓰지 않는 이상 엄청나게 많은 리렌더링이 발생할 것 같아 바로 포기했다. 그러다가 scrollLeft값을 활용해서 이동을 시켜주면 어떨까 라는 생각이 들어 해당 방법을 적용해 보기로 했다. 내가 생각한 로직은 이하와 같다 우선, mouseDown이 아닐 때는 이동이 되지 않도록 isDown state를 생성 1234567891011121314151617181920212223242526272829303132const [isDown, setIsDown] = useState(false);export const ProductList = () =&gt; { // 1. isDown state 생성 const [isDown, setIsDown] = useState(false); // 2. mouseDown이 됐을 때 setIsDown을 true로! const handleDown = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; { e.preventDefault(); setIsDown(true); }; // 3. 손 떼면 isDown은 false const handleUp = () =&gt; { setIsDown(false); }; // 4. 마우스가 움직였어도 isDown이 아니면 return! const handleMove = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; { if (!isDown) return; e.preventDefault(); }; return ( // 마우스 이벤트에 따라 호출될 함수들 선언 &lt;ListContainer onMouseLeave={handleUp} onMouseUp={handleUp} onMouseDown={(e) =&gt; handleDown(e)} onMouseMove={(e) =&gt; handleMove(e)} &gt; &lt;ListUl&gt;...생략&lt;/ListUl&gt; &lt;/ListContainer&gt; );}; mouseDown &amp; mouseMove가 될 때 마우스 이동값을 구해 그 만큼 scroll되도록 구현 1) 가장 먼저, 첫 클릭된 위치를 기록해야 한다. 이를 위해 startX라는 state를 만들어준다. 12const [isDown, setIsDown] = useState(false);const [startX, setStartX] = useState(0); 2) 그리고 상대적 위치를 알아내기 위하여, useRef를 통해 DOM에 접근해 스크롤 박스 내에서의 이동값을 계산하기 위한 준비를 한다. 12345678910111213const [isDown, setIsDown] = useState(false);const [startX, setStartX] = useState(0);const [scrollLeft, setScrollLeft] = useState(0);const containerRef: any = useRef();const handleDown = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; { e.preventDefault(); setIsDown(true); // 우리의 컴포넌트 컨테이너는 중앙에 정렬되어 있기 때문에 offsetLeft값을 빼줘야 스크롤 박스 내에서의 상대적 위치 계산이 가능하다 setStartX(e.pageX - containerRef.current.offsetLeft); // 그리고 현재 스크롤된 만큼의 거리를 scrollLeft state에 업데이트 해준다. setScrollLeft(containerRef.current.scrollLeft);}; 3) 이제 마우스가 움직였을 때의 로직만 구현하면 된다. 12345678910const handleMove = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; { if (!isDown) return; e.preventDefault(); // mouseMoved에는 말 그대로 움직일 때마다의 마우스의 상대적 위치가 기록된다. const mouseMoved = e.pageX - containerRef.current.offsetLeft; // 그리고 toMove에는 위에서 저장된 마우스의 상대적 위치 - 처음 위치를 해주면 된다. const toMove = mouseMoved - startX; // 이제 스크롤박스 DOM의 scrollLeft 값을 업데이트 해주면 된다. containerRef.current.scrollLeft = scrollLeft - toMove;}; 전체 코드드래그 &amp; 스크롤 구현 컴포넌트","link":"/projects/preonboard/2.houseDecoration/"},{"title":"영양제 검색 서비스","text":"💎 프로젝트 소개 이번에는 고객이 원하는 영양제의 이름을 검색했을 때, 주어진 Mock Data 안에서 매치되는 영양제 목록을 불러와 화면에 출력해주는 무한스크롤 페이지를 제작했다. 📲 링크Git. https://github.com/hoonjoo-park/find-my-supplements 배포 주소. https://find-my-supplements.vercel.app/ 📩 onChange 이벤트에 따른 데이터 fetch 방식 논의 팀원들과의 논의 결과 두 종류의 fetch 방식이 추려졌고, 이하와 같은 논리적 이유에 따라 2번 data fetch 방식을 결정했다. 1. state에 모든 API Data를 담아둔 뒤 match 결과를 맵핑한다. ❌ 1번과 같은 경우는, 초기 렌더링 시에 한 번만 API요청을 보낸 뒤, state에 모든 데이터를 담아둔다. 그리고 input박스의 onChange 이벤트에 따라 String.match()를 통한 빠른 검색결과 리스팅을 구현할 수 있다. 장점 state 배열 내에서 빠르게 match값들을 찾아 리스팅해줄 수 있다. 데이터 정렬 횟수를 최소화 할 수 있다. 단점 만약 API데이터의 크기가 클 경우, 초기 데이터 fetch에 따른 로딩 시간이 굉장히 길어질 수 있다. 메모리를 너무 방대하게 차지하는 공간 비효율성이 초래될 수 있다. 2. onChange마다 해당 값에 맞는 데이터를 DB로부터 get 요청을 보낸다. ✅ 2번 방식의 경우, onChange 이벤트가 발생할 때마다, 서버에 Get요청을 보내는 방식이다. 초기에는 MongoDB와 Mongoose를 활용하여 백엔드에서 regex를 활용한 데이터 요청과 반환을 구현해보고자 했으나, 본 프로젝트에서는 mock data를 활용했다. 장점 데이터 fetch 로딩 및 렌더링 시간의 단축을 기대할 수 있다. 메모리 공간을 크게 차지하지 않아도 된다. 단점 onChange이벤트는 너무 잦은 이벤트를 야기하기 때문에, 서버에 너무 많은 요청이 일어나 서버에 과부하가 발생할 수 있다. 서버에서 응답 받은 데이터를 매 응답마다 정렬해줘야 한다. ✅ 2번 방식 채택, 그리고 단점 보완에 대한 고찰 이러한 두 방식의 극명한 장단점의 차이로 고민을 하던 중, 1번 방식의 경우, 현재는 데이터의 길이가 600개밖에 안되지만, 추후 확장 가능성을 고려했을 때 효율적이지 못한 방식이 될 것이라 판단하여 2번 방식을 활용하기로 결정했다. 우선, 최대한 API요청 횟수를 줄이기 위해 많은 고민을 했다. 그리고 정렬 기능의 효율성을 높이기 위해 데이터 정렬에 대한 시간복잡도 또한 고려하여 기능 구현을 했다. 이하는 위의 두 원칙을 최대한 실현하기 위해 본 프로젝트에서 활용한 방법들이다. 먼저, 잦은 요청과 그에 따른 데이터 처리량의 부하를 예방하기 위하여, 매 요청마다 모든 일치 데이터를 불러오는 것이 아닌, 상위 20개씩의 데이터만 우선적으로 불러와 이후의 데이터 페칭은 ‘무한스크롤‘방식을 통해 불러와지도록 기능설계를 했다. 또한, 한글 자음이나 모음만 입력됐을 경우에는 API요청이 가지 않도록 사전 방지를 해뒀다. 이후 데이터 간의 우선순위를 매기기 위해 임의로 registCount라는 필드를 DB에 추가했고, 이에 따라 고객이 찾을 확률이 높은 데이터가 먼저 불러와질 수 있도록 유도했다. 즉, 무작위로 데이터가 20개씩 페칭되는 것이 아닌, 고객이 찾고있을 영양제일 확률이 높은, 인기가 가장 많은 영양제를 순서대로 불러온 것이다. 이렇게 우선순위에 따른 데이터 페칭 기능을 구현하기 위해서는 정렬 기능의 구현이 필요했다. 이에 따라 우리 팀은 시간복잡도를 최소화 하기 위해 O(nlogn)의 시간복잡도를 갖는 병합정렬 방식을 채택했다. 사실 현재의 데이터 볼륨 수준에서는 시간복잡도가 크게 유의미하지는 않지만, 추후 데이터가 방대해질 수도 있기에, 정렬에 투입되는 시간비용을 최소화하고자 했다. 또한, 본 프로젝트에서 데이터를 검색하여 불러오는 방식이 onChange마다 get요청이 이루어지는 것이기에, 정렬기능에서도 최대한의 효율을 고려해야 한다고 판단했다. 1234567891011121314151617181920212223242526272829303132import { DataTypes } from '@types';export const mergeSort = (data: DataTypes[]) =&gt; { const merge = (left: DataTypes[], right: DataTypes[]) =&gt; { let mergedArr: DataTypes[] = []; let i = 0; let j = 0; while (i &lt; left.length &amp;&amp; j &lt; right.length) { if (left[i].registCount &gt;= right[j].registCount) { mergedArr.push(left[i]); i++; } else { mergedArr.push(right[j]); j++; } } while (i &lt; left.length) { mergedArr.push(left[i]); i++; } while (j &lt; right.length) { mergedArr.push(right[j]); j++; } return mergedArr; }; if (data.length &lt;= 1) return data; let middle = Math.floor(data.length / 2); let leftArr: DataTypes[] = mergeSort(data.slice(0, middle)) as DataTypes[]; let rightArr: DataTypes[] = mergeSort(data.slice(middle)) as DataTypes[]; return merge(leftArr, rightArr);}; 요약 🧙‍♀️ 문제 해결 과정과 방법 이번 프로젝트에서는 intersectionObserver를 활용한 무한스크롤 기능 구현과, setState의 비동기적 특성 및 dependency에 대한 미숙함에서 문제를 겪었다. 이에 대한 해결 과정 및 학습 정리 내용을 한 페이지에 담기에는 무리가 있다고 판단되어 개별적으로 포스팅 했다. React에서의 무한스크롤 (IntersectionObserver) setState의 비동기적 특성과 Dependency 🍰 요약 및 정리 잦은 API호출을 방지하기 위해 → 무한스크롤과 자음과 모음 예외처리를 했다. 검색과 데이터 호출에 투자되는 시간비용을 줄이기 위해 → 병합정렬 사용과 데이터에 우선순위를 부여했다.","link":"/projects/preonboard/7.supplement/"},{"title":"냄궁밈수 (밈 생성기)","text":"🧤 프로젝트 개요 원하는 사진을 고른 뒤, 센스 있는 문구를 넣어 자신만의 재밌는 밈을 생성할 수 있는 웹 페이지 📲 링크Git. https://github.com/hoonjoo-park/Namgoong-Meme-Soo 배포 주소. https://namgoong-meme-soo.vercel.app/ 🤷 사이트 이름이 왜 냄궁밈수인가..? 사실 특별한 이유는 없다.. 그냥 친구들과 얘기를 나누던 중 ‘밈‘이 들어가는 사이트 이름 작명을 부탁해봤다. 그러다가 그냥 우스갯 소리로, 영화 설국열차에서 크리스 에반스의 인상 깊은 대사였던(?) “Are You 냄궁밈수?”라는 헛소리가 나왔다. 그래서 친구들과 웃다가 “그래~ 그냥 그걸로 하자~”하며 사이트 이름이 냄궁밈수가 되었다. 🚚 밈 텍스트 박스 드래그 이동 기능 입력한 밈 텍스트가 마우스 드래깅을 통해 원하는 위치로 이동될 수 있도록 기능을 구현했다. 밈 제작의 기본 중 기본은, 텍스트 엘리먼트를 마우스 드래깅을 통해 위치를 자유자재로 조정할 수 있도록 하는 것이라 생각했다. 이에 따라 여러 고민을 하던 중, 예전에 드래그&amp;슬라이드 기능을 구현했던 방법과 유사한 접근 방법을 사용하여 엘리먼트 이동 기능을 구현해보기로 결정했다. onMouseDown(시작) → onMouseMove(이동) → onMouseUp(종료) 이와 같은 로직을 따르면 될 것 같았기에 위의 세 이벤트 리스너와 핸들링 함수를 사용했다. onMouseDown우선, 텍스트 박스 위에서 mouseDown이 됐을 때 저장해야 하는 값들이 꽤 많았다. 마우스의 초기 좌표값 : e.pageX, e.pageY 텍스트 박스의 초기 위치값 : offsetLeft, offsetTop 마우스가 다운됐는지 여부 : isDown(boolean) 이러한 값들을 handleMouseDown이라는 이벤트 핸들러 함수에서 이하와 같이 처리해줬다. 12345678const handleMouseDown = (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; { // 이러한 값들이 왜 필요한지는 아래의 설명을 읽다보면 이해가 될 것이다. setIsDown(true); setStartX(e.pageX); setStartY(e.pageY); setStartTop(e.currentTarget.offsetTop); setStartLeft(e.currentTarget.offsetLeft);}; onMouseMovemousemove 이벤트의 경우에는, 마우스가 텍스트 박스 위에서 움직일 때를 리스닝 하는 것이 아닌, window 위에서 마우스가 움직이는 것을 리스닝 하도록 처리해줘야 했다. 박스 위에서의 mousemove를 리스닝하도록 하면, 마우스가 박스 밖으로 나갔을 때 텍스트박스가 이동을 멈추는 문제들이 발생했기 때문이다. 따라서, 위에서 사용했던 isDown을 활용해 window에 addEventListener를 통해 mousemove 이벤트 리스너를 추가해줬다. 123456789// isResizing은 아래에서 설명할 텍스트박스 리사이징 기능에서 활용되는 state다.// 미리 간략하게 설명하자면, 리사이징 중에도 mousemove 이벤트를 활용하기에// 리사이징이 진행중일 때는 텍스트박스가 이동되지 않도록 미리 방지해준 것이다.useEffect(() =&gt; { if (isResizing) return; window.addEventListener('mousemove', handleMouseMove); window.addEventListener('mouseup', handleStopMoving);}, [isDown, isResizing]); 즉, mouseDown이 됐을 때 → useEffect를 통해 window에 mousemove 이벤트 리스너가 활성화 된다. 이제 마우스가 움직일 때를 핸들링하는 함수 handleMouseMove에 대해 다뤄보도록 하겠다. 1234567891011121314151617const handleMouseMove = (e: MouseEvent) =&gt; { // 마우스가 다운되지 않았을 때나, 리사이징 중일 때에는 해당 함수가 작동돼선 안된다! if (!isDown || isResizing) return; // toMoveTop과 toMoveLeft는 텍스트박스 엘리먼트가 움직여야 할 위치값을 나타낸다. const toMoveTop = e.pageY - startY + startTop; const toMoveLeft = e.pageX - startX + startLeft; // moveOptions는 텍스트박스가 이미지 밖으로 이동되는 것을 방지하기 위한 조건문 옵션이다. const moveOptions = toMoveTop + 10 &lt;= 0 || toMoveTop + inputRef.current!.offsetHeight - 10 &gt;= textBoundary!.bottom || toMoveLeft - inputRef.current!.offsetWidth / 2 + 10 &lt;= 0 || toMoveLeft + inputRef.current!.offsetWidth / 2 - 10 &gt;= textBoundary!.right; // moveOptions가 true라면 이미지 범위 밖으로 이동됨을 의미하기 때문에 textMover 실행을 방지해야 한다. if (moveOptions) return; textMover(toMoveTop, toMoveLeft);}; 좀 더 쉽게 설명하자면, 위의 사진과 같이 마우스를 클릭한 뒤,마우스가 움직인 거리만큼 텍스트박스가 이동되는 것이다. 조금 더 자세히 toMoveLeft와 연관지어 풀어 써보자면, 아래의 사진과 같이 표현할 수 있을 것이다. 이 때문에 위에서 const toMoveLeft = e.pageX - startX + startLeft 라는 계산식이 도출된 것이다. 이를 다시 풀어서 설명하면,마우스의 현재위치(e.pageX) - 처음 mouseDown 됐을 때의 위치(startX) = 마우스가 이동한 거리startLeft = 원래 offsetLeft 위치 따라서 마우스가 이동한 거리 + 원래 offsetLeft 값을 더해주면 → 마우스 드래그에 따른 박스의 위치(X)값이 계산되는 것이다. 이제 값을 구했으니 textMover라는 함수를 사용해 실제 박스를 해당 위치로 이동시켜주기만 하면 된다. 1234567// inputRef는 text박스를 의미한다const textMover = (top: number, left: number) =&gt; { // useRef를 활용하여 inputRef.current의 top과 left값을 위에서 계산해준 값으로 넣어주면 된다. inputRef.current!.style.top = `${top}px`; inputRef.current!.style.left = `${left}px`; return;}; onMouseUp 이제 텍스트 이동이 끝났을 때 이벤트들을 모두 remove 해주기만 하면 기능 구현이 모두 끝난다. 만약, onMouseUp에 따른 이벤트 리무빙을 해주지 않는다면, 텍스트가 계속해서 마우스를 따라다닐 것이다. 따라서 아래와 같이 이벤트 리스너들을 제거해줘야 한다. 12345const handleStopMoving = () =&gt; { setIsDown(false); window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleStopMoving);}; 이렇게 까지만 구현해주면, 텍스트 박스가 마우스 드래깅에 따라 원하는 위치로 이동되도록 하는 기능 구현이 모두 끝났다! 물론, 추후에 코드들을 조금 더 간결하고 가독성이 좋도록 리팩토링을 더 진행해볼 계획이다. 🕹 밈 텍스트 박스 리사이징 기능 사용자 입장에서 생각했을 때, 밈 텍스트의 위치조정 뿐만 아니라 텍스트 사이즈도 자유롭게 조절될 수 있으면 훨씬 더 편하게 밈을 만들 수 있을 것이라 생각했다. 따라서 텍스트 박스 엘리먼트의 크기가 조절될 수 있도록 함과 동시에, 폰트 사이즈 또한 박스 크기에 비례하여 줄어들고 늘어날 수 있도록 기능을 구현해보고자 했다. resizer 버튼 배치하기 위의 gif에 나타나 있듯이, 텍스트 박스 모서리에 네 개의 리사이저를 배치했다. 1234567891011121314&lt;Text className={isResizing ? 'active' : ''} onMouseDown={(e) =&gt; handleMouseDown(e)} onTouchStart={(e) =&gt; handleTouchStart(e)} ref={inputRef} fontSize={fontSize}&gt; {text['text']} // 각 리사이저들 (span태그를 사용했음) &lt;Resizer className='resizer leftTop'&gt;&lt;/Resizer&gt; &lt;Resizer className='resizer rightTop'&gt;&lt;/Resizer&gt; &lt;Resizer className='resizer rightBottom'&gt;&lt;/Resizer&gt; &lt;Resizer className='resizer leftBottom'&gt;&lt;/Resizer&gt;&lt;/Text&gt; mouseDown 이벤트 활용하기 그리고 각 리사이저들에 onMouseDown 이벤트 핸들러를 할당해줬다. onMouseDown에 할당된 resizeStart 함수는 위에서 사용했던 handleMouseDown 핸들러 함수와 굉장히 유사하다. 1234567891011121314const resizeStart = (e: React.MouseEvent, type: string) =&gt; { // 하지만 한 가지 다른 점은, 각 리사이저별로 마우스 이동 방향 및 거리에 따른 사이즈 조절 기준이 다르기 때문에 type을 담아서 보내줬다. setResizer(type); // leftTop, rightTop, rightBottom, leftBottom 등등 setIsResizing(true); // 마우스의 XY 시작점 setResizeStartX(e.clientX); setResizeStartY(e.clientY); // 패딩값을 제외한 순수 width height값을 getComputedStyle을 통해 반환받아 활용 const inputStyle = getComputedStyle(inputRef.current!); const inputWidth = parseFloat(inputStyle.width); const inputHeight = parseFloat(inputStyle.height); setStartWidth(inputWidth); setStartHeight(inputHeight);}; 그리고 위와 동일하게, useEffect를 활용하여 리사이징이 시작됐을 때(onMouseDown) window에 전역적으로 mousemove와 mouseup 이벤트 핸들러를 할당해 줬다. 1234567useEffect(() =&gt; { // setState는 비동기적 특성을 갖기 때문에, // 위에서 초기에 setResizer가 실행 됐어도, 첫 렌더링 때에는 resizer가 null이여서 아래와 같은 조건문을 명시 if (!resizer || !isResizing) return; window.addEventListener('mousemove', mouseResizing); window.addEventListener('mouseup', stopResizing);}, [resizer, isResizing]); mouseMove 이벤트를 통해 박스 크기 조절하기 가장 어려웠던 부분이다. 처음에는 그냥 마우스의 이동 거리를 매 이벤트마다 재할당 해주며 사이즈를 줄이거나 늘려주면 될 것이라 생각했지만, mousemove 이벤트를 setState가 따라가지 못해서 정확한 사이징이 이루어지지 않았다. 따라서, 차라리 계속 변경되는 엘리먼트의 사이즈를 계속 업데이트 해주는 것 보다는, 초기 width값을 고정시켜두고 마우스의 매 이동거리가 아닌, 총 이동거리를 계속 차감해주는 방식을 선택했다. 코드는 이하와 같다. 123456789const mouseResizing = (e: MouseEvent) =&gt; { // movedX, movedY는 그냥 마우스의 이동 거리다. const movedX = resizeStartX - e.clientX; const movedY = resizeStartY - e.clientY; // 폰트 사이즈는 아래에서 설명하도록 하겠다. handleFontSize(); // 그리고 handleResize에 해당 값들을 인자로 전달해준다. handleResize(movedX, movedY);}; 이 경우는 그냥 음수값만큼 startWidth에 더해주면 저절로 사이즈가 줄어들도록 값을 줄 수 있다. 하지만 이 경우는 movedX가 양수임에도, 의도한 기능은 width가 줄어들어야 하기 때문에 startWidth에서 해당 값을 차감해줘야 한다. 123456789101112131415161718192021222324const handleResize = (movedX: number, movedY: number) =&gt; { switch (resizer) { case 'leftTop': // 초기 width, height값에 움직인 만큼의 값을 매 이벤트마다 계산하여 사이즈값을 준다. // 하지만 위의 사진에서 설명했듯이, 리사이저마다 계산되어야 하는 방식이 다름에 유의해야 한다. inputRef.current!.style.width = `${startWidth + movedX}px`; inputRef.current!.style.height = `${startHeight + movedY}px`; break; case 'rightTop': inputRef.current!.style.width = `${startWidth - movedX}px`; inputRef.current!.style.height = `${startHeight + movedY}px`; break; case 'rightBottom': inputRef.current!.style.width = `${startWidth - movedX}px`; inputRef.current!.style.height = `${startHeight - movedY}px`; break; case 'leftBottom': inputRef.current!.style.width = `${startWidth + movedX}px`; inputRef.current!.style.height = `${startHeight - movedY}px`; break; default: return; }}; onMouseUp 위에서 사용한 mouseUp 핸들링 함수와 거의 유사하다. 123456const stopResizing = () =&gt; { setIsResizing(false); // mouse가 up 됐을 때 -&gt; window에 등록된 두 이벤트 핸들러를 삭제해 준다. window.removeEventListener('mousemove', mouseResizing); window.removeEventListener('mouseup', stopResizing);}; 💾 DOM을 이미지로 저장하기 dom-to-image와 file-saver 라이브러리를 활용했다. 설치 1$ npm install dom-to-image file-saver 코드 활용 로직 useRef로 이미지 박스 DOM에 직접적으로 접근한다 → dom-to-image를 통해 해당 DOM을 스크린샷 찍은 후 파일 url을 얻는다 → 해당 url을 file-saver에 전달하여 로컬에 사진이 저장될 수 있도록 한다. 1234567const saveImage = async () =&gt; { const image = imageRef.current; // domtoimage를 활용하여 원하는 DOM을 스크린샷 찍은 후 해당 이미지의 blob을 받는다. const png = await domtoimage.toBlob(image); // 그리고 file-saver를 통해 해당 blob(이미지)을 다운 받는다. saveAs(png, 'meme.png');}; 프로젝트 회고 음… 가벼운 마음으로 시작했지만, 굉장히 손도 많이 가고 꼼꼼함이 필요했던 프로젝트였던 것 같다. 그리고 처음으로 배포를 한 뒤에, 주변 지인들에게 사이트 활용을 부탁했고, 지인들로부터 보완사항 및 피드백을 받아 git issue에 등록했다. 그리고 매일 한 두개씩의 이슈들을 해결하려 노력했다. 특히 아래의 세 가지 기능들이 지인들로 부터 받은 피드백이었고, 해당 기능들을 추가 및 보완하기 위해 굉장히 애를 썼다. 텍스트 추가 및 삭제 기능 텍스트별 폰트 색상 적용 기능 텍스트박스 및 폰트 리사이징 기능 “우선 배포해라, 어차피 고쳐야 할 것들은 산더미다” 라는 말이 굉장히 와닿았던 프로젝트였다. 앞으로 다른 프로젝트를 할 때에도, 최대한 유저 입장에서 고민하며 개발을 하고, 배포 후에도 유저들의 피드백에 귀 기울일 수 있는 개발자가 되도록 노력해야겠다. 굉장히 유의미한 경험이었다. 🧏‍♂️","link":"/projects/presonal/namgoongmemesoo/"},{"title":"크로스 브라우징 (IE, Babel)","text":"🌐 크로스 브라우징이란? 크로스 브라우징은 웹사이트의 브라우저 호환성을 최적화 하는 것이다. 크롬, 인터넷 익스플로러, 엣지, 파이어폭스, 사파리 등등… 브라우저는 널리고 널렸다. 근데, 우리가 만든 웹사이트가 모든 브라우저 상에서 동일하게 기능하고 보여질까? 그랬다면 정~말 좋겠지만 아쉽게도 아니다. 각 브라우저들은 저마다 사용하는 렌더링 엔진이 다르다. 구글(크롬)의 경우 블링크(Blink)라는 렌더링 엔진을 사용하고, IE는 트라이던트라는 엔진을 사용한다고 한다. 이렇듯, 모든 브라우저가 우리의 웹사이트와 코드를 동일하게 이해하고 처리하지 않는다는 점을 이해해야 한다. 그럼 모든 브라우저에 대한 호환성을 고려해야 할까? 물론 그건 아니다, 향후에 기술이 비약적으로 발전하여 그러한 세상이 올 수도 있겠지만, 현재로썬 가장 사용률이 높은 브라우저들을 추려낸 뒤, 이에 대응하는 것이 효율적인 방법이라고 할 수 있다. Browser Market Share Worldwide | Statcounter Global Stats 우선 statcounter의 데이터로 봤을 때, 세계에서 가장 점유율이 높은 브라우저는 감사하게도 구글 크롬이다. 그리고 2위는 사파리, 그 이외에는 거의 유의미한 차이가 드러나지 않는 수준으로 Firefox, Edge, 삼성 인터넷 등의 순이다. 이렇게만 봤을 때는 “어? 크롬에 집중하되, 사파리랑 파이어폭스, 엣지 정도만 호환성에 신경써주면 되겠는데?” 할 수도 있다. 하지만… 전세계 브라우저 사용 점유율 (출처 : statcounter) 우리 대한민국은 IT 강국일 뿐만 아니라, IE 강국이기도 한 것 같다… 대한민국 브라우저 사용 점유율 (출처 : statcounter) IE가 거의 25% ~ 30%대를 점유하고 있는 모습이다. 이 때문에 대한민국의 개발자들은 IE와의 씨름을 해왔어야 했다. 심지어 IE는 버전도 너무 다양하다. IE8, 9, 10, 11… 다른 브라우저들 처럼 자체적으로 업데이트가 되는 것이 아니라, 사용자가 직접 필요하면 업데이트를 진행하는 방식을 취하고 있다. 이를 조금 더 비극적으로 설명하면, 어디선가는 아직도 IE8, 그리고 IE9를 사용하고 있는 유저들이 있을 수 있다는 것이다 🤦‍♂️ Goodbye IE! 정말 말 그대로 ‘Good’ ‘Bye’다. IE(인터넷 익스플로러)는 2022년 6월 15일에 서비스가 전면 종료된다. 이후 Microsoft Edge가 윈도우의 브라우저를 공식적으로 대체한다. 근데 뭐 마이크로소프트가 개발자들의 편의를 생각한 것은 아니고, 주요인은 IE의 보안 취약성 때문이라고 한다. 한국인터넷진흥원에 의하면, 2020년 하반기 우리나라에서 사이버 공격에 쓰인 소프트웨어 취약점 중 인터넷 익스플로러의 취약점이 100%를 차지했다고 하니… 정말 이제는 IE를 역사 속으로 묻어줘야 할 때가 오지 않았나 싶다. 물론, 재야에는 윈도우 XP를 사용하고 있는 사용자들이 존재할 수도 있다. 하지만 아래의 통계자료를 확인해보자. (XP는 IE8까지만 지원된다) 이 **0.12%**를 위해서 우리가 개발 단계에서 골머리를 앓아야 하는걸까…? 시대는 변하고 기술은 그보다 더 빨리 격변한다..! 따라서 이제는 크롬, 사파리, 파이어폭스, 엣지에 대응하여 개발을 하는 것이 크로스 브라우징의 기본이자 정석이 되지 않을까 싶다. 🏋️ Babel이란? 트랜스파일러? (Transpiler) compiler는 우리가 작성한 코드를 바이트 코드로 변환한다.그리고 transpiler는 코드를 같은 레벨의 다른 언어로 변환한다. 즉, 바벨은 자바스크립트 코드를 자바스크립트 코드로 변환해주는 트랜스파일러다. “엥? JS → JS라고?” 할 수도 있는데, 물론 똑같은 것을 똑같이 변환해준다는 것이 아니라, ES6 문법으로 쓰인 JS코드를 ES5로 변환해주는 것이다. 그럼 ES5와 ES6는 무엇일까? ES5와 ES6 ES5와 ES6는 ECMAScript5, 6를 의미한다. ECMAScript는 ECMA라는 기관에서 만들어낸 script 언어로, 하나의 언어이자 표준이다. 이는 ECMA-262라는 표준을 따르고 있다고 한다. 특히, 2015년 6월부터 매 년 꾸준히 버전을 업그레이드 하고 있는데, 이 2015년에 배포된 버전이 ES6다. 근데 위의 표를 보면… ES12까지 출시가 됐는데 왜 우리는 ES6를 여전히 최신 기술로 여기며 이를 공부하고 있는 것일까? 이는 ES5에서 ES6로의 업데이트에는 큰 변화가 있었고, 이미 ES6에서 이전에 존재했던 많은 문제점들과 가독성, 그리고 효율성 등의 개선이 이루어졌기 때문이다. 그럼에도 우리는 코딩을 하여 ES6 이상의 기능들을 사용하고 있기도 하다. async await, 제곱연산자(**), String.padStart 등등 ES6를 기반으로 새로운 기능들을 추가해 사용하고 있는 것이다. 따라서 이제는 ES6가 추후 출시된 버전들의 기반이 되는 것이라고 볼 수 있기에 ES6를 공부하는 것이 우리에겐 중요하다. 그럼 이제 Babel을 설치하는 법과, 기본 활용법에 대해서 알아보도록 하자. 설치 및 기본 템플릿1$ npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/polyfill 설치가 완료됐다면? → 루트 디렉토리에 .babelrc 파일을 생성하고, 아래와 같이 코드를 붙여 넣는다. 123456789101112131415161718{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot; { &quot;targets&quot;: { &quot;edge&quot;: &quot;17&quot;, // 엣지 17버전 까지 커버를 할 수 있도록 트랜스파일링 할 것이란 뜻 &quot;firefox&quot;: &quot;60&quot;, &quot;chrome&quot;: &quot;67&quot;, &quot;safari&quot;: &quot;11.1&quot;, &quot;ie&quot;: &quot;11&quot; }, &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: &quot;3.6.5&quot; } ] ]} CLI를 통한 트랜스파일링 실행 1./node_modules/.bin/babel [변환 대상 폴더 또는 파일] --out-dir [변환 결과를 담을 폴더] 12## npx가 설치되어 있다면 이렇게 간단한 형태로도 트랜스파일이 가능하다.$ npx babel [타겟 폴더 또는 파일] --out [결과를 담을 폴더] 이를 터미널에서 입력해 주면, 변환할 폴더의 JS파일들이 트랜스파일 되어 설정한 디렉토리에 저장된다. 또는 npm build를 커스텀해도 된다. 이하와 같이 하면, npm run build만으로도 바벨 커맨드를 실행할 수 있다. 1234567// package.json{ &quot;scripts&quot;: { &quot;build&quot;: &quot;babel src -d dist&quot; }} Polyfill “충전 솜” 이라는 뜻이다. 물론 Babel에서 ES6 → ES5로 트랜스파일링 할 때, 거의 대부분을 대응해주기는 하지만, 아예 없던 기능이 새로 추가된 경우 등에는 추가적인 대응이 필요하다. 따라서 Babel만을 사용해서 완전한 트랜스파일링을 기대하는 것은 힘들고, 폴리필(Pollyfill)을 통해 arrow Function이라던지, Set이라던지, 이러한 새로운 기능들이 트랜스파일링 될 수 있도록 해야 한다. 하지만 Babel 7.40 버전부터 babel 자체에서 지원하던 babel/polyfill이 지원종료 되었기 때문에 다른 대안을 활용해야 한다. 이 때 사용하는 것이 core-js다. core-js 설치1$ npm install core-js@3 12345678910// .babelrcpresets: [ [ '@babel/preset-env', { useBuiltIns: 'usage', // 필요한 폴리필만 추가 corejs: 3, }, ],], 또는, @babel/plugin-transform-runtime 을 사용할 수도 있다. 1$ npm i --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs3 12345678910111213// webpack.config.jsoptions: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, proposals: true, }, ], ], }, 🎨 CSS 크로스 브라우징 CSS작업을 할 때 IE 크로스브라우징 대응을 하며 정말 경악을 금치 못했다…설마…? 하고 Can I Use에 들어가 검색을 해보면 IE에서 지원하지 않는 것들이 너무나도 많았다. 따라서 프로젝트 진행 중, 크롬에서는 헤더 하단에 box-shadow가 보여지게 하고, IE에서는 그에 대한 대안으로 border를 주기로 결정했었다. 근데 문제는 chrome에서는 border가 보여지지 않고, box-shadow만 적용되게 하고 싶었다. CSS Hack 이 때 필요한 것이 CSS Hack이다. 아래의 코드를 스타일 뒤에 붙여주면 된다. IE 8, IE9, IE8+9 hack \\0/IE8 : IE8 에서 적용 \\0/IE9 : IE9에서 적용 \\0/IE8+9 : IE8과 IE9 모두 적용 12345.gnbNav.scrolled { box-shadow: 0px 1px 3px 0px rgba(255, 202, 67, 0.7); border-bottom: 1px solid $mainColor \\0 / IE8 + 9; border-bottom: none;} 123456789/* IE10 이상에만 적용하고 싶을 때 */@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) { /* CSS를 여기부터 작성 */}/* 또는 */@media all and (-ms-high-contrast: none) { /* CSS를 여기부터 작성 */} IE8 이하에선 시멘틱 태그가 사용 불가능 하다. 굉장히 충격적이었다… 이 때문에 모든 시맨틱 태그들을 div태그 또는 ul태그로 변환하는 작업을 했다… 정말 이번 프로젝트를 하며, 선배 개발자 분들에게 경의를 표하고 싶었다. IE가 미워졌다… 🏀 결론 및 요약 내가 만든 웹사이트는 모든 브라우저에서 동일하게 보여지고 기능하지 않기에 크로스 브라우징을 해야 한다. IE는 버전별로 자동 업데이트가 되지 않기에, 버전별 대응을 해줘야 한다. 하지만, IE는 2022년 6월 15일에 서비스가 전면 종료된다. Babel을 통해 ES6로 작성한 코드를 ES5로 트랜스파일 할 수 있다. CSS 또한 크로스 브라우징에서 꼼꼼하게 검토되어야 한다. (Can I Use 사용) 포스팅에 참조한 자료Babel · The compiler for next generation JavaScript 지금 바로 시작하는 ES6 : NHN Cloud Meetup Can I use… Support tables for HTML5, CSS3, etc","link":"/projects/preonboard/8.crossBrowsing/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"Sementic Web","slug":"Sementic-Web","link":"/tags/Sementic-Web/"},{"name":"구현","slug":"구현","link":"/tags/%EA%B5%AC%ED%98%84/"},{"name":"구조","slug":"구조","link":"/tags/%EA%B5%AC%EC%A1%B0/"},{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"정렬","slug":"정렬","link":"/tags/%EC%A0%95%EB%A0%AC/"},{"name":"해시","slug":"해시","link":"/tags/%ED%95%B4%EC%8B%9C/"},{"name":"완전탐색","slug":"완전탐색","link":"/tags/%EC%99%84%EC%A0%84%ED%83%90%EC%83%89/"},{"name":"스택&#x2F;큐","slug":"스택-큐","link":"/tags/%EC%8A%A4%ED%83%9D-%ED%81%90/"},{"name":"빅오","slug":"빅오","link":"/tags/%EB%B9%85%EC%98%A4/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"배열과 오브젝트","slug":"배열과-오브젝트","link":"/tags/%EB%B0%B0%EC%97%B4%EA%B3%BC-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"문제해결","slug":"문제해결","link":"/tags/%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0/"},{"name":"예제","slug":"예제","link":"/tags/%EC%98%88%EC%A0%9C/"},{"name":"재귀","slug":"재귀","link":"/tags/%EC%9E%AC%EA%B7%80/"},{"name":"탐색","slug":"탐색","link":"/tags/%ED%83%90%EC%83%89/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"브라우저","slug":"브라우저","link":"/tags/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/"},{"name":"Wesbos Challenge","slug":"Wesbos-Challenge","link":"/tags/Wesbos-Challenge/"},{"name":"BFS&#x2F;DFS","slug":"BFS-DFS","link":"/tags/BFS-DFS/"},{"name":"개인 프로젝트","slug":"개인-프로젝트","link":"/tags/%EA%B0%9C%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"}],"categories":[{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"프론트엔드","slug":"프론트엔드","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"},{"name":"Next.js","slug":"프론트엔드/Next-js","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Next-js/"},{"name":"React","slug":"프론트엔드/React","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/React/"},{"name":"Redux","slug":"프론트엔드/Redux","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Redux/"},{"name":"Typescript","slug":"프론트엔드/Typescript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Typescript/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Udemy","slug":"알고리즘/Udemy","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Udemy/"},{"name":"백준","slug":"알고리즘/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"},{"name":"프로그래머스","slug":"알고리즘/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Javascript","slug":"프론트엔드/Javascript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Javascript/"},{"name":"LeetCode","slug":"알고리즘/LeetCode","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/LeetCode/"},{"name":"프로젝트","slug":"프로젝트","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"네트워크","slug":"CS/네트워크","link":"/categories/CS/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"},{"name":"브라우저","slug":"CS/브라우저","link":"/categories/CS/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80/"},{"name":"프리온보딩","slug":"프로젝트/프리온보딩","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/%ED%94%84%EB%A6%AC%EC%98%A8%EB%B3%B4%EB%94%A9/"},{"name":"개인","slug":"프로젝트/개인","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/%EA%B0%9C%EC%9D%B8/"}]}