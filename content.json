{"pages":[],"posts":[{"title":"1.Redux 기초","text":"내가 userObject를 component에 전달하던 방식 이전까지는….최상단 루트인 App.js에 userObject를 두고, 유저 정보의 변경을 루트에서 하향식으로 각 컴포넌트에 뿌려줬다. 근데 이런 방식이 굉장히 불편하고 비효율적이라고 느껴졌다. 이에 따라, 가장 널리 알려진 상태관리 라이브러리 Redux를 통해 state들을 관리해보고자 한다.특히, userObject를 계속 props를 통해 컴포넌트에게 뿌려주는 것이 가장 귀찮고 번거로웠다… Redux 기본 컴포넌트 안에서만 사용되던 state를 이제 store라는 곳에 담아두고 사용한다.그리고 필요한 컴포넌트에서 해당 store를 구독(subscribe)하고, 해당 state가 변경되면 그 state를 구독하고 있는 컴포넌트가 리렌더링 된다. 기본 로직과 컨셉 -뷰에서 Dispatch를 통해 Action을 발동시킨다 -그리고 해당 Store에서, 정해진 reducer를 통해 state를 변경한다. -해당 state(store)를 구독하고 있는 컴포넌트는 리렌더링 된다. Redux 설치 참고로, Redux는 React를 위해서 만들어진 라이브러리가 아니다…순수 javascript 앱을 위해 만들어진 것이기 때문에 react-redux를 통해 redux와 react를 연결시켜줘야 한다. 12$ npm install redux react-redux redux-logger$ npm install --save redux-devtools-extension Reducers reducer는 하나의 함수다.현재 state와 action 오브젝트를 받고, 만약 필요하다면 state를 update해준다. 🔥 불변성을 지켜야 한다. Redux는 참조값을 기준으로 state가 업데이트 된 것인지 아닌지를 판단한다. 따라서 직접적으로 state를 업데이트 하면, 참조값이 변했다는 것을 인식하지 못한다. 12// 올바른 불변성 유지 방법state.something = {...something, action.something} reducer 생성 123456789101112131415161718192021222324// Actionexport const updateUserAction = 'Update_User';// Action Creatorexport const updateUser = (user) =&gt; ({ type: updateUserAction, payload: user,});const initialState = { user: { test: 'hello' } };function updateUserReducer(state = initialState, action) { // reducer가 이 action을 참조하는지 체크 if (action.type === updateUserAction) { // 만약 참조한다면, state를 복사 return { ...state, // 그리고 새로운 값을 업데이트 해준다. user: state.user, }; } // 위 조건에 해당되지 않으면 그냥 기존 state값을 리턴해준다. return state;}export default updateUserReducer; rootReducer 생성 위에서 생성한 개별 reducer를 하나로 합쳐줄 rootReducer를 만들어야 한다.‼️ 근데 만약 reducer가 하나라면 combineReducers를 사용해선 안된다. 123456import { combineReducers } from 'redux';import updateUserReducer from './authentication/userUpdate';const rootReducer = combineReducers({ updateUserReducer });export default rootReducer; Store 적용하기123456789101112131415161718192021222324// ../src/index.jsimport { createStore, applyMiddleware } from 'redux';import logger from 'redux-logger';import { composeWithDevTools } from 'redux-devtools-extension';import { Provider } from 'react-redux';// reducer가 여러개라면?import rootReducer from './reducers/rootReducer';// reducer가 하나라면 ?import updateUserReducer from './redux/authentication/userUpdate';const store = createStore( rootReducer, composeWithDevTools(applyMiddleware(logger)));ReactDOM.render( &lt;React.StrictMode&gt; &lt;GlobalStyle /&gt; &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 컴포넌트에서 redux 활용하기 이제 기본적인 세팅이 끝났으니, 각 컴포넌트에서 redux를 활용해볼 수 있다. 1234567891011121314151617181920// someComponent.jsximport { connect } from &quot;react-redux&quot;;const someComponent = (props)=&gt; { console.log(props) return ( &lt;div&gt;Welcome!!&lt;/div&gt; &lt;div&gt;{props.user}&lt;/div&gt; )}const mapStateToProps = (state) =&gt; { return { user: state.user }}const mapDispatchToProps = (dispatch)=&gt; { updateUserReducer}export default connect(mapStateToProps)(someComponent) 성공적으로 불러와졌다…!! 다음 포스팅에서는 이러한 redux state를 dispatch하여 변경시키는 것을 시도해보려고 한다.","link":"/redux/Redux_basic/"},{"title":"[Node.js] 11047번 : 동전 0","text":"문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수) 출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다. 풀이 과정 실수로 완전탐색 방식으로 풀어버릴 뻔 했다….처음 풀어보는 그리디 알고리즘 유형이었어서 여러 풀이법들을 참고했다. 그리디 알고리즘…? 그리디 알고리즘은 모든 경우의 수를 탐색하는 알고리즘이 아니다. 따라서 경우에 따라 내가 도출한 답이 최적의 답이 아닐 수도 있다. ( 하지만 빠를 수는 있음 ) 코드 로직 우선 N값과 K값을 선언해준다. 카운트를 세야 하기 때문에 count 변수 또한 선언해준다. 그리디 알고리즘이기 때문에, 작은 값에서 큰 값으로 탐색하는 것은 비효율적이다. 따라서, 배열의 가장 우측에서부터 차례대로 탐색하는 것이 빠른 해답을 찾기 위한 방법일 것이다. for문 또한 i가 감소하는 식으로 구성한다. 우측에서부터 진행되기 때문에 최소 조합을 구성하기 위해선 K/Arr[i]가 count에 담기면 된다. 그리고 K값은 해당 Arr[i]값으로 나눈 나머지, 즉 K%= Arr[i]가 되면 된다. 이렇게 반복문을 계속 돌리면 우측에서부터 탐색했을 경우의 최소 동전 집합의 개수를 구할 수 있다. 소스 코드123456789101112function coin(arr, NK) { // K와 N 선언 const N = NK[0]; let K = NK[1]; let count = 0; // 합이 K가 되는 동전 조합의 최소값 구하기 for (let i = N - 1; i &gt; 0; i--) { count += Math.floor(K / arr[i]); K %= arr[i]; } return count;}","link":"/algorithm/boj/11047/"},{"title":"[Node.js] 11399번 : ATM","text":"문제인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다. 사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다. 줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다. 줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 입력첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000) 출력첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다. 풀이 과정 최소한의 대기시간으로 사람들이 ATM업무를 처리할 수 있도록 하는 줄서기 배열을 구하고, 총 걸린 시간을 반환하면 된다. 앞 사람의 업무처리 시간이 길수록 뒷 사람들의 대기시간은 더 늘어난다. 따라서 업무처리 시간이 짧은 순서대로 사람들을 줄 세워야 한다. 업무처리 시간을 기준으로 오름차순 정렬하면 쉽게 풀 수 있는 문제다. tempSum : 자신을 제외한 이전까지의 합을 구하기 위한 변수 sum : 대기시간 + 업무처리 시간까지 모두 합한 해당 요소까지의 시간 소스코드123456789101112131415function ATM(n, arr) { // 우선 업무처리시간이 짧은 순으로 오름차순 정렬한다. arr.sort((a, b) =&gt; a - b); // 자신을 제외한 이전까지의 합을 담는 tempSum let tempSum = 0; // 자신을 포함한 모든 대기시간 + 업무처리시간의 합 let sum = 0; for (let i = 0; i &lt; n; i++) { // tempSum은 총 대기시간이 된다. (앞의 요소들의 업무처리 시간들의 합이기 떄문) // 또한 tempSum이 뒤에 연산되기 때문에 sum에 더해지는 tempSum은 이전까지의 대기시간 + 업무처리 시간이다 sum += tempSum + arr[i]; tempSum += arr[i]; } return sum;}","link":"/algorithm/boj/11399/"},{"title":"[Node.js] 13305번 : 주유소","text":"문제어떤 나라에 N개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다. 처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다. 예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다. 각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오. 입력표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 도시의 개수를 나타내는 정수 N(2 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 제일 왼쪽 도로부터 N-1개의 자연수로 주어진다. 다음 줄에는 주유소의 리터당 가격이 제일 왼쪽 도시부터 순서대로 N개의 자연수로 주어진다. 제일 왼쪽 도시부터 제일 오른쪽 도시까지의 거리는 1이상 1,000,000,000 이하의 자연수이다. 리터당 가격은 1 이상 1,000,000,000 이하의 자연수이다. 출력표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력한다. 풀이 과정 현재 가격과 다음 목적지의 가격을 비교하면 쉽게 풀 수 있을 것 같다. 우선 첫 시작점에서는 반드시 주유를 해야한다. 두번째 목적지에서 부터는 목적지별 주유비용을 서로 비교하며, 더 싼 가격이 나오기 전 까지는 같은 값을 유지한다. (거리만큼 계속 곱해나감) 그리고 더 저렴한 목적지가 나오면 그 뒤로부터는 다시 기준 주유비용을 현재 목적지의 주유비용으로 설정한다. 소스코드12345678910111213function gasStation(N, distance, cost) { let answer = distance[0] * cost[0]; for (let i = 1; i &lt; N - 1; i++) { if (cost[i] &lt; cost[i - 1]) { answer += cost[i] * distance[i]; } else { answer += cost[i - 1] * distance[i]; } } return answer;}gasStation(4, [2, 3, 1], [5, 2, 4, 1]);","link":"/algorithm/boj/13305/"},{"title":"[Node.js] 1541번 : 잃어버린 괄호","text":"문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다. 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다. 괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오. 입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다. 출력첫째 줄에 정답을 출력한다. 풀이 과정 마이너스 앞에 있는 숫자를 최소로 만들고, 마이너스 뒤에 있는 숫자들의 크기를 가장 크게 만들면 주어진 조건을 만족할 수 있을 것 같다. -를 기준으로 문자열을 split 그리고 다시 +를 기준으로 split 각 배열들의 합을 우선 구한다. (map &amp; reduce) 그리고 그 합들을 모두 빼준다. (reduce) 소스코드12345678910111213function lost(input) { // -를 기준으로 String을 배열로 나눠준다. let arr = input.split('-'); // +를 기준으로 +가 들어있는 배열들을 다시 또 나눠준다. arr = arr.map((el) =&gt; el.split('+')); // 그리고 각자 배열들의 요소들을 reduce를 사용하여 더해준다. arr = arr.map((el) =&gt; el.reduce((prev, cur) =&gt; Number(prev) + Number(cur))); // 이제 각 값들을 빼주기만 하면 된다 let answer = arr.reduce((prev, cur) =&gt; Number(prev) - Number(cur)); return answer;}lost('55-50+40');","link":"/algorithm/boj/1541/"},{"title":"[Node.js] 1931번 : 회의실 배정","text":"문제한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다. 입력첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다. 풀이 과정 최대한 회의실 사용 일정을 꽉꽉 채워 담아야 한다.따라서 이번에는 큰 수에서 내림차순으로 탐색하는 것이 아니라, 작은 수에서 오름차순으로 탐색해야 한다. 배열을 회의가 끝나는 시간이 가장 빠른 순으로 오름차순 정렬한다. 끝나는 시간 순으로 정렬을 했기 때문에, 시작 시간이 끝나는 시간보다 크거나 같으면 해당 미팅을 진행할 수 있다. 따라서, 미팅을 스케줄에 넣을 때 마다 endpoint가 방금 추가된 미팅의 끝나는 시간으로 설정되어야 한다. (아래 그림 참조) 반복문 활용 arr[i][0] === end라면 count를 더한다. 그리고 end값을 수정한다. 최종적으로 count를 return해준다. 소스코드12345678910111213141516function meetingRoom(arr, N) { // 보기에서는 끝나는 시간 순으로 이미 정렬되어 있었지만, 다른 인풋값이 들어올 경우를 대비해 정렬을 해줬다. arr.sort((a, b) =&gt; a[1] - b[1]); // 두 번째 시간부터 체크할 것이기 때문에 카운트는 1, end도 첫 째 미팅의 끝나는 시간으로 선언 let count = 1; let end = arr[0][1]; for (let i = 1; i &lt; arr.length; i++) { // 만약 현재 미팅의 시작시간이 전에 추가된 미팅의 끝나는 시간보다 크거나 같으면 추가할 수 있다. if (arr[i][0] &gt;= end) { // 카운팅을 하고, end값을 현재 미팅의 종료시간으로 갱신한다. count++; end = arr[i][1]; } } return count;}","link":"/algorithm/boj/1931/"},{"title":"콜백과 프로미스 (Callback &amp; Promise)","text":"콜백 함수 (Callback Function) 비동기 처리 방식의 문제점을 해결하기 위해, 특정 로직 수행이 완료됐을 때 원하는 동작을 실행시킬 수 있도록 하는 함수! 레스토랑 예약을 예시로 들 수 있다. 우리는 레스토랑 예약을 통해 우리가 원하는 시간대에 웨이팅 없이 식사를 편하게 즐길 수 있고, 웨이팅을 하는 대신 그 시간을 자유롭게 활용할 수 있다. 즉, 예약한 시간대**(로직 수행이 완료됐을 때)에 우리는 식당에 가서 먹기로 했던 메뉴를 시켜먹으면 되는 것이다(동작)**. 😈 콜백 지옥 우리는 가끔, 비동기 처리를 위해 콜백함수를 중첩하여 사용하는 경우를 맞이하는데…이를 콜백 지옥(Callback Hell)이라고 부른다.이렇게 콜백 함수가 꼬리에 꼬리를 무는 형식은 가독성도 떨어지고 변경 및 유지보수가 어렵다. ⇒ 이러한 콜백 지옥 문제를 해결하기 위해 필요한 것이 Promise와 Async다. 🤙 프로미스란? “A promise is an object that may produce a single value some time in the future” =&gt; 자바스크립트 비동기 처리에 사용되는 객체로, 미래에 특정한 value를 생성해낸다.“미래에 하나의 value를 생성해낼 것이라는 약속!” 콜백 함수와 프로미스의 차이점? 콜백 함수와 프로미스 모두 비동기적 처리 방식의 문제점을 해결하기 위한 함수라는 점에서는 동일하다.하지만 Promise는 이러한 콜백함수들이 한 객체로써 뭉쳐서 중첩되어있지 않고분리된 객체로써 논리적으로 상호 연결될 수 있도록 하는 하나의 절차적 함수라고 보면 된다. 프로미스의 구조 new Promise() resolve() then() 프로미스의 상태(state) Pending(대기) : 비동기처리 로직이 아직 미완료된 상태 123new Promise(function (resolve, reject) { // ...}); Fullfilled(이행) : 비동기 처리가 완료 → 프로미스가 결과값을 반환 123456789101112//resolve가 됐고, 이제 then을 활용해 처리 결과값을 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { const data = 100; resolve(data); });}// resolve()의 결과 값 data를 resolvedData로 받음getData().then(function (resolvedData) { console.log(resolvedData); // 100}); Rejected(실패) : 비동기 처리의 오류/실패 12345678910111213//이렇게 리젝트에 대한 결과값(실패 이유)을 아래의 catch()를 통해 받을 수 있다.function getData() { return new Promise(function (resolve, reject) { reject(new Error('Request is failed')); });}// reject()의 결과 값 Error를 err에 받음getData() .then() .catch(function (err) { console.log(err); // Error: Request is failed }); Iterator &amp; Iterable *이터레이터 : 반복자이터러블 : 반복 가능한* 자바스크립트에서는 “반복 가능한(Iterable)” 요소들만 순회 또는 반복될 수 있다. ex) 배열 이터레이터는 next, done, value의 구성을 갖는다!done : 이터레이터가 아직 루프중인지 확인value : 루프중일 때 해당하는 값을 반환 이터레이터와 배열의 차이? 이터레이터는 next 메서드만 기능할 수 있기 때문에, 배열의 기능적 부분집합이라고 볼 수 있다. 하지만… 일반적으로 배열이 이터레이터보다 무겁고 배열이 이터레이터보다 메모리 효율성이 떨어진다. 이터레이터는 다음 값 호출을 받았을 때, 그 때 필요한 값만 계산하는 것이 가능하기 때문이다. (next) 제너레이터 (Generator) 이터레이터를 사용할 수 있도록 해주는 함수 == 제너레이터이터레이터 + 이터러블의 조합 == 제너레이터 기본 문법 1234567function* gen() { yield 1; yield 2; yield 3;}var g = gen(); // &quot;Generator { }&quot; 사용 예시 (무한 반복자) 1234567891011function* idMaker() { var index = 0; while (true) yield index++;}var gen = idMaker(); // &quot;Generator { }&quot;console.log(gen.next().value); // 0console.log(gen.next().value); // 1console.log(gen.next().value); // 2// ...","link":"/javascript/base/%EC%BD%9C%EB%B0%B1%EA%B3%BC%20%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4%20(Callback%20&%20Promise)/"},{"title":"Javascript는 어떻게 작동하는가?","text":"💡 사전 지식 Parse : 컴퓨터가 이해할 수 있도록 프로그래밍 언어가 데이터를 가공하고 읽기 위해 일정한 포맷으로 변환하는 것. (쉽게 말하면, 사람의 언어 구조 → 컴퓨터의 언어 구조로 변환되는 것이라 봐도 될 것 같다) Thread : 프로그램 내에서의 작업 또는 프로세스의 경로 자바스크립트 개요 JS는 컴파일이 필요 없는 Interpreter 언어이다. JS는 변수를 설정할 때 특정 문자열타입을 지정하지 않고 let과 const에 구분없이 담을 수 있다. (동적 타입) 이러한 타입 시스템의 부재로 정적타입 언어인 C, C++에 비해 자바스크립트는 효율성이 떨어지고 느리다. 그렇다면 이렇게 비효율적이고 느린 언어를 계속 사용하는가? 이를 이해하기 위해선, 자바스크립트의 역사에 대해 간략히 짚고 넘어가야 한다. JS의 역사 1990년대의 웹 브라우저들은 매우 정적이고 비상호적인 페이지들을 띄우는 역할만을 담당했었다. 하지만 이후 웹 브라우저에서의 상호작용성을 더하기 위해 1995년 Netscape의 브랜든 아이크(Brendan Eich)에 의해 10일만에 개발된 Javascript가 세상에 공개되었고, 이는 혁신을 일으켰다. 하지만 여러 경쟁사들이 이러한 동적이고 상호적인 브라우저 언어의 개발에 뛰어들었고, 브라우저마다 언어가 달랐기에 호환성 등의 문제가 발발했다. 이에 따라 ECMA Script라는 브라우저 언어에 대한 약속이자 문법을 담은 문서가 개발된 것이다. 그렇게 표준화 되어가는 것 처럼 보이던 ECMA Script에 의한 브라우저 언어의 안정성과 호환성은 마이크로소프트 사의 ECMA 참여 거부로 점점 불안정해지기 시작한다. 그러나, Jesse James라는 개발자가 AJAX를 제안했고, 2008년 생태계 교란종이라고 할 수 있는 강력한 Chrome의 등장으로 위기를 느낀 다른 브라우저들의 협력을 통해 ES5, ES6 등의 문서들이 이후 작성되었다. 드디어 JS는 성숙하고 안정된 언어로 자리잡을 수 있게 된 것이다. 이제 JS가 브라우저에서 어떻게 “실행(Implemented)”되어야 하는지는 ES에 의해 정의됐다.그렇다면 “어떻게” 작동되어야 하는지는 무엇이 결정하는가? ⇒ JS엔진에 대한 이해가 필요하다. 자바스크립트 엔진 모든 브라우저는 JS코드를 실행하기 위한 JS 엔진을 탑재하고 있다 (Netscape는 SpiderMonkey라는 엔진을, Chrome은 V8엔진을 사용한다). 가장 기초적인 엔진구조(SpiderMonkey)는 JS소스코드를 컴파일 하여 Bytecode로 만드는 baseline compiler → 그리고 이 Bytecode를 머신코드(Binary Code)로 변환하여 최종적으로 CPU에서 실행되게 하는 Interpreter가 존재한다. 하지만 이러한 기초적 엔진구조는 컴파일 시간의 단축에만 집중할 뿐, 코드의 최적화에는 목적을 두지 않는다. 따라서 위와 같은 기초적 엔진구조는 아주 동적이고 인터렉티브한 웹 어플리케이션을 구동하는데 무리가 있다. 이러한 문제점들을 해결하기 위해 구글(Google)은 V8엔진을 사용한다. V8은 Baseline Compiler로써 Full-Codegen을 사용하고, 최적화를 위한 Crankshaft를 사용한다. 기존과 같이 Full-Codegen은 최적화를 신경쓰지 않고 최대한 빨리 Binary Code를 반환한다. 하지만 이러한 과정 중에 소스코드의 최적화를 진행해 최적화된 코드를 Full-Codegen이 반환한 코드의 일부와 대체한다. 즉, 빠른 컴파일과 최적화를 행한다는 것이다. 어떻게 작동되는지에 대한 프로세스는 이제 알겠다. 그렇다면 그 “최적화”라는 것은 어떻게 이루어지는가? 자바스크립트의 최적화 위에서 설명했듯, JS는 타입 시스템이 없고, 더 나아가 프로파일링 데이터(Profiling Data)를 수집하며 느리게 실행되는 코드를 감별하느라 CPU에 부담을 준다. 이에 따라 2017년에 새로 개발된 것이 새로운 V8엔진이다. 새로운 버전의 V8 엔진에는 Ignition이라는 파이프라인이 추가됐다. 이는 **베이스라인의 기능( JS 소스코드 → 바이트 코드로 변환) + 인터프리터의 기능(바이너리 코드로의 변환)**이 이루어지는 파이프라인이다. 그리고 Turbo Fan은 Ignition으로 부터 프로파일링 데이터를 넘겨받아 Hot코드 (CPU에 부담을 주는 코드)를 최적화 할 지, 말 지를 결정한다. 런타임에서의 JS 자바스크립트는 single-threaded 언어다. 즉, 자바스크립트는 코드가 실행될 때 모든 코드가 한 덩어리로써 한번에 실행된다는 것이다. 이러한 싱글 스레드 방식의 문제점은, 실행시간이 오래걸리는 코드가 중간에 껴있으면, 그 후의 코드 실행에 악영향을 미친다는 것이다. 따라서 이러한 블락(또는 무한루프) 문제점이 발생하면 브라우저의 모든 기능들은 중단된다는 문제점을 갖는다. 하지만 다행히도, 이제는 대부분의 브라우저들이 멀티탭 기능들을 탑재하고 있기에, 브라우저별 스레드가 아닌 탭(Tab)별 스레드가 적용되기 때문에 하나의 탭에만 싱글 스레드 문제점이 적용된다. 이렇듯 자바스크립트는 싱글 스레디드 언어이기 때문에 하나의 힙 메모리와 하나의 스택을 갖는다. 스택에서의 코드 실행 방식과 pop 방식은 아래와 같이 LIFO(후입선출)를 따른다. 이와 같은 싱글 스레드 방식만을 따르면, 브라우저는 HTTP 요청을 보내거나 받는 동안 다른 모든 핵심 기능들을 (캐싱, 데이터베이스 스토리지, DOM 이벤트 리스닝 등등) 사용하지 못할 것이다. 이를 해결하기 위해 자바스크립트만의 스레드는 독립적으로 두되, 브라우저 자체 내에서 다른 스레드를 구성하여 DOM 이벤트 리스닝, 캐싱, 데이터베이스 스토리지 등을 자바스크립트와는 독립적으로 기능할 수 있도록 하는 것이다. 이러한 독립적 스레드를 사용하는 브라우저 기능 중에는 Web API 요청을 위한 fetch() 가 있다. 이 fetch()는 자바스크립트 엔진 내의 스레드를 사용하지 않기 때문에 비동기적으로 작동하고, 이러한 비동기 방식 때문에 우리는 fetch()를 사용할 때 콜백함수를 사용하고, async await과 같은 비동기 처리 방식들을 사용하는 것이다. 1234567891011121314151617function printHello() { console.log('Hello from baz');}function three() { setTimeout(printHello, 3000);}function two() { three();}function one() { two();}one(); Event Loop : 콜스택과 콜백 큐를 주시하며, 콜스택이 비어있고, 콜백 큐에 처리해야 할 스택이 존재한다면 해당 스택을 콜스택으로 옮겨 쌓아 올리는 역할을 한다. 이와 비슷하게 setTimeout() 또한, 콜스택과 메시지큐, 이벤트루프에 의한 독립적 스레드에 의해 효율적으로 작동된다. 먼저 위의 코드를 보면 one() → two() → three() 순으로 코드가 실행될 것이다. 하지만 three()의 setTimeout()내의 콜백함수인 printHello()는 자바스크립트에 의해 webAPI로 보내질 것이고 자바스크립트 엔진 자체에서 3초를 기다리는 것이 아닌, 자바스크립트 자체는 이후 바로 다음 라인의 코드로 넘어간다. 하지만 다음 라인의 코드가 없기에 자바스크립트는 콜스택에서 three two one을 순서대로 pop할 것이다. 하지만 3초 뒤 콜백함수(printHello)는 webAPI에 의해 메시지큐에 담길 것이고, 이벤트루프가 이 콜백함수를 다시 콜스택 위에 올릴 것이다. 그렇게 setTimeout과 그 안의 콜백함수가 실행되는 것이다.","link":"/javascript/base/javascript-howItWorks/"},{"title":"[Node.js] 프로그래머스 : 체육복","text":"문제 설명점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다. 전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요. 제한사항 전체 학생의 수는 2명 이상 30명 이하입니다. 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다. 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다. 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다. 입출력 예 n lost reserve 5 [2,4] [1,3,5] 5 [2,4] [3] 3 [3] [1] 입출력 예 설명예제 #11번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다. 예제 #23번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다. 풀이 과정 체육복의 여분을 가져온 학생은 우선적으로 reserve에서 제외되어야 한다! 우선 object에 각 key에 대한 카운트를 한다. for문을 통해 reserve에 lost에도 똑같은 값이 있는지 체크하고, 해당 값을 양측에서 모두 제거해준다. ⇒ 단, 그냥 splice를 해버리면 배열의 length가 도중에 줄어들어서 반복문이 배열의 끝에 닿지 못한다. 이번에는 plus, minus 값이 object에 있는지 없는지 체크하고 있다면 해당 값들을 제거한다. 각 조건문마다 answer++를 걸어서 최종적으로 answer값을 도출해주면 된다. 소스코드1234567891011121314151617181920212223242526function solution(n, lost, reserve) { lost.sort(); reserve.sort(); let obj = {}; lost.forEach((el) =&gt; !obj[el] &amp;&amp; (obj[el] = 1)); let answer = n - lost.length; for (let i = 0; i &lt; reserve.length; i++) { if (obj[reserve[i]]) { obj[reserve[i]]--; answer++; reserve.splice(i, 1, 'del'); } } for (let i = 0; i &lt; reserve.length; i++) { let minus = reserve[i] - 1; let plus = reserve[i] + 1; if (obj[plus]) { obj[plus]--; answer++; } else if (obj[minus]) { obj[minus]--; answer++; } } return answer;} 프로그래머스 고인물의 풀이…. (filter 활용)12345678910function solution(n, lost, reserve) { return ( n - lost.filter((a) =&gt; { const b = reserve.filter((c) =&gt; Math.abs(c - r) &lt;= 1); if (!b) return false; reserve = reserve.filter((d) =&gt; d !== b); }) );}","link":"/algorithm/programmers/greedy1/"},{"title":"[Wesbos] Drum Kit","text":"키보드를 누르면 해당 키값에 맞는 드럼 사운드가 재생되는 간단한 웹페이지다.우선, 각 키를 눌렀을 때 기능해야하는 것들 + 웹페이지 작동 원리와 로직은 이하와 같다! 로직 키보드를 눌렀을 때? 해당 키값 찾기 (keyCode) 해당 오디오 태그 값 찾아서 play 연타 가능하도록 Currenttime = 0으로 설정 css 적용 (.playing 삽입) 적용된 css 제거하며 역트랜지션 구현 가능하도록 구현 코딩 과정1. 해당 키값 찾기 (keyCode) 각 키보드에는 고유한 키값이 존재한다.http://keycode.info/ 이곳에 들어가 각 키값(keyCode)들을 알아보자. html파일에서 key블록을 구성하고 있는 div에 data-key = “nn”형식으로 키값을 부여한다. 123&lt;div data-key=&quot;65&quot; class=&quot;key&quot;&gt; &lt;kbd&gt;A&lt;kbd&gt;&lt;/div&gt; 참고로 본인은 기존에 설정 되어있던 [a-s-d-f-g-h-j-k-l] 배열이 불편하다 생각이 들어 오투잼 배열로 키보드 배열을 변경했음. (div와 audio 태그 내의 data-key만 변경해주면 쉽게 변경 가능!) 완료했다면, JS파일로 돌아가 keys라는 변수를 querySelectorAll을 통해 지정해준다. 1const keys = document.querySelectorAll('.key'); 이제 키보드를 눌렀다는 event를 컴퓨터가 감지할 수 있도록 addEventListener를 통해 keydown 이벤트에 반응하는 함수를 만들어준다. 1window.addEventListener('keydown', keydown); forEach 💡 배열에 사용되는 함수! 편리하게도 배열의 각 요소에 대한 callback 함수를 적용할 수 있음 123456//예시const array1 = ['가', '나', '다'];array1.forEach((element) =&gt; console.log(element));// 예상 아웃풋: &quot;가&quot;// 예상 아웃풋: &quot;나&quot;// 예상 아웃풋: &quot;다&quot; 이제 위에서 설정한 keydown 이벤트를 들을 수 있는 keydown함수를 작성해준다. 그리고 console.log를 통해 누른 키에 해당하는 keyCode값을 콘솔 창에 찍어보자. 123function keydown(e) { console.log(e.keyCode);} 2. 키 값을 활용해 audio를 play audio에 입력된 data-key와 입력된 키의 keyCode가 상호 연결되어,입력된 키에 해당하는 audio만 재생이 돼야 한다. ⇒ 따라서, audio를 따로 변수처리 해서 해당 오디오 파일을 재생시켜줘야 함 12345678const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`);// 이렇게 e.keyCode를 변수화 하여 audio에 대입시키면 audio는 특정 audio,// 즉 눌러진 키에 해당하는 사운드만 플레이 될 수 있도록 지정할 수 있는 것!audio.play();//이제 play함수를 적용시키면 눌려진 키 값에 해당하는 사운드만 재생되는 것을 확인 할 수 있다. 3. currentTime을 활용한 연타 기능 추가 But… 키값에 맞는 오디오가 잘 플레이 되기는 하지만, 키를 연속적으로 눌러도 한 사운드의 재생이 끝날 때 까지 다음 키의 재생이 이루어지지 않는 것을 확인할 수 있다. ⇒ 따라서 currentTime을 활용해 키가 연속적으로 눌렸을 때 이에 즉각적으로 play() 함수가 반응되도록 해보자. 123456function keydown(e) { console.log(e.keycode); //이제는 필요 없는 코드 const audio = document.querySelector(`audio[data-key=&quot;${e.keyCode}&quot;]`); audio.currentTime = 0; audio.play();} currentTime currentTime은 HTML 내의 태그를 제어하기 위한 메소드다. currentTime = n; 을 통해 특정 수를 부여하면 audio는 해당 숫자에 해당되는 초로 이동한다.이에 따라, 위에서와 같이 currentTime=0; 을 사용하게 되면어떤 키가 눌렸을 때 해당 audio의 현재 플레이 위치는 0이 되는 것이다.즉, “재생이 정지된 것과 같은 효과 ⇒ 그에 따른 연타 가능”의 기능이 적용될 수 있는 것! 4. CSS 적용! 이제 CSS 적용만 하면 된다 :)audio에서 적용했던 논리와 동일하게 내가 누른 키에 해당하는 에만 css가 적용되도록 하면 됨! 123const key = document.querySelector(`.key[data-key=&quot;${e.keyCode}&quot;]`);key.classList.add('playing'); //미리 작성해둔 css 클래스를 적용 하지만…. 위의 코드만으론 css가 “적용”되기만 할 뿐, 키보드를 떼었을 때 css가 제거되지는 않는다. 5. 역트랜지션 구현 위의 키보드 div들의 .playing CSS의 적용과 트랜지션이 끝났을 때 곧바로 CSS가 제거되도록 코드를 짜주면 된다. 123456keys.forEach((key) =&gt; key.addEventListener('transitionend', transitionRemove));function transitionRemove(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing'); //transition이 끝난 div들의 playing css는 모두 제거된다.} 이제 모든 필요 기능들에 필요한 코드를 다 짰다. 아래는 그에 따른 최종 완성 코드다 :) 최종 완성 코드12345678910111213141516171819function playsound(e) { const key = document.querySelector(`.key[data-key = &quot;${e.keyCode}&quot;]`); const audio = document.querySelector(`audio[data-key = &quot;${e.keyCode}&quot;]`); if (!audio) return; //반드시 필요한 것은 아니지만, audio의 data-key에 해당하지 않는 키값이 입력됐을 때 함수가 종료되도록 //위와 같은 코드를 추가했음! audio.currentTime = 0; audio.play(); key.classList.add('playing');}function removeTransition(e) { if (e.propertyName !== 'transform') return; this.classList.remove('playing');}const keys = document.querySelectorAll('.key');keys.forEach((key) =&gt; key.addEventListener('transitionend', removeTransition));window.addEventListener('keydown', playsound);","link":"/javascript/wesbos/01.%20Drum%20Kit%20/"},{"title":"[Wesbos] Clock","text":"CSS와 JS를 이용해 아날로그 시계를 구현해보는 챕터다.시침 분침 초침이 시간에 따라 움직이도록 하려면 어떻게 해야할까? 로직시간이 변할 때 시간이 지날 때마다 침들의 deg에 변화를 준다. (rotate) = 1초, 1분, 1시간을 기준으로! = 각도는 360도를 기준으로! 침이 움직일 때 (CSS) = transition 효과를 줘서 실제 시계 침의 움직임과 유사하도록 구현 (째깍째깍의 느낌) 코딩 과정1. 초침, 분침, 시침을 지정해주자123const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand'); 그렇다면….. 시간의 흐름을 어떻게 get하고 표현해야할까? 2. 현재 시, 분, 초를 불러오기현재 시,분,초에 따라 침들의 각도가 달라져야 하기 때문에, 시분초를 불러오는게 가장 먼저 해야 할 일 ! Date(), getHours(), getMinutes(), getSeconds() 👉 new Date()를 통해 현재 년월일 시분초를 불러올 수 있다. 이후, Date 내에서 getOOO을 통해 시 분 초를 골라서 사용할 수 있음 ! 123456function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds();} 3. 현재 시, 분, 초에 따른 침들의 각도 지정하기! 👉 transform = rotate(OOdeg); 를 활용 ! 123456const secondsDegrees = (seconds / 60) * 360 + 90;secondsHand.style.transform = `rotate(${secondsDegrees}deg)`;const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90;hoursHand.style.transform = `rotate(${hoursDegrees}deg)`;const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90;minutesHand.style.transform = `rotate(${minutesDegrees}deg)`; 4. setInterval을 활용한 함수의 주기적 실행 👉 현재 시간에 따라 침이 변화해야 하는데 setInterval( ) 을 추가하지 않을 시 위의 setDate( ) 함수는 한번밖에 실행되지 않아 시계가 멈춰있게 된다. setInterval() 👉 일정한 시간 간격을 기준으로 특정 코드블록을 반복 실행할 수 있도록 하는 함수 setInterval(실행할 함수 이름, 시간 간격 기준) 단, 시간 간격은 ms가 기본 단위이다 (1000에 1초) 12setInterval(setDate, 1000);//1초에 한번씩 setDate함수를 실행하겠다는 뜻 최종 완성 코드123456789101112131415161718const hoursHand = document.querySelector('.hour-hand');const minutesHand = document.querySelector('.min-hand');const secondsHand = document.querySelector('.second-hand');function setDate() { const now = new Date(); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds(); const secondsDegrees = (seconds / 60) * 360 + 90; secondsHand.style.transform = `rotate(${secondsDegrees}deg)`; const hoursDegrees = (hours / 12) * 360 + (minutes / 60) * 30 + 90; hoursHand.style.transform = `rotate(${hoursDegrees}deg)`; const minutesDegrees = (minutes / 60) * 360 + (seconds / 60) * 6 + 90; minutesHand.style.transform = `rotate(${minutesDegrees}deg)`;}setInterval(setDate, 1000);","link":"/javascript/wesbos/02.%20Clock/"},{"title":"[Wesbos] Variable CSS","text":"로직 스크롤 → 해당 라벨의 이동값 선택 → 해당 값이 css variable에 적용 → 뒤에 suffix값 붙여넣기 CSS의 변수화 👉 CSS에서의 Variable control은 이하와 같이 표현 12345:root { --속성 : 값};//:root는 최상위 엘리먼트를 의미한다. (HTML) setProperty() 👉 설정, 2개의 인자 (속성,값) 1document.documentElement.style.setProperty(속성, 값); documentElement 👉 html 안의 모든 요소를 말한다 최종 코드 123456789101112const inputs = document.querySelectorAll('.controls input');function handleUpdate() { const suffix = this.dataset.sizing || ''; document.documentElement.style.setProperty( `--${this.name}`, this.value + suffix );}inputs.forEach((input) =&gt; input.addEventListener('change', handleUpdate));inputs.forEach((input) =&gt; input.addEventListener('mousemove', handleUpdate)); 1font-family: 'helvetica neue', sans-serif;","link":"/javascript/wesbos/03.%20Variable%20CSS/"},{"title":"[Wesbos] Array Cardio_1","text":"✅ 모든 언어에서 필수적으로 다뤄야 하는,그리고 굉장히 중요한 영역인 배열을 다루는 챕터였다. 기본 사항 이번 챕터에서 다룬 주요 배열 함수들은 순서대로filter(), map(), sort(), reduce()다. Javascript에서 배열 = [] 객체={}로 표현한다.객체는 {key : value}가 기본 형태 🙂 console.log 외에도 console.table(), console.dir() 등을 활용해볼 수도 있다. table()은 표 형태로 콘솔창에 출력되고,dir()은 해당 객체의 property들이 출력된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 주어진 배열const inventors = [ { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 }, { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 }, { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 }, { first: 'Max', last: 'Planck', year: 1858, passed: 1947 }, { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 }, { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 }, { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 }, { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 }, { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 },];const people = [ 'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig', 'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving', 'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano', 'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose', 'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank',]; filter() 🔥 array.filter()를 통해 기존 배열을 조건에 맞게 새로운 배열로 반환할 수 있다. 실행결과123//filter를 활용하여 inventors 배열 내에서 &quot;1500년도에 태어난 inventor만&quot;을 새 배열로 추출해보시오.const fifteen = inventors.filter(inventor =&gt; (inventor.year &gt;= 1500 &amp;&amp; inventor.year =&lt; 1599));console.table(fifteen); map() 🔥 array.map()를 통해 배열 내의 데이터를 **”콜백함수”**에 맞게 새로운 배열로 반환! filter와 map의 차이점? filter는 조건!map은 콜백(CallBack)함수! ⇒ 이처럼, filter는 콜백함수에 반응하지 앉고 map()만 콜백함수가 조건으로써 적용될 수 있다.쉽게 생각하면, filter()는 if가 사용되는 배열함수라고 생각하면 될 것 같다. 실행결과123456//map() 함수를 사용해서 invertor들의 성과 이름을 통해 Full Name이 담긴 새 배열을 만들어보시오.const fullNames = inventors.map( (inventor) =&gt; `${inventors.first} ${inventors.last}`);console.table(fullNames); sort() sort()의 기본형은 글자순으로 자동정렬 or 숫자(앞자리 기준) 기준으로 자동정렬이다. 하지만, 우리가 이번 챕터에서 사용하는 sort()함수는 Compare Function. 즉, 비교 함수로써의 sort()다. Compare Function으로써의 sort() 🔥 array.sort(a,b)를 통해 a와 b를 비교해 “오름차순 또는 내림차순” 정렬 방식을 정하여 반환 123array.sort((a, b) =&gt; (a.value &gt; b.value ? 1 : -1));// 즉, a값이 b보다 크면 아래로 내리고, 그 반대라면 작은 것을 위로 올리겠다는 뜻 !// 0 또한 지정해줄 수 있는데, 이는 a와 b가 같은 값일 때를 의미한다. 실행결과123456// sort()를 활용하여 inventors를 나이에 대한 내림차순으로 정렬해보시오.const orderByBirth = inventors.sort((a, b) =&gt; (a.year &gt; b.year ? 1 : -1));// True라면 1이 부여되어 비교대상보다 위로 올라간다. (모든항 비교해 점수매기기라고 생각해도 될듯)console.table(orderByBirth); reduce() 🔥 array.reduce(리듀서 함수, 현재값) ⇒ 리듀서 함수를 실행하여 하나의 결과값을 반환한다. 1234array.reduce((total, currentValue) =&gt; { return total + currentValue;}, 0);// total의 초기값은 0, 이후 currentValue에 부여한 수식이 루프되어 총합이 계산된다. 실행결과1234567// reduce()를 활용하여 inventors의 나이를 모두 합한 결과값을 반환하시오.const sumOld = inventors.reduce((sum, inventor) =&gt; { return sum + (inventor.passed - inventor.year);}, 0);//여기서 0은 initialValue를 의미하는데, 가장 처음 루프 때 sum의 값이라고 생각하면 된다.","link":"/javascript/wesbos/04.%20Array%20Cardio1%20/"},{"title":"[Wesbos] Flex Box","text":"box-sizing 🔥 박스 크기의 기준을 어떤 것으로 설정할 것인가? content-box : 오로지 콘텐트 요소만 포함 (기본값) border-box : 콘텐트 + 보더 + 패딩 값을 모두 포함 inherit : 부모 요소로부터 상속 12345// 대부분의 개발자들은 border-box를 기본값으로 설정해두고 코딩을 함*{ box-sizing : border-box;}; justify-content와 align-items 🌸flex-basis와 flex-grow flex-basis = flex item의 기본 크기를 설정함 ! (direction이 row면 너비, column이면 높이) flex-grow = item이 basis값보다 커질 수 있는지 설정! (기본값은 0, 유연하게 늘어날 수 있도록 설정은 1) 123456// 비율 놀이라고 생각해도 편함 !.item:nth-child(1) { flex-grow: 1;}.item:nth-child(2) { flex-grow: 2;}.item:nth-child(3) { flex-grow: 1;}// 이럴 경우 1: 2: 1 비율로 컨테이너 안에서 크기가 형성됨 축약 속성 🔥 flex : grow, shrink, basis; Flex-container와 Flex-items? 🔥 Container는 아이템을 담는 박스라고 생각하면 되고,item은 개별 객체들이라고 보면 됨 ! // container에 display=flex를 주고, items에는 items에 쓸 수 있는 기능들이 따로 있음 flex-basis 🔥 flex를 적용할 경우, item들은 컨텐츠에 맞게 넓이가 설정되는데 basis값을 줄 경우 기본 넓이값이 설정된다. 만약 flex-basis를 100px로 줬는데 아이템 안에 컨텐츠가 100px보다 크다면 컨텐츠 값에 맞게 늘어난다. 즉, 컨텐츠 길이가 basis값보다 작으면 아이템은 basis에 맞춰서 크기가 설정됨 ! flex-grow (유연하게 늘리기) 🔥 flex-basis가 갖는 영역을 제외한 여백의 비율을 지정.기본값 = 0 flex-shrink (유연하게 줄이기) 🔥 flex-basis보다 크기가 줄어들 수 있는가 ?기본값 : 1 만약, 0으로 값을 설정하면 고정값으로 설정돼 basis의 크기가 고정값으로 지정된다.** 최종 완성 코드12345678const panels = document.querySelectorAll('.panel');function clicked() { this.classList.toggle('open'); this.classList.toggle('open-active');}panels.forEach((div) =&gt; div.addEventListener('click', clicked));","link":"/javascript/wesbos/05.%20Flex%20Box/"},{"title":"[Wesbos] Type Ahead (동적 검색)","text":"💡 앞으로 개발을 하다보면 자주 사용하게 될 것 같은 동적 검색창이다.사실 Wes Bos 30일 챌린지를 진행하면서 근 6회차 중에 가장 어려운 챕터였던 것 같다…. 로직 json파일 불러오기 json파일을 새로운 배열 형태로 생성 (fetch) 검색어 찾기 기능 (“찾기”) 검색어에 해당하는 cities 나타내기(display) 1. json파일 불러오기 💡 json 주소 주소에 저장돼있는 json 형식의 city 파일 1234//이 json 파일 주소를 const를 통해 endpoint라는 값으로 지정!const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json'; ❓ 하지만, 여기까지는 아직 주소값만 지정해준 것이기 때문에,이 json파일을 배열로써 나타나게 해줘야 한다. 12// 우선 cities라는 빈 배열을 만들어주자const cities = []; ⭐ 그렇다면, 이제 어떻게 저 주소로부터 city 값들을 불러들여올 수 있을까? =&gt; fetch API를 사용하면 된다 ! fetch API💡 fetch는 서버에 네트워크 요청을 할 수 있도록 도와주는 AJAX기반의 API다. 💡 fetch(접근하고자 하는 url, 옵션)then.() == 호출에 성공했을 때 응답객체를 resolve 즉, then은 fetch에 대한 응답형태 및 방식이라고 보면 된다. 123456//우선, 나는 json 주소를 endpoint로 지정해뒀으니까 주소 대신 변수명을 넣어준다.fetch(endpoint) //Blob은 타입이 존재하는 바이너리 객체! .then((Blob) =&gt; Blob.json()) //이제 이 json 데이터를 위에서 생성한 cities 배열에 push 해주면 기본적인 세팅은 끝! .then((data) =&gt; cities.push(...data)); fetch(endpoint)를 통해 Promise가 resolve됐음 Blob형태의 json 값들이 배열로 반환됨 검색을 통해 해당하는 city 찾기! ❓ 일단 findMatches라는 함수를 생성할건데,filter 조건 내에서 검색창에 입력될 글자는 매번 다를 것이므로 이를 어떻게 변수화 할지가 관건이다.이것을 해결해줄 기능이 바로 “**RegEXP와 match()”**다. RegExp 🔥 정규표현식 = 문자검색, 문자 대체, 문자추출에 주로 사용 new RegExp(표현식, 플래그) match() 🔥 정규표현식에 맞는 문자열을 찾아서 배열 객체**(문자열 형태)**로 반환한다. 12345678function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { // 모든 문자와 여러줄을 영어 대소문자를 구분하지 않고 받아들임 const regex = new RegExp(wordToMatch, 'gi'); // &quot;||&quot;은 or을 뜻한다는 점 복기! return place.city.match(regex) || place.state.match(regex); });} 검색어에 해당하는 city or state 나타내기 💡 우선, 검색창과 검색결과가 보여질 html 요소를 정의해주고,addEventListener를 통해 변화에 따른 함수 실행을 설정하자 1234567// html 요소 정의const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');// addEventListener 사용searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches); displayMatches12345678910111213141516171819202122232425function displayMatches() { // 검색창에 입력된 글을 변수화! const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { // 각 값들에 대한 정의 const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);} 최종 완성 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';console.log(endpoint);const cities = [];fetch(endpoint) .then((Blob) =&gt; Blob.json()) .then((data) =&gt; cities.push(...data));function findMatches(wordToMatch, cities) { return cities.filter((place) =&gt; { const regex = new RegExp(wordToMatch, 'gi'); return place.city.match(regex) || place.state.match(regex); });}function displayMatches() { const matchArray = findMatches(this.value, cities); const html = matchArray .map((place) =&gt; { const regex = new RegExp(this.value, 'gi'); const cityName = place.city.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); const stateName = place.state.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${this.value}&lt;/span&gt;` ); return ` &lt;li&gt; &lt;span class=&quot;name&quot;&gt;${cityName}, ${stateName}&lt;/span&gt; &lt;span class=&quot;population&quot;&gt;${place.population}&lt;/span&gt; &lt;/li&gt; `; }) .join(''); return (suggestions.innerHTML = html);}const searchInput = document.querySelector('.search');const suggestions = document.querySelector('.suggestions');searchInput.addEventListener('change', displayMatches);searchInput.addEventListener('keyup', displayMatches);","link":"/javascript/wesbos/06.%20Type%20Ahead/"},{"title":"[Wesbos] 배열 기초체력 다지기2","text":"이번 챕터에서 다룰 기능들 array.some() array.every() array.find() array.findIndex() 주어진 배열1234567891011121314const people = [ { name: 'Wes', year: 1988 }, { name: 'Kait', year: 1986 }, { name: 'Irv', year: 1970 }, { name: 'Lux', year: 2015 },];const comments = [ { text: 'Love this!', id: 523423 }, { text: 'Super good', id: 823423 }, { text: 'You are the best', id: 2039842 }, { text: 'Ramen is my fav food ever', id: 123523 }, { text: 'Nice Nice Nice!', id: 542328 },]; some() 💡 배열 안에서 “특정” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 1234// 최소 한명이라도 19살 이상인 사람이 있는가?const isAdult = people.some(person =&gt; ((new Date()).getFullYear() - person.year &gt;= 19);console.log(isAult); every() 💡 배열 안에서 “모든” 요소들이 주어진 조건에 해당하는지 True or False 형태로 출력! 123456// 모든 사람들이 19세 이상인가?const isEvery = people.every( (person) =&gt; new Date().getFullYear - people.year &gt;= 19);console.log({ isEvery }); find() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소값을 반환 123// ID가 823423인 사람이 쓴 comment는 무엇인가?const findID = comments.find((comment) =&gt; comment.id === 823423);console.log(findID); findIndex() 💡 배열 안에서 판별함수(조건)를 만족하는 첫 번째 요소의 index값을 반환 123456// ID가 823423인 사람이 쓴 comment를 삭제하시오.const index = comments.findIndex((comment) =&gt; comment.id === 823423);const newComments = [...comments.slice(0, index), ...comments.slice(index + 1)];console.table(newComments);","link":"/javascript/wesbos/07.%20Array%20Cardio2/"},{"title":"[Wesbos] Fun with Canvas","text":"🙂 사실 그렇게 자주 사용할것 같지는 않지만, 배워두면 좋을 것 같은 ..?Javascript를 이용한 그리기 도구 기능 구현 챕터다 로직 canvas태그를 통해 그림판을 브라우저에 깔아준다 canvas의 개념적 정의를 ‘2d’로 설정한다 : canvas.getContext(‘2d’) canvas에 이벤트리스너를 부여한다. 캔버스 내에서 마우스 움직임에 따라 그림이 그려질 수 있도록 ctx설정을 한다 (그리기 속성과 위치값 설정) 그림판 깔기canvas 태그 💡 &lt;canvas&gt;&lt;/canvas&gt;와 같은 형태로 쓰이며, id값을 부여해 사용해주는 것이 바람직하다. canvas태그에 id값을 #draw로 부여해뒀다. 이를 활용! 12345const canvas = document.querySelector('#draw');//그림판 캔버스가 브라우저 전체 크기를 차지할 수 있도록 설정canvas.width = window.innerWidth;canvas.height = window.innerHeight; canvas태그 불러오기 및 기본설정 (렌더링 컨텍스트) 💡 canvas만 브라우저에 펼쳐져 있다고 그림을 그릴 수 있는게 아니다. **getContext()**를 통해 렌더링 컨텍스트까지 canvas에 노출시켜줘야그리기 함수나 렌더링 컨텍스트 등을 활용할 수 있다. 그리기 도구를 지정해준다고 생각하면 이해하기 편할 것이다. 1const ctx = canvas.getContext('2d'); 이벤트리스너 적용 및 함수 생성 💡 canvas가 이벤트를 감지할 수 있도록 addEventListener와 그에 따른 함수를 생성해줘야 한다. 12//마우스의 움직임을 감지canvas.addEventListener('mousemove', draw); 💡 이제 draw함수를 생성해보자 ! 12//일단 만들어만 놓자function draw() {} ctx를 통한 그리기 속성 세팅 💡 그림을 그려야하기 때문에, 먼저 그리기 도구들을 세팅해주자 ctx세팅을 위한 함수 및 기능들은 아래 표에 정리해두었다. 1234ctx.strokeStyle = '#BADA55';ctx.lineCap = 'round';ctx.lineJoin = 'round';ctx.lineWidth = 50; ctx를 통한 위치값 설정 및 그리기 기능 구현 💡 거의 다 왔다….. 이제 그림을 그릴 수 있도록 xy 좌표값과 그에 해당하는 기본 변수값들을 지정해줘야 한다. 123456789101112131415//마우스를 클릭한 상태로 움직였을 때만 그리기가 가능하도록 isDrawing을 설정해줬다.let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { //마우스를 뗀 상태라면 그려지지 않는다 if (!isDrawing) return; ctx.beginPath(); //새로운 경로가 생성된다. ctx.moveTo(lastX, lastY); //마우스가 눌린 시점의 x,y의 좌표가 입력될 것이다. ctx.lineTo(e.offsetX, e.offsetY); //마우스가 이동한 위치의 좌표가 입력될 것이다. ctx.stroke(); //도형(선 포함)이 그려진다. //마우스 움직임에 따라 lastX와 lastY값 지속적으로 변동 [lastX, lastY] = [e.offsetX, e.offsetY];} 123456789//마우스를 눌렀을 때 x와 y값이 입력되도록 설정!canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});//마우스가 눌려있지 않은 경우에 그리기를 실행하지 않기 위한 설정canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false)); offsetX &amp; offsetY 💡 offsetX : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “x좌표” 위치를 나타냄 offsetY : 이벤트의 대상이 되는 객체 내에서의 상대적 마우스 “y좌표” 위치를 나타냄 최종 완성 코드123456789101112131415161718192021222324252627282930313233const canvas = document.querySelector('#draw');const ctx = canvas.getContext('2d');canvas.width = window.innerWidth;canvas.height = window.innerHeight;ctx.strokeStyle = '#BADA55';ctx.lineJoin = 'round';ctx.lineCap = 'round';ctx.lineWidth = 50;let isDrawing = false;let lastX = 0;let lastY = 0;function draw(e) { if (!isDrawing) return; ctx.beginPath(); ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`; ctx.moveTo(lastX, lastY); ctx.lineTo(e.offsetX, e.offsetY); ctx.stroke(); [lastX, lastY] = [e.offsetX, e.offsetY];}canvas.addEventListener('mousemove', draw);canvas.addEventListener('mousedown', (e) =&gt; { isDrawing = true; [lastX, lastY] = [e.offsetX, e.offsetY];});canvas.addEventListener('mouseup', () =&gt; (isDrawing = false));canvas.addEventListener('mouseout', () =&gt; (isDrawing = false));","link":"/javascript/wesbos/08.%20Fun%20with%20Canvas/"},{"title":"[Wesbos] Dev Tools (개발자 도구)","text":"Interpolated'hello %s', 'hoonjoo' 12console.log(&quot;hello my name is %s What's your name?&quot;, 'hoonjoo');// 결과값 : hello my name is hoonjoo What's your name? Styled12345// CSS를 컨트롤 할 수도 있다!console.log( '%c I can change my style by this', 'font-size : 50px; color : #BADA55'); warning 12// 콘솔 창에 경고 표시를 할 수 있음console.warn('stop'); error 12// 콘솔 창에 오류 표시를 할 수 있음console.error('stop'); Info1console.info(''); Testing1assert(1 === 1, 'That's Wrong!') Cleaning1console.clear(); Grouping Together123456789dogs.forEach(dog ⇒ {console.group(``${dog.name}``)console.log(`${dog.name} is ${dog.old} years old`)console.groupEnd(`${dog.name}`);}); count1console.count(); time12// 불러오는데 얼마나 걸리는지?console.time();","link":"/javascript/wesbos/09.%20Dev%20Tools%20(%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EB%8F%84%EA%B5%AC)/"},{"title":"[Wesbos] Hold Shift Button to Check","text":"정말 자주 쓰일 것 같은 기능이다. 첫 번째 체크박스를 클릭하고 쉬프트를 누른 뒤아래에 있는 임의의 박스를 클릭하면 그 사이에 있는 체크박스들이 함께 체크된다. 네이버에서도 사용! 로직 체크박스를 변수화해 지정한다. (const) click 이벤트를 위한 addEventListener + 함수 생성 lastChecked와 inBetween을 선언하여 플래그값으로 활용 ⭐️ 체크박스 지정하기 💡 거의 가장 먼저 하는 것은 const를 통해 사용할 객체를 변수화 하는 것이다. 1const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]'); addEventListener + 함수 생성 💡 여기서 사용할 것은 click 이벤트다.이 챕터를 진행하기 전이었다면, keyCode를 활용해 keydown등의 이벤트를 사용했을텐데…‘e.shiftKey’를 사용할 수 있더라 0_0; 12345// 이벤트리스너checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));//함수 생성function checkIt(e) {} 플래그 활용 다른 것들은 어렵지 않은데…. 이 부분이 참 생소하고 어려웠다 ㅜㅜ lastChecked 💡 제일 최초로 체크된 박스를 저장하기 위한 플래그다. 12// Boolean값 없이 선언만 해준다let lastChecked; inBetween 💡 최초 체크박스와 쉬프트를 누른채 클릭한 체크박스 사이에 있는 박스들을 인식하기 위한 플래그! 12345678910111213141516171819function checkIt(e) { //사이에 있는 놈인가? false let inBetween = false; //만약 쉬프트키가 눌려져 있고, 현재 체크 박스가 체크됐다면? if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { // 방금 눌린 것 or 최초로 눌린 것 = inBetween 아님! if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } // inBetween이면 checked되게 하라 if (inBetween) { checkbox.checked = true; } }); } // 처음 눌린 놈! lastChecked = this;} 최종 완성 코드12345678910111213141516171819202122const checkBoxes = document.querySelectorAll('.inbox input[type=&quot;checkbox&quot;]');//lastChecked 변수를 부여let lastChecked;function checkIt(e) { //사이에 있는가? =&gt; 일단 false let inBetween = false; //여기서 e는 click 이벤트다, 그리고 this는 &lt;input type=&quot;checkbox&quot;&gt;임!! if (e.shiftKey &amp;&amp; this.checked) { checkBoxes.forEach((checkbox) =&gt; { if (checkbox === this || checkbox === lastChecked) { inBetween = !inBetween; } if (inBetween) { checkbox.checked = true; } }); } lastChecked = this;}checkBoxes.forEach((checkbox) =&gt; checkbox.addEventListener('click', checkIt));","link":"/javascript/wesbos/10.%20Hold%20Shift%20Button%20to%20Check/"},{"title":"[Wesbos] Custom Video Player","text":"사실 요즘은 자체적으로 이렇게 동영상 플레이어를 구현하는 것이 아니라,유튜브와 같은 플랫폼에 이미 업로드 되어있는 영상을 불러오는 형식을 더 자주 사용하기 때문에, 실용적인 챕터일까? 라는 생각을 하기도 했다. 하지만…JS를 통해 CSS적인 요소를 컨트롤 하는 부분과 valueChange를 하는 등의 연습은 큰 도움이 됐던 것 같다. 로직 다양한 객체들 const로 정의 이벤트 리스너 (재생버튼, 프로그레스바, 볼륨바, 속도바, 스킵버튼) 재생 기능과 CSS 제어 프로그레스바 구현 볼륨 컨트롤 구현 속도 설정 구현 스킵버튼 구현 Const!! 💡 이번 챕터에선 정의해줘야 할 객체들이 많다…. 1234567const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider'); 이벤트리스너 💡 구현해야 할 기능들이 많기 때문에… 이벤트 또한 역시나 많다… 123456789101112131415//재생&amp;일시정지 버튼toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);//비디오 뷰어 내에 있는 버튼과 프로그레스바video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);// 프로그레스바, 사운드, 속도 등등의 value값 제어를 위한 것ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));//스킵버튼skipButtons.forEach((button) =&gt; button.addEventListener('click', skip)); 재생과 버튼 업데이트 💡 재생 버튼을 누르면 재생이 되고, 버튼 아이콘도 변경되어야 한다. 필자는 if문을 쓰는게 더 쉽고 간편할 것 같아서…if문을 통해 재생 및 일시정지, 그리고 재생버튼 업데이트 기능을 구현해봤다. ❗ 재생버튼 뿐만 아니라, 유튜브와 같이 비디오 플레이어 화면을 클릭했을 때도 재생 또는 일시정지가 될 수 있도록 구현하기 위해 pause함수가 video와 toggle에도 작동할 수 있도록 이벤트리스너를 작성했다. 12345678910111213141516171819202122//puase함수function pause() { //비디오가 정지되어 있으면 플레이 if (video.paused) { video.play(); } //아니면 일시정지 else { video.pause(); }}function updateButton() { // 정지되어 있으면 재생 아이콘이, if (video.paused) { toggle.textContent = '►'; } // 재생중이면 일시정지 아이콘이 나타나도록 설정 else { toggle.textContent = '❚ ❚'; }} 그 외 기능들123456789101112131415161718// 볼륨과 속도바function valueChange() { //volume or playBackRate = this.value가 되는 것! video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;} 최종 완성 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const player = document.querySelector('.player');const video = player.querySelector('.viewer');const toggle = player.querySelector('.toggle');const progress = player.querySelector('.progress');const progressBar = player.querySelector('.progress__filled');const skipButtons = player.querySelectorAll('[data-skip]');const ranges = player.querySelectorAll('.player__slider');function pause() { if (video.paused) { video.play(); } else { video.pause(); }}function updateButton() { if (video.paused) { toggle.textContent = '►'; } else { toggle.textContent = '❚ ❚'; }}function valueChange() { video[this.name] = this.value;}function skip() { video.currentTime += parseFloat(this.dataset.skip);}function scrub(e) { video.currentTime = (e.offsetX / progress.offsetWidth) * video.duration;}function handleProgress() { const percent = (video.currentTime / video.duration) * 100; progressBar.style.flexBasis = `${percent}%`;}toggle.addEventListener('click', pause);toggle.addEventListener('click', updateButton);video.addEventListener('click', pause);video.addEventListener('click', updateButton);video.addEventListener('timeupdate', handleProgress);ranges.forEach((range) =&gt; range.addEventListener('mousemove', valueChange));ranges.forEach((range) =&gt; range.addEventListener('change', valueChange));skipButtons.forEach((button) =&gt; button.addEventListener('click', skip));let mousedown = false;progress.addEventListener('click', scrub);progress.addEventListener('mouseup', (e) =&gt; mousedown &amp;&amp; scrub(e));progress.addEventListener('mousedown', () =&gt; (mousedown = true));progress.addEventListener('mousemove', () =&gt; (mousedown = false));","link":"/javascript/wesbos/11.%20Custom%20Video%20Player/"},{"title":"[Wesbos] 코나미 코드","text":"코나미 코드…? 💡 게임이나 웹사이트 내에 개발자가 숨겨둔 “이스터에그” 같은 것이라고 생각하면 된다. 로직 키보드 입력을 감지할 이벤트리스너 + 함수 생성 배열 생성하기 특정한 문자열이 입력됐을 때 이스터에그 발생되도록 설정 이벤트리스너 💡 이 부분은 쉽다.**’keyup’**을 listen할 수 있도록 설정하고 그에 따른 함수를 생성해보자 1234567// 'keyup'을 감지해야 할 것은 window 전체!window.addEventListener('keyup', easterEgg);// 키가 잘 찍히는지 콘솔창을 통해 확인해보자function easterEgg(e) { console.log(e.key);} 잘 된다!! 배열 생성 💡 내가 입력한 키값들이 저장될 수 있도록 배열을 활용해보자. 12345678910const pressed = [];// 배열에 잘 저장되는지 테스트도 해보기!function easterEggg(e) { pressed.push(e.key); console.log(pressed);}//근데... 무한으로 배열에 키가 저장되면 비효율적이니까 MAXIMUM 길이를 정해주자. (splice 활용) 잘 된다! splice() ⭐ 배열의 기존 요소를 삭제, 교체, 추가 하며 배열의 내용을 변경할 수 있도록 하는 메서드! 123456//기본 문법array.splice(index, deleteCount, item);//deleteCount를 0으로 지정하면 insert!//item 지정하지 않으면 삭제만 수행함 시크릿코드 생성 💡 진부하지만… 일단 편의상 ‘hoonjoo’로…!! 1const secretCode = 'hoonjoo'; 이스터에그 실행 💡 배열에 ‘hoonjoo’가 포함된다면 이스터에그 실행되도록 할 것임! 1234567891011function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!'); //이건 그냥 자바스크립트에서 제공하는 플러그인인 것 같다. cornify_add(); }} 최종코드1234567891011121314const pressed = [];const secretCode = 'hoonjoo';function easterEggg(e) { pressed.push(e.key); //splice(시작점인덱스, 삭제카운트, 아이템) =&gt; (-8. n-7)이 되는 것 pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length); console.log(pressed); if (pressed.join('').includes(secretCode)) { console.log('성공!!!'); cornify_add(); }}window.addEventListener('keyup', easterEggg);","link":"/javascript/wesbos/12.%20Konami/"},{"title":"[Wesbos] 스크롤 → 슬라이드인","text":"진~~~짜 유용하게 잘 쓰일 것 같은 챕터다.스크롤을 내리면 비어있던 이미지들이 위치에 맞게 슬라이드 인 되는 기능이다. 🤔 그동안은 클릭이나 키다운에 의한 이벤트 함수를 생성했었는데,이번 챕터에서는 스크롤한 위치에 따른 기능실행이라는 점이 신선했던 것 같다. 로직 const eventListener + 함수생성 offset값을 활용한 위치값 불러오기 const!1const slideIn = document.querySelectorAll('.slide-in'); 이벤트리스너와 함수12345function slide(e) { console.log(e);}window.addEventListener('scroll', slide); 하지만, 이렇게 둘 경우 너무 자주 함수(slide)가 실행되어 비효율적일 수 있다. 1234567891011121314151617181920//미리 입력되어 있던 debounce 함수 모듈을 활용해보자function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}//slide함수에 적용될 수 있또록 감싸주자window.addEventListener('scroll', debounce(slide)); offset 값을 활용! 💡 scrollY : 세로로 스크롤이 몇 px만큼 움직였는지 알 수 있음 💡 innerHeight : 현재 뷰포트의 세로값(px)을 알 수 있음 어느 위치를 기준으로 이미지가 슬라이드 인 되어야 할까? 🤔 이미지의 세로 중간 쯤 뷰포트 바텀라인이 도착하면 슬라이드인 되도록 하는 것이 자연스러울 것 같다. 💡 그럼 ! 일단 현재 얼마나 스크롤 됐는지에 대한 값을 불러오는 변수를 설정해주자. 얼마나 스크롤 됐는지?❗ 뷰포트 바닥을 기준으로 계산을 할 것이다. (상단 기준이면 scrollY만 있어도 됨) 123// 스크롤한 만큼의 Y값(px) + 뷰포트의 Y길이(px)const slideAt = window.scrollY + window.innerHeight;console.log(slideAt); 이미지의 바닥 위치12// 떨어진 거리 + 이미지박스 높이 = 이미지 바닥의 위치const imageBottom = slideImage.offsetTop + slideImage.height; offsetTop? 💡 부모의 상단 보더로부터 자신의 상단 보더가 떨어진 만큼의 거리! 슬라이드인 조건들스크롤이 이미지의 절반까지 위치했는가?1const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; 화면에서 이미지가 이미 지나쳐갔는가?12// 이미지가 스크롤되어 지나쳐, 이미 화면에서 안보이는데 굳이 띄워둘 필요는 없음!const isPassed = window.scrollY &lt; imageBottom; 이제 이미지를 위의 두 조건이 아닐 경우에는 이미지가 슬라이드 아웃 되도록 해주면 된다. 최종 코드123456789101112131415161718192021222324252627282930313233343536function debounce(func, wait = 10, immediate = true) { var timeout; return function () { var context = this, args = arguments; var later = function () { timeout = null; if (!immediate) func.apply(context, args); }; var callNow = immediate &amp;&amp; !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); };}const slideIn = document.querySelectorAll('.slide-in');function slide(e) { slideIn.forEach((slideImage) =&gt; { const slideAt = window.scrollY + window.innerHeight; console.log(slideAt); console.dir(slideImage); // bottom of the image const imageBottom = slideImage.offsetTop + slideImage.height; const isHalfShown = slideAt &gt; slideImage.offsetTop + slideImage.height / 2; const isPassed = window.scrollY &lt; imageBottom; if (isHalfShown &amp;&amp; isPassed) { slideImage.classList.add('active'); } else { slideImage.classList.remove('active'); } });}window.addEventListener('scroll', debounce(slide));","link":"/javascript/wesbos/13.%20Scroll_SlideIn/"},{"title":"[Wesbos] 배열 참조 vs 복사","text":"참조와 원본 간의 관계 num, string, boolean값들의 참조 변수는 앞에 선언된 것을 우선시한다. 12345678age = 100;age = age2;console.log(age, age2); // 100 100//하지만 여기서 age값을 바꿔주면age = 200;console.log(age, age2); // 200 100 이 결과값으로 도출된다. 하지만!!! 배열에선 다르다 💡 위에선 참조와 원본이 다르게 처리됐지만, 배열에선 참조를 변경 시 원본에 영향을 준다. 1234567const players = ['hoonjoo', 'chanjoo', 'jaeseong', 'hyobum'];const team = players;team[1] = 'saeeun';//team = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum'];//players = ['hoonjoo', 'saeeun', 'jaeseong', 'hyobum']; 그렇다면, 배열에서 원본에 영향을 주지 않고 참조를 변경하는 방법은 없을까? array.slice() 💡 앞에서 배웠던 것과 같이, slice()를 사용하면 배열의 복사본을 만든다. concat(array) 💡 [].concat(array)를 사용해서 빈 배열에 기존 배열을 합치는 식의 복사를 할 수도 있다. spread 💡 newArray = […orgArray]; 와 같은 방식을 사용할 수도 있다. Array.from() 💡 newArray = Array.from(orgArray); 복사와 원본 간의 관계object.assign() 💡 특정 객체를 “얕게” 복사함 object.assign({}, 복사할 객체) assign을 통해 복사를 할 경우,이는 얕은 복사이기 때문에 한 층에 대한 변경은 원본 배열 객체에는 영향을 주지 않는다! 하지만, 더 깊은 층에 대한 변경은 원본 배열에도 영향을 준다 예시123456789101112131415161718192021const hoonjoo = { name: 'hoonjoo', country: 'Korea', social: { twitter: '@hoon', instagram: '#hooonjooo', },};const second = object.assign({}, hoonjoo);// 이 경우 원본 배열에는 영향 주지 않음 (원본 : Korea, 복사본 : USA)second.country = 'USA';//하지만....// 이 경우 social의 층이 깊기 때문에 원본 배열에도 영향을 준다second.social.instagram = '$hooonjooo';//따라서 이 두 결과값은 동일하다hoonjoo.social;second.social; 그렇다면 딥 클론을 할 수 있는 방법은? 편법!!1const second = JSON.parse(JSON.stringify(hoonjoo));","link":"/javascript/wesbos/14.%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%8E%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%A9%20vs%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%89%E1%85%A1/"},{"title":"[Wesbos] 로컬스토리지 &amp; 이벤트 위임","text":"로컬스토리지의 활용법과 이벤트 위임이라는 굉장히 유용한 기능을 배울 수 있는 챕터였다. (어려웠지만….. ㅋㅋ) 물론 mongoDB와 같은 DB를 사용하면 크게 사용할 일은 없겠지만, 간단한 웹서비스 등을 만들 때에는 유용할 것 같다. 로직 사용할 객체들 변수화 하기 (const) + 이벤트리스너와 함수 생성 &lt;input&gt;에입력한 값을 인식할 수 있도록 함수 설정 add item(submit)을 누르면 가 append! append된 요소들이 로컬스토리지에 저장 되도록 설정 체크박스의 체크 유무 또한 로컬 스토리지에 저장 되도록 설정 (위임도 필요) 삭제 기능 추가 const 선언 💡 Add item버튼, html에 추가될 아이템 ul, 아이템 배열을 생성하여 변수화해준다. 123const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const items = []; addEventListener1234567function addItem(e) { e.preventDefault(); //잘 작동하는지 확인! console.log('hi');}addItems.addEventListener('submit', addItem); event.preventDefault() 💡 페이지의 이동 또는 리로드가 실행되지 않도록 막아준다! ⇒ 이 챕터에선 submit을 눌러도 페이지가 새로고침되지 않고 submit만 될 수 있도록 하기 위해 사용 &lt;input&gt;에 입력한 텍스트 인식 💡 &lt;input&gt; 에 입력한 값이 잘 불러와질 수 있도록 addItem 함수를 수정보완 1234567891011121314function addItem(e) { e.preventDefault(); // 입력된 값을 text로 변수화 text = this.querySelector('[name=item]').value; // 객체 생성 item = { text: text, done: false, }; //찍어보기 console.log(item); // 미리 생성한 배열인 items에 item을 push} 미리 생성한 배열인 items에 item을 push!123456789function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item);} setItem() 💡 로컬스토리지 객체에 접근하여 항목 하나를 추가한다 ⭐️JSON.stringify()⭐️ 💡 JavaScript값이나 객체를 JSON형태의 문자열로 변환한다. (배열 자체가 문자열이 되어 반환된다고 생각하면 편할듯?) 12console.log(JSON.stringify({ x: 5, y: 6 }));// 예상 결과값 : &quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot; 버튼 누르면 → 아이템(&lt;li&gt;) append! 💡 우선 appendList라는 함수를 생성해주자. 1234567891011121314function appendList(plates = [], platesList) { platesList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;item${i}&quot; ${ plate.done ? 'checked' : '' } /&gt; &lt;label for=&quot;item${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join(''); // map에 의해서 콤마(,)가 append될 때마다 붙기 때문에 이를 제거하기 위해 join을 사용!} localStoragegetItem() 💡 로컬스토리지 내에서 항목을 읽어냄 ⭐️JSON.parse()⭐️ 💡 문자열로 구성된 JSON을 JavaScript값이나 객체로 반환한다. 문자열 → JavaScript 객체 123456789101112131415161718// 로컬 스토리지에 저장된 메뉴가 있으면 불러오고, 없으면 빈 배열!const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); // input박스에 입력될 텍스트를 변수화 const text = this.querySelector('[name=item]').value; const item = { text: text, // 체크박스에 활용할 Boolean값 done: false, }; items.push(item); populateList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();} 체크 유무 저장 💡 위의 items 객체에서 설정한 done의 boolean값을 저장하여체크박스의 체크 유무를 새로고침해도 유지될 수 있도록 설정 12345678function toggleDone(e) { if (!e.target.matches('input')) return; // input 태그가 아니면 종료 (label도 찍힐 수 있기 때문) const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; // 반대값 설정 트릭 ! localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);} 삭제기능 추가 💡 wrapper 하단에 Clear All 버튼을 만들어 준 뒤, localStorage.removeItem() 을 사용해서 삭제기능을 구현하면 된다. removeItem() 💡 로컬 스토리지에서 항목 하나를 제거한다. 1234567891011// 클리어 버튼 변수화const clear = document.querySelector('.clear');function removeAll() { localStorage.removeItem('items'); // removeItem은 로컬스토리지 삭제 기능만 하기 때문에, li가 제거될 수 있도록 새로고침을 해준다. location.reload();}// 클릭 이벤트 &amp; 함수 할당clear.addEventListener('click', removeAll); 최종 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const addItems = document.querySelector('.add-items');const itemsList = document.querySelector('.plates');const clear = document.querySelector('.clear');const items = JSON.parse(localStorage.getItem('items')) || [];function addItem(e) { e.preventDefault(); text = this.querySelector('[name=item]').value; const item = { text: text, done: false, }; items.push(item); appendList(items, itemsList); localStorage.setItem('items', JSON.stringify(items)); this.reset();}// 원본 훼손을 최대한 방지하기 위해 items 복사!function appendList(plates = [], plateList) { plateList.innerHTML = plates .map((plate, i) =&gt; { return ` &lt;li&gt; &lt;input type=&quot;checkbox&quot; data-index=${i} id=&quot;items${i}&quot; ${ plate.done ? 'checked' : '' }/&gt; &lt;label for=&quot;items${i}&quot;&gt;${plate.text}&lt;/label&gt; &lt;/li&gt; `; }) .join('');}function toggleDone(e) { if (!e.target.matches('input')) return; // skip this unless it's an input const el = e.target; const index = el.dataset.index; items[index].done = !items[index].done; localStorage.setItem('items', JSON.stringify(items)); appendList(items, itemsList);}function removeAll() { localStorage.removeItem('items'); location.reload();}clear.addEventListener('click', removeAll);addItems.addEventListener('submit', addItem);itemsList.addEventListener('click', toggleDone);appendList(items, itemsList);","link":"/javascript/wesbos/15.%20%E1%84%85%E1%85%A9%E1%84%8F%E1%85%A5%E1%86%AF%E1%84%89%E1%85%B3%E1%84%90%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8C%E1%85%B5%20&%20%E1%84%8B%E1%85%B5%E1%84%87%E1%85%A6%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%B1%E1%84%8B%E1%85%B5%E1%86%B7/"},{"title":"[Wesbos] Mouse Move Shadow","text":"mousemove 이벤트가 일어날 때마다해당 텍스트의 그림자가 마우스 위치로 이동하는 기능을 구현하면 된다. 로직 const와 함수 생성 및 할당 마우스 offset값 활용 해당 값을 style.textShadow에 적용! const와 함수 생성 및 할당 💡 마우스가 움직일 공간인 뷰포트와 h1태그를 변수화 한 후, 함수를 생성해준다. 123456789const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { // 확인해보기! console.log(e);}hero.addEventListener('mousemove', shadow); offsetX &amp; offsetY 값의 활용 💡 canvas 챕터에서 사용했었던 offset값을 다시 활용해보자. 1234function shadow(e) { let { offsetX: x, offsetY: y } = e; console.log(x, y);} 하지만… hero 안에 자식요소로 &lt;h1&gt; 태그가 존재하기 때문에text위에 마우스를 올리면 자식요소에 대한 offset값이 출력된다. 🤔 X축에 대해선 offsetLeft를, Y축에 대해선 offsetTop을 활용하면 된다. 123456789function shadow(e) { let { offsetX: x, offsetY: y } = e; // 즉, 뷰포트인 hero가 타게팅되고 있지 않다면~ if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; }} offset 값을 px로 반환하여 활용 💡 기본 단위를 선언 ⇒ 픽셀 값으로 반환하여 적용 12345678910111213141516function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this !== e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } // 내가 마우스를 움직인 만큼의 거리가 뷰포트 내에서 몇 퍼센트인지 xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; // 위의 값을 css에 적용! text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;} 최종 완성 코드1234567891011121314151617181920const hero = document.querySelector('.hero');const text = hero.querySelector('h1');function shadow(e) { const { offsetWidth: width, offsetHeight: height } = hero; let { offsetX: x, offsetY: y } = e; if (this != e.target) { x = x + e.target.offsetLeft; y = y + e.target.offsetTop; } xWalk = Math.round((x / width) * 100) - 50; yWalk = Math.round((y / height) * 100) - 50; text.style.textShadow = ` ${xWalk}px ${yWalk}px 0 rgba(161, 231, 233, 1) `;}hero.addEventListener('mousemove', shadow);","link":"/javascript/wesbos/16.%20Mouse%20Move%20Shadow/"},{"title":"[Wesbos] 배열 조건부 정렬","text":"보통 가수 이름이나, 노래 제목 등을 정렬할 때관사 The, a, an 등은 참조하지 않은 채로 정렬을 한다고 한다. 이를 바탕으로 sort() 등을 활용해 정렬해보자. 로직 정렬에 조건 걸기 (/ ^(a | the | an)/) 정렬하기 sort() 정렬된 것 ul에 넣어주기 innerHTML 참조한 관사 (A, The, An)에만 CSS값 주기 정렬에 조건 걸기 💡 굉장히 새로운 내용이었다. 내가 제거하고 싶은 부분들을 제거해서 배열을 새로 만든 다음에, 이것을 기준으로 정렬한다는 것이 참신했다. 우선, bands 배열 내에 있는 오브젝트들의 관사를 제거해주는 함수를 만들어보자. 12345678// bandName 인자가 들어오면 -&gt; a, the, an을 제거하고 양 옆 공백을 삭제하여 반환해준다.function strip(bandName) { return bandName.replace(/^(a |the |an )/i, '').trim(); // 반드시 | 뒤에 공백이 없어야 한다. 공백까지 인식해버림..}console.log(strip('the hoonjoo Park'));// 잘 기능하는지 찍어보기 string.trim() 💡 문자열에서 양 옆에 있는 공백을 제거해준다. 정렬하기 💡 기초체력 다지기에서 공부했듯이, sort() 를 사용하면 된다. 12// 코드는 항상 최대한 간결하게 !!const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1)); 정렬한 것 화면에 띄우기123const bandUl = document.querySelector('#bands');bandUl.innerHTML = sortedBands.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join(''); 참조한 관사 (A, The, An)에만 CSS값 주기 💡 Type Ahead 챕터에서 사용했던 정규식 RegExp() 를 활용해봤다. 우선… 새로운 특정 관사가 &lt;span class=&quot;hl&quot;&gt;&lt;/span&gt; 로 replace될 수 있도록 해보자 12345678910111213// map을 통해 새로운 배열을 생성해야 하므로 anThe를 만들어서 써보자const anThe = sortedBands.map((node) =&gt; { // 첫 문자 &amp; 대소문자를 구분하는 regex 생성 const regex = new RegExp(/^(A |The |An )/g); // 노드 내에서 regex와 일치하는 (A The An)을 matchRegex에 할당 const matchRegex = node.match(regex); // replace를 통해 해당 regex값이 &lt;span&gt;태그가 붙은 형태로 바뀌어질 수 있도록! const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;}); 최종 완성 코드12345678910111213141516171819202122232425262728293031323334const bands = [ 'The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil', 'Norma Jean', 'The Bled', 'Say Anything', 'The Midway State', 'We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive', 'Anywhere But Here', 'An Old Dog',];const bandUl = document.querySelector('#bands');function strip(bandName) { return bandName.replace(/^(a |the |an)/i, '').trim();}const sortedBands = bands.sort((a, b) =&gt; (strip(a) &gt; strip(b) ? 1 : -1));const anThe = sortedBands.map((node) =&gt; { const regex = new RegExp(/^(A |The |An )/g); const matchRegex = node.match(regex); const newSortedBands = node.replace( regex, `&lt;span class=&quot;hl&quot;&gt;${matchRegex}&lt;/span&gt;` ); return newSortedBands;});const appendBand = anThe.map((band) =&gt; `&lt;li&gt;${band}&lt;/li&gt;`).join('');bandUl.innerHTML = appendBand;","link":"/javascript/wesbos/17.%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%20%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB%E1%84%87%E1%85%AE%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF/"},{"title":"[Wesbos] reduce와 map 응용","text":"[data-time]에 저장되어 있는 시간 값들의 총합을 구하여 비디오의 총 러닝타임을 구해보자 로직 const를 통해 사용할 요소 선언 map과 split을 통해 값 정제 reduce()를 통해 총합 구하기! 시간들을 수학적 계산을 통해 알맞게 전환 const 선언부터… 💡 이번 챕터에선 간단하게 &lt;li&gt; 태그들만 선언 해줘도 된다. 12345// nodelist로 표현되긴 하지만, 실제 배열은 아니기 때문에 배열에 집어넣어줘야 함!const timeNodes = Array.from(document.querySelectorAll('[data-time]'));console.log(timeNodes); map과 split을 통해 시간값 정제 💡 우선… 원활한 계산을 위해 [분 : 초]의 형식에서 “:”을 제거해주고 정수화시켜줘야 될 것 같다. dataset.time🤔 태그 내에 [data-OOO]이 저장되어 있다면, dataset.OOO 을 통해 그 값을 불러올 수 있다. 12345678910const seconds = timeNodes // 노드들은 이제 data-time에 적힌 값이 됐음 .map((node) =&gt; node.dataset.time) // 이것을 timeCode라고 하고, :을 기준으로 나눠서 왼쪽은 mins, 오른쪽은 secs로 할당 .map((timeCode) =&gt; { // 정수화!! const [mins, secs] = timeCode.split(':').map(parseFloat); // mins는 분 형식이니까 초 값으로 만들려면 곱하기 60! return mins * 60 + secs; }); reduce를 사용하여 총합 구하기123.reduce((acc, current) =&gt; acc + current);console.log(seconds); 계산 → “시 : 분 : 초”로 나타내기 💡 시 → 분 → 초 순서대로 계산을 해보자한 시간은 3600초… 1234567891011// secondsLeft를 활용해서 계속 남은 초를 계산let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);// 3600초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);// 60초로 나눈 나머지 = 남은 초secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft); 최종 완성 코드123456789101112131415161718192021const timeNodes = Array.from(document.querySelectorAll('[data-time]'));const totalTime = document.querySelector('p');const seconds = timeNodes .map((node) =&gt; node.dataset.time) .map((timeCode) =&gt; { const [mins, secs] = timeCode.split(':').map(parseFloat); return mins * 60 + secs; }) .reduce((acc, current) =&gt; acc + current);let secondsLeft = seconds;const hours = Math.floor(seconds / 3600);secondsLeft = secondsLeft % 3600;const minutes = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, minutes, secondsLeft);totalTime.innerHTML = `&lt;span&gt;${hours}시간 ${minutes}분 ${secondsLeft}초&lt;/span&gt;`;","link":"/javascript/wesbos/18.%20reduce%E1%84%8B%E1%85%AA%20map%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC/"},{"title":"3.TCP&#x2F;IP","text":"TCP/IP란? 네트워크 아키텍처란, 하나의 언어이자 약속의 집합이다. 이러한 언어 중에서도 통용되는 언어가 있는데 그게 바로 TCP/IP다. TCP/IP의 계층구조 (OSI 4계층) 네트워크 아키텍처는 프로토콜들(규약)의 집합이다. 효율적 통신을 위해 이러한 프로토콜들을 계층화 하는데, 가장 널리 쓰이는 계층화 구조는 4계층 구조이다. (물론 OSI 7계층도 존재한다) 네트워크 인터페이스층 ⇒ 같은 네트워크 안에서의 데이터를 전송하는 역할 인터넷층 ⇒ 서로 다른 네트워크 간에 데이터를 전송하는 역할 (중개자) 트랜스포트층 ⇒ TCP or UDP를 통한 데이터의 배분 (to 특정한 복수의 애플리케이션) 애플리케이션층 ⇒ 애플리케이션의 기능을 실행하기 위해, 그에 맞는 데이터의 형식과 처리 방법 등을 결정하는 역할(HTTP, SMTP, POP3, DHCP, DNS 등의 프로토콜이 존재) 데이터의 송수신 규칙 (feat. 헤더) 위에서 설명했듯이, 프로토콜들은 계층화 되어 있다.따라서 애플리케이션이 정상적으로 데이터를 주고받기 위해선 이러한 프로토콜들을 조합해야 한다. 캡슐화와 역캡슐화 헤더에는 데이터의 출발지 주소, 그리고 목적지 주소가 담긴다. 그리고 이러한 헤더는 다음 프로토콜에 송신되어, 또 다시 새로운 헤더로 포장된다. 즉, 계층별 출발지와 목적지 정보가 차근차근 입력되며 쌓이는 것이다. 클라이언트(브라우저)에서 서버로 데이터를 전송하는 과정 위의 그림과 같이 브라우저~이더넷을 거치며 각 헤더들이 캡슐화되어 쌓인다.그리고 마지막으로 이더넷에서 물리적 신호로 변환하여 전송 매체로 데이터를 보낸다. 데이터를 수신하는 입장인 서버는 이러한 헤더를 받아 이더넷에서 쌓인 FCS와 이더넷 헤더를 읽고 자신한테 전달된 데이터가 맞는지 확인한다. 이후 역순으로 IP - TCP - HTTP 헤더들을 차례대로 벗겨내며 읽어나간다. 데이터별 명칭 HTTP(애플리케이션층) : HTTP메시지 TCP(트랜스포트층) : TCP 세그먼트 IP(인터넷층) : IP 패킷 이더넷(네트워크 인터페이스층) : 이더넷 프레임 IP (Internet Protocol) IP의 역할은 ‘엔드투엔드 통신’을 하는 것이다.즉, 특정 PC에서 다른 PC로 데이터를 전송하는 것이다. 보내고자 하는 데이터를 IP 패킷으로 포장한다. IP헤더에는 출발지 IP주소와 목적지 IP주소가 담긴다. 이를 참조하여 데이터는 다른 목적지 IP를 가진 컴퓨터로 전송되는 것이다. 하지만 만약 해당 목적지 주소가 다른 네트워크에 존재한다면, 라우터를 통해 다른 네트워크로 데이터가 전송된다. 이를 라우팅이라 한다. IP는 어떻게 구성될까 도트형으로 10진 표기된다. (ex. 192.168.0.1) 위에서는 컴퓨터(호스트) 자체의 주소를 IP라고 설명했다. 하지만 사실 IP는 호스트의 인터페이스를 식별하는 것이다. 따라서, 한 호스트가 여러 인터페이스를 보유하고 있을 경우 (유선 인터페이스, 무선LAN 인터페이스 등등) 인터페이스마다 IP주소를 설정할 수 있다. IP의 목적지 유니캐스트, 브로드캐스트, 멀티캐스트 유니캐스트 : 단 하나의 주소로 데이터를 전송 할 때(가장 일반적) 브로드캐스트 : 같은 네트워크 안에 있는 모든 호스트에게 똑같은 데이터를 전송할 때 멀티캐스트 : 특정 그룹을 지정하여 똑같은 데이터를 전송할 때 IP주소의 구성 IP주소는 네트워크부 + 호스트부로 구성된다. (고정되지 않고 가변적임) 네트워크부는 말 그대로 네트워크 자체를 식별한다 (이 네트워크로 보내줘!)⇒ 서브넷 마스크를 통해 IP주소 안에서 어디까지가 네트워크부인지 식별할 수 있다. 호스트부는 네트워크 안에서의 호스트를 식별한다. (이 호스트에게 보내줘!) 네트워크 접속 네트워크 접속에는 두 단계가 존재한다.물리적 접속 → 논리적 접속 물리적 접속 네트워크 인터페이스 층에서 이루어지며, 말 그대로 물리적인 신호를 주고받을 수 있도록 하는 것이다. 예를 들어 LAN선을 기기에 연결시키거나, 와이파이 연결을 위해 무선LAN 엑세스 포인트에 접속하는 것이다. 논리적 접속 위에서 설명했던 것 처럼, 네트워크 연결을 위해서는 인터페이스에 IP주소가 반드시 필요하다. 이러한 IP를 설정하는 것이 논리적 접속의 단계다. 물론 IP주소를 직접 설정하는 것은 전문가가 아니라면 어렵기 때문에 DHCP라는 기술을 통해 자동으로 IP주소를 설정할 수 있다. IP의 역할과 활동","link":"/cs/network/TCP:IP/"},{"title":"2.네트워크의 구성","text":"네트워크를 구성하는 기기 네트워크 연결을 위해서는 기기와 기기 간의 연결이 필요하다.이러한 연결을 돕는 데에 가장 주요한 세 개의 기기가 존재한다. 라우터 레이어2 스위치 레이어3 스위치 데이터 전송처리 절차 네트워크 기기는 물리적 신호를 전달 받아 디지털 신호(0,1)로 변환하여 다른 기기로 다시 전송해준다. 데이터 수신 ⇒ 물리적 신호로 변환된 데이터를 받아서 디지털 신호로 변환한다. 데이터를 보낼 곳 결정 ⇒ 데이터에는 부가적인 제어 정보도 함께 담겨서 온다. 이를 활용해 네트워크 기기는 데이터 전송 대상을 설정한다. 데이터 전송 ⇒ 다시 디지털 신호(0,1)을 물리적 신호로 변환하여 송신 대상에게 데이터를 전송한다. 네트워크의 구체적 구성 네트워크 연결을 위해 우리는 일반적으로 인터페이스(포트)를 통해 각 기기를 연결한다. 이더넷 포트 ? LAN 포트? ⇒ 모두 이더넷 인터페이스를 통칭하는 말이다. 이더넷 인터페이스란, 현재 가장 널리 통용되는 인터페이스다. 💡 우리는 이 인터페이스를 통해 물리적 신호와 디지털 신호 등이 전송될 수 있도록 현관문의 역할을 해준다. LAN을 구축하는 방법 LAN은 근거리 네트워크를 의미한다.그렇다면 기기와 기기를 연결해서 어떻게 인터넷 네트워크를 구현한다는 것일까? LAN에도 당연히 라우터, 레이어2 스위치와 같은 네트워크 기기가 필요하다. ⇒ 그리고 PC 또는 노트북에 네트워크 연결을 위한 인터페이스가 존재해야 한다. 사용자 PC의 인터페이스(포트)에 LAN선을 연결하고, 이 선을 또 네트워크 기기의 인터페이스에 연결해준다. 그러면 이제 네트워크 기기를 통해 데이터를 주고 받을 수 있다.","link":"/cs/network/%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AE%E1%84%89%E1%85%A5%E1%86%BC/"},{"title":"1.네트워크의 기본","text":"네트워크란 무엇인가? 네트워크란, 한 마디로 “연결”을 의미한다.학교도 선생님과 학생들을 이어주는 네트워크, 회사도, 집도 모두 네트워크의 일환이다. 컴퓨터 네트워크 ⇒ 하지만 컴퓨터 네트워크는 “데이터를 주고 받기 위한 네트워크”를 의미한다. 카톡 메시지를 주고 받는 것, 인터넷에서 정보를 검색하거나 작성하는 것 모두 데이터의 전달 과정이 그 기반이 된다. 사설 네트워크 (인트라넷) 사설 네트워크는 사용자의 제한을 두는 제한적인 네트워크다. ⇒ 인트라넷, LAN 등이 이에 포함될 수 있다. 인터넷 누구나 접속이 가능한 네트워크다 ⇒ 해커, 옆집 강아지(?), 할아버지 할머니 등등 브라우저를 통해 누구든지 인터넷에 접속할 수 있다. LAN과 WAN LAN과 WAN은 사설 네트워크(인트라넷 등)에 사용되는 네트워크다. LAN (Local Area Network) ⇒ 가까운 범위 내의 기기들을 라우터 등을 통해 연결시키고, 기기 간의 데이터 통신 등이 가능하도록 네트워크를 구성한다. 즉, 가까운 거리에 있는 기계와 기계를 연결시킨다! WAN (Wide Area Network) ⇒ 위의 LAN을 다른 거점의 LAN과 연결시킬 수 있도록 연결해주는 역할을 한다.즉, LAN과 LAN의 연결을 돕는 징검다리라고 생각하면 편하다. 인터넷 그렇다면 근거리 기기간의 통신이 아닌, 각기 떨어져 있는 세상의 모든 사람들과 통신할 수 있는 방법은 뭘까? → 바로 인터넷이다. AS와 ISP AS : 자율 시스템(Autonomous System)⇒ 전세계의 다양한 조직들이 운영하는 네트워크조직 등을 구성하는 네트워크 생태계 ISP : Internet Service Provider⇒ 쉽게 설명하자면, 네트워크 서비스를 제공해주는 기업을 의미한다. 1티어 ISP로는 SKT, KT, LG U+ 등이 있다. 하위 티어의 영세 ISP도 많은데, 이들의 통신은 어쩔 수 없이 1티어 ISP를 경유할 수밖에 없다즉, 우리는 인터넷을 이용하고자 한다면… 1티어 ISP를 반드시 사용하게 된다. 서버와 클라이언트, 그리고 애플리케이션 인터넷을 통해 데이터를 주고받는다는 것은 알겠다.그렇다면 그 데이터가 도대체 어떻게 저장되고 어디에 저장되는 것인가? 서버와 클라이언트 클라이언트 서버 일반적인 우리들의 컴퓨터 굉장히 좋은 컴퓨터 주로 서버에 데이터를 “요청(Reuest)” 클라이언트로 부터 요청을 처리 (Response) ⇒ 클라이언트(우리)는 서버에 어떠한 특정 요청을 보내고 → 서버는 이러한 요청을 처리한 뒤 응답(Response)를 보내준다. 고객이 레스토랑에서 웨이터에게 주문을 하는 것과 같다고 보면 된다. 이러한 이유 때문에 서버의 컴퓨터 성능은 고성능이 요구된다. 애플리케이션 서버에서 데이터를 받아 처리하는 역할을 하는 것이 애플리케이션이다.클라이언트 사이드에서 반환된 데이터를 받아내는 것 또한 클라이언트의 애플리케이션이다. 네트워크 아키텍처와 프로토콜 그럼 어떤 방식으로 데이터를 주고 받을까?⇒ 네트워크를 통한 올바른 데이터 송수신을 위해선 규칙과 규약 등이 필요하다. 프로토콜 ⇒ 우리가 한국어를 사용할 때 막 사용하는 것이 아니듯이, 네트워크 또한 통신을 할 때 자기가 원하는 대로 규칙없이 대화를 하지는 않는다. 한국어에도 문법, 훈민정음, 발음, 상황에 따른 용법 등 다양한 규칙과 기준이 존재하듯, 네트워크 통신에도 이러한 다양한 규칙(프로토콜)들이 존재한다. 즉, 프로토콜은 네트워크 통신을 위한 규약이자 규칙들의 단편들이다. 네트워크 아키텍처 ⇒ 위의 프로토콜들이 종합된 것이 네트워크 아키텍처다.한국어, 영어와 같이 하나의 언어라고 생각하면 된다. TCP/IP 전세계적으로 영어가 공용어로 통하듯이, 대부분 통용되는 네트워크 아키텍처의 표준은 TCP/IP다. 이러한 네트워크 아키텍처를 효율적으로 운용하기 위해 아키텍처는 프로토콜들을 단순히 집약해놓은 것이 아니라, 계층화 하여 기능별로 구분해 둔다. TCP/IP의 계층 애플리케이션 계층 트랜스포트 계층 인터넷층 네트워크 인터페이스층 클라우드 네트워크 전통적인 방식은 회사 등이 자체적으로 서버를 구축하여 운용하고 관리하는 것이었다.하지만 시대가 변함에 따라, 인터넷만 통해서 가상의 (물리적으로 떨어져있는) 서버를 구축할 수 있게 되었고, 우리는 이를 클라우드 서비스라고 부른다. 클라우드 서비스의 종류 Iaas : 하드웨어만 사용 가능 Paas : 하드웨어와 OS, Middleware등의 시스템 플랫폼을 활용 가능하다. Saas : 하드웨어와 플랫폼 뿐만 아니라, 애플리케이션 기능까지 모두 사용 가능하다⇒ 대표적인 예로 AWS를 들 수 있다.","link":"/cs/network/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%9D%98%20%EA%B8%B0%EB%B3%B8/"}],"tags":[{"name":"Redux","slug":"Redux","link":"/tags/Redux/"},{"name":"그리디 알고리즘","slug":"그리디-알고리즘","link":"/tags/%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"Wesbos Challenge","slug":"Wesbos-Challenge","link":"/tags/Wesbos-Challenge/"},{"name":"네트워크","slug":"네트워크","link":"/tags/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"}],"categories":[{"name":"프론트엔드","slug":"프론트엔드","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"Redux","slug":"프론트엔드/Redux","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Redux/"},{"name":"백준","slug":"알고리즘/백준","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EB%B0%B1%EC%A4%80/"},{"name":"Javascript","slug":"프론트엔드/Javascript","link":"/categories/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C/Javascript/"},{"name":"프로그래머스","slug":"알고리즘/프로그래머스","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Network","slug":"CS/Network","link":"/categories/CS/Network/"}]}